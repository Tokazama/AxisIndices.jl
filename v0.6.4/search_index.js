var documenterSearchIndex = {"docs":
[{"location":"comparison/#Comparison-to-Other-Packages","page":"Comparison to Other Packages","title":"Comparison to Other Packages","text":"","category":"section"},{"location":"comparison/","page":"Comparison to Other Packages","title":"Comparison to Other Packages","text":"This is very brief overview of how AxisIndices compares to other packages. Rather than a comprehensive comparison of available alternatives and integrations, this is intended to provide a general idea of how AxisIndices fits in the Julia ecosystem.","category":"page"},{"location":"comparison/","page":"Comparison to Other Packages","title":"Comparison to Other Packages","text":"AxisArrays.jl similarly supports mapping some sort of keys to each set of indices. AxisIndices is intended to be a more comprehensive, well documented, and flexible implementation of this concept. AxisArays natively offers the ability to name each dimension. In contrast AxisIndices was developed with the intention of using packages like NamedDims.jl to more fully implement such features in a complementary way.","category":"page"},{"location":"comparison/","page":"Comparison to Other Packages","title":"Comparison to Other Packages","text":"DimensionalData.jl is a notable package that covers many similar funcitonalities as AxisArrays did. There are numerous differences in design decisions between this package and DimensionalData. It's likely that the majority of these differences represent personal preferences rather than strictly objective advantages over one another. In terms of approach, DimensionalData offers a more comprehensive alternative to the functionality of AxisArrays, where AxisIndices is intended only to be a highly customizable component of some of the features AxisArrays offers. Therefore, this package expects users seeking a complete replacement for AxisArrays to ultimately use another package that composes a modular solution to replacing AxisArrays.","category":"page"},{"location":"comparison/","page":"Comparison to Other Packages","title":"Comparison to Other Packages","text":"There are many packages that offer overlapping features. For example, Dictionaries.jl implements a focused improvement on dictionaries where mapping keys to indices highly overlaps. However, as Dictionaries.jl continues to evolve many of the types provided therein may prove extremely useful in constructing the keys of an Axis type thereby giving these dictionaries multidimensional functionality. Similarly, many packages provide overlapping features that could actually be extended with the addition of AxisIndices.","category":"page"},{"location":"development/#Development","page":"Development","title":"Development","text":"","category":"section"},{"location":"development/#Style","page":"Development","title":"Style","text":"","category":"section"},{"location":"development/","page":"Development","title":"Development","text":"In addition to attempting to follow the BlueStyle guide this package also attempts to consistently use the following conventions internally.","category":"page"},{"location":"development/","page":"Development","title":"Development","text":"axis - refers to an AbstractAxis\nks - refers to the keys of an axis\ninds - refers to the indices of an axis\narg(s) - ","category":"page"},{"location":"observations/#Observations","page":"Observations","title":"Observations","text":"","category":"section"},{"location":"observations/","page":"Observations","title":"Observations","text":"The AxisIndices.ObservationDims module is experimental and demonstrates the convenience of generating methods using the @defdim macro.","category":"page"},{"location":"observations/#Example-usage","page":"Observations","title":"Example usage","text":"","category":"section"},{"location":"observations/","page":"Observations","title":"Observations","text":"Let's create some data where each observation represents a unique set of subject measurements.","category":"page"},{"location":"observations/","page":"Observations","title":"Observations","text":"julia> using AxisIndices\n\njulia> data = NamedAxisArray(reshape(1:6, 2, 3), x = 2:3, observations = [:subject_1, :subject_2, :subject_3])\n2×3 NamedAxisArray{Int64,2}\n • x - 2:3\n • observations - [:subject_1, :subject_2, :subject_3]\n      subject_1   subject_2   subject_3\n  2           1           3           5\n  3           2           4           6\n","category":"page"},{"location":"observations/","page":"Observations","title":"Observations","text":"The ObservationDims module isn't necessary to access observations or subject specific data...","category":"page"},{"location":"observations/","page":"Observations","title":"Observations","text":"julia> data[observations = :subject_1]\n2-element NamedAxisArray{Int64,1}\n • x - 2:3\n\n  2   1\n  3   2\n","category":"page"},{"location":"observations/","page":"Observations","title":"Observations","text":"...but there are a number of convenient methods for accessing observation data with this module.","category":"page"},{"location":"observations/","page":"Observations","title":"Observations","text":"julia> using AxisIndices.ObservationDims\n\njulia> obsdim(data)  # the dimension along which observations are enumerated\n2\n\njulia> nobs(data)  # the number of distinct observations\n3\n\njulia> obs_keys(data)  # the key for each observation\n3-element Array{Symbol,1}:\n :subject_1\n :subject_2\n :subject_3\n","category":"page"},{"location":"observations/","page":"Observations","title":"Observations","text":"There are several other useful methods such as each_obs which supports iterating along the observation dimension. Such methods may be helpful in development of an API. For example, multiple dispatch could be used to return an observation iterator with each_obs on non array types also.","category":"page"},{"location":"observations/#Reference","page":"Observations","title":"Reference","text":"","category":"section"},{"location":"observations/","page":"Observations","title":"Observations","text":"Pages   = [\"observations.md\"]\nModules = [AxisIndices.ObservationDims]\nOrder   = [:function, :type]","category":"page"},{"location":"observations/","page":"Observations","title":"Observations","text":"Modules = [AxisIndices.ObservationDims]","category":"page"},{"location":"observations/#AxisIndices.ObservationDims.each_obs-Tuple{Any}","page":"Observations","title":"AxisIndices.ObservationDims.each_obs","text":"each_obs(x)\n\nCreate a generator that iterates over the obs dimensions A, returning views that select all the data from the other dimensions in A.\n\n\n\n\n\n","category":"method"},{"location":"observations/#AxisIndices.ObservationDims.has_obsdim-Tuple{Any}","page":"Observations","title":"AxisIndices.ObservationDims.has_obsdim","text":"has_obsdim(x) -> Bool\n\nReturns true if x has a dimension corresponding to obs.\n\n\n\n\n\n","category":"method"},{"location":"observations/#AxisIndices.ObservationDims.nobs-Tuple{Any}","page":"Observations","title":"AxisIndices.ObservationDims.nobs","text":"nobs(x) -> Int\n\nReturns the size along the dimension corresponding to the obs.\n\n\n\n\n\n","category":"method"},{"location":"observations/#AxisIndices.ObservationDims.obs_axis-Tuple{Any,Any}","page":"Observations","title":"AxisIndices.ObservationDims.obs_axis","text":"obs_axis(x, size[; first_pad=nothing, last_pad=nothing, stride=nothing, dilation=nothing])\n\nReturns an AxisIterator along the obs axis.\n\n\n\n\n\n","category":"method"},{"location":"observations/#AxisIndices.ObservationDims.obs_axis-Tuple{Any}","page":"Observations","title":"AxisIndices.ObservationDims.obs_axis","text":"obs_axis(x)\n\nReturns the axis corresponding to the obs dimension.\n\n\n\n\n\n","category":"method"},{"location":"observations/#AxisIndices.ObservationDims.obs_axis_type-Tuple{Any}","page":"Observations","title":"AxisIndices.ObservationDims.obs_axis_type","text":"obs_axis_type(x)\n\nReturns the key type corresponding to the obs axis.\n\n\n\n\n\n","category":"method"},{"location":"observations/#AxisIndices.ObservationDims.obs_indices-Tuple{Any}","page":"Observations","title":"AxisIndices.ObservationDims.obs_indices","text":"obs_indices(x)\n\nReturns the indices corresponding to the obs axis\n\n\n\n\n\n","category":"method"},{"location":"observations/#AxisIndices.ObservationDims.obs_keys-Tuple{Any}","page":"Observations","title":"AxisIndices.ObservationDims.obs_keys","text":"obs_keys(x)\n\nReturns the keys corresponding to the obs axis\n\n\n\n\n\n","category":"method"},{"location":"observations/#AxisIndices.ObservationDims.obsdim-Tuple{Any}","page":"Observations","title":"AxisIndices.ObservationDims.obsdim","text":"obsdim(x) -> Int\n\nReturns the dimension corresponding to obs.\n\n\n\n\n\n","category":"method"},{"location":"observations/#AxisIndices.ObservationDims.select_obs-Tuple{Any,Any}","page":"Observations","title":"AxisIndices.ObservationDims.select_obs","text":"select_obs(x, i)\n\nReturn a view of all the data of x where the index for the obs dimension equals i.\n\n\n\n\n\n","category":"method"},{"location":"axis/#The-Axis-Interface","page":"Axis Interface","title":"The Axis Interface","text":"","category":"section"},{"location":"axis/","page":"Axis Interface","title":"Axis Interface","text":"The following describes the components necessary to construct and manipulate existing and new subtypes of AbstractAxis.","category":"page"},{"location":"axis/","page":"Axis Interface","title":"Axis Interface","text":"AbstractAxis Type Usage\nAxis Attach keys to indices\nSimpleAxis Give standard indices access AxisIndices's syntax\nCenteredAxis Enforce indexing that is centered around zero\nOffsetAxis Enforce indexing with where the first index is offset from 1\nIdentityAxis Preserve indices after indexing\nMetaAxis Attach arbitrary metadata to an axis\nStructAxis Map a type's field names and field types to each element along an axis.","category":"page"},{"location":"axis/#Introduction","page":"Axis Interface","title":"Introduction","text":"","category":"section"},{"location":"axis/","page":"Axis Interface","title":"Axis Interface","text":"The supertype to all axis types herein is the AbstractAxis, which is a subtype of AbstractUnitRange{<:Integer}.","category":"page"},{"location":"axis/","page":"Axis Interface","title":"Axis Interface","text":"If we have a set of keys a b c and a set of indices 1 2 3 then the key a maps to the index 1. Given these definitions, the AbstractAxis differs from the classic dictionary in the following two ways:","category":"page"},{"location":"axis/","page":"Axis Interface","title":"Axis Interface","text":"The valtype of AbstractAxis is always an integer.\nThe values are always unique and continuous.","category":"page"},{"location":"axis/","page":"Axis Interface","title":"Axis Interface","text":"The two main axis types defined here are Axis and SimpleAxis. The standard syntax for indexing doesn't change at all for these types.","category":"page"},{"location":"axis/","page":"Axis Interface","title":"Axis Interface","text":"julia> using AxisIndices\n\njulia> using Dates\n\njulia> using ChainedFixes  # provides `and`, `or`, `⩓`, `⩔` methods\n\njulia> sa = SimpleAxis(1:10)\nSimpleAxis(1:10)\n\njulia> sa[2]\n2\n\njulia> sa[>(2)]\nSimpleAxis(3:10)\n\njulia> a = Axis(1:10)\nAxis(1:10 => Base.OneTo(10))\n\njulia> a[2]\n2\n\njulia> a[2:3]\nAxis(2:3 => 2:3)","category":"page"},{"location":"axis/","page":"Axis Interface","title":"Axis Interface","text":"But now we can also use functions to index by the keys of an AbstractAxis.","category":"page"},{"location":"axis/","page":"Axis Interface","title":"Axis Interface","text":"julia> a = Axis(2.0:11.0, 1:10)\nAxis(2.0:1.0:11.0 => 1:10)\n\njulia> a[1]\n1\n\njulia> a[isequal(2.0)]\n1\n\njulia> a[>(2)]\nAxis(3.0:1.0:11.0 => 2:10)\n\njulia> a[>(2.0)]\nAxis(3.0:1.0:11.0 => 2:10)\n\njulia> a[and(>(2.0), <(8.0))]\nAxis(3.0:1.0:7.0 => 2:6)\n\njulia> sa[in(3:5)]\nSimpleAxis(3:5)","category":"page"},{"location":"axis/","page":"Axis Interface","title":"Axis Interface","text":"This also allows certain syntax special treatment because they are obviously not referring to traditional integer based indexing.","category":"page"},{"location":"axis/","page":"Axis Interface","title":"Axis Interface","text":"julia> x, y, z = Axis([:one, :two, :three]), Axis([\"one\", \"two\", \"three\"]), Axis(Second(1):Second(1):Second(3));\n\njulia> x[:one]\n1\n\njulia> x[:one] == y[\"one\"] == z[Second(1)]\ntrue\n\njulia> x[[:one, :two]]\n2-element Array{Int64,1}:\n 1\n 2","category":"page"},{"location":"axis/","page":"Axis Interface","title":"Axis Interface","text":"Note in the last example that a vector was returned instead of an AbstractAxis. An AbstractAxis is a subtype of AbstractUnitRange and therefore cannot be reformed after any operation that does not guarantee the return of another unit range. This is similar to the behavior of UnitRange in base.","category":"page"},{"location":"axis/#Indexing-an-Axis","page":"Axis Interface","title":"Indexing an Axis","text":"","category":"section"},{"location":"axis/","page":"Axis Interface","title":"Axis Interface","text":"Setup for running axis examples.","category":"page"},{"location":"axis/","page":"Axis Interface","title":"Axis Interface","text":"julia> using AxisIndices, Unitful, IntervalSets, ChainedFixes\n\njulia> using Unitful: s\n\njulia> time1 = Axis((1.5:.5:10)s)\nAxis((1.5:0.5:10.0) s => Base.OneTo(18))\n\njulia> time2 = Axis((1.5:.5:10)s, 2:19)\nAxis((1.5:0.5:10.0) s => 2:19)","category":"page"},{"location":"axis/#Indexing-With-Integers","page":"Axis Interface","title":"Indexing With Integers","text":"","category":"section"},{"location":"axis/","page":"Axis Interface","title":"Axis Interface","text":"Integers will map directly to the indices of an axis.","category":"page"},{"location":"axis/","page":"Axis Interface","title":"Axis Interface","text":"julia> time1[1]\n1\n\njulia> time1[2]\n2\n\njulia> time2[2]\n2\n\njulia> time2[1]\nERROR: BoundsError: attempt to access 18-element Axis((1.5:0.5:10.0) s => 2:19) at index [1]\n[...]","category":"page"},{"location":"axis/","page":"Axis Interface","title":"Axis Interface","text":"Notice that time2[1] throws an error. This is because the indices of the time2 axis don't contain a 1 and begins at 2. This allows an axis to map to any single dimensional memory mapping, even if it doesn't start at 1.","category":"page"},{"location":"axis/","page":"Axis Interface","title":"Axis Interface","text":"Indexing an axis with a collection of integers works similarly to indexing any other AbstractUnitRange. That is, using other subtypes of AbstractUnitRange preserves the structure...","category":"page"},{"location":"axis/","page":"Axis Interface","title":"Axis Interface","text":"julia> time1[1:2]\nAxis((1.5:0.5:2.0) s => 1:2)\n\njulia> time2[2:3]\nAxis((1.5:0.5:2.0) s => 2:3)","category":"page"},{"location":"axis/","page":"Axis Interface","title":"Axis Interface","text":"However, we can't ensure that the resulting range will have a step of one in other cases so only the indices are returned.","category":"page"},{"location":"axis/","page":"Axis Interface","title":"Axis Interface","text":"julia> time1[1:2:4]\n1:2:3\n\njulia> time1[[1, 2, 3]]\n3-element Array{Int64,1}:\n 1\n 2\n 3\n\njulia> time1[firstindex(time1):end]\nAxis((1.5:0.5:10.0) s => 1:18)\n","category":"page"},{"location":"axis/#Indexing-With-Keys","page":"Axis Interface","title":"Indexing With Keys","text":"","category":"section"},{"location":"axis/","page":"Axis Interface","title":"Axis Interface","text":"julia> time1[1.5s]\n1\n\njulia> time2[1.5s]\n2","category":"page"},{"location":"axis/","page":"Axis Interface","title":"Axis Interface","text":"julia> time1[1.5s..3s]\nAxis((1.5:0.5:3.0) s => 1:4)\n\njulia> time1[3s..4.5s]\nAxis((3.0:0.5:4.5) s => 4:7)","category":"page"},{"location":"axis/#Keys-and-Indices","page":"Axis Interface","title":"Keys and Indices","text":"","category":"section"},{"location":"axis/","page":"Axis Interface","title":"Axis Interface","text":"If our keys are integers and we want to ensure that we always refer keys we can use Keys","category":"page"},{"location":"axis/","page":"Axis Interface","title":"Axis Interface","text":"julia> Axis((2:11), 1:10)[Keys(<(5))]\nAxis(2:4 => 1:3)\n\njulia> Axis((2:11), 1:10)[Indices(<(5))]\nAxis(2:5 => 1:4)\n\njulia> Axis((2:11), 1:10)[Keys(3)]\n2\n\njulia> Axis((2:11), 1:10)[Indices(3)]\n3\n","category":"page"},{"location":"axis/#Approximate-Indexing","page":"Axis Interface","title":"Approximate Indexing","text":"","category":"section"},{"location":"axis/","page":"Axis Interface","title":"Axis Interface","text":"julia> axis = Axis([pi + 0, pi + 1]);\n\njulia> axis[3.141592653589793]\n1\n\njulia> axis[3.14159265358979]\nERROR: BoundsError: attempt to access 2-element Axis([3.141592653589793, 4.141592653589793] => OneToMRange(2)) at index [3.14159265358979]\n[...]\n\njulia> axis[isapprox(3.14159265358979)]\n1\n\njulia> axis[isapprox(3.14, atol=1e-2)]\n1","category":"page"},{"location":"axis/#Indexing-With-Functions","page":"Axis Interface","title":"Indexing With Functions","text":"","category":"section"},{"location":"axis/","page":"Axis Interface","title":"Axis Interface","text":"Operators that typically return true or false can often ","category":"page"},{"location":"axis/","page":"Axis Interface","title":"Axis Interface","text":"julia> time1[<(3.0s)]\nAxis((1.5:0.5:2.5) s => 1:3)\n\njulia> time1[>(3.0s)]\nAxis((3.5:0.5:10.0) s => 5:18)\n\njulia> time1[==(6.0s)]\n10\n\njulia> time1[!=(6.0s)] == vcat(1:9, 11:18)\ntrue","category":"page"},{"location":"axis/","page":"Axis Interface","title":"Axis Interface","text":"These operators can also be combined to get more specific regions of an axis.","category":"page"},{"location":"axis/","page":"Axis Interface","title":"Axis Interface","text":"julia> time1[and(>(2.5s), <(10.0s))]\nAxis((3.0:0.5:9.5) s => 4:17)\n\njulia> time1[>(2.5s) ⩓ <(10.0s)]  # equivalent to `and` you can use \\And<TAB>\nAxis((3.0:0.5:9.5) s => 4:17)\n\njulia> time1[or(<(2.5s),  >(9.0s))] == vcat(1:2, 17:18)\ntrue\n\njulia> time1[<(2.5s) ⩔ >(9.0s)] == vcat(1:2, 17:18) # equivalent to `or` you can use \\Or<TAB>\ntrue\n","category":"page"},{"location":"axis/#Performance","page":"Axis Interface","title":"Performance","text":"","category":"section"},{"location":"axis/","page":"Axis Interface","title":"Axis Interface","text":"Indexing CartesianAxes is comparable to that of CartesianIndices.","category":"page"},{"location":"axis/","page":"Axis Interface","title":"Axis Interface","text":"julia> using AxisIndices, BenchmarkTools\n\njulia> cartaxes = CartesianAxes((Axis(2.0:5.0), Axis(1:4)));\n\njulia> cartinds = CartesianIndices((1:4, 1:4));\n\njulia> @btime getindex(cartaxes, 2, 2)\n20.848 ns (1 allocation: 32 bytes)\nCartesianIndex(2, 2)\n\njulia> @btime getindex(cartinds, 2, 2)\n22.317 ns (1 allocation: 32 bytes)\nCartesianIndex(2, 2)\n\njulia> @btime getindex(cartaxes, ==(3.0), 2)\n444.374 ns (7 allocations: 416 bytes)\nCartesianIndex(2, 2)","category":"page"},{"location":"axis/","page":"Axis Interface","title":"Axis Interface","text":"Indexing LinearAxes is comparable to that of LinearIndices","category":"page"},{"location":"axis/","page":"Axis Interface","title":"Axis Interface","text":"julia> using AxisIndices, BenchmarkTools\n\njulia> linaxes = LinearAxes((Axis(1.0:4.0), Axis(1:4)));\n\njulia> lininds = LinearIndices((1:4, 1:4));\n\njulia> @btime getindex(linaxes, 2, 2)\n18.275 ns (0 allocations: 0 bytes)\n6\n\njulia> @btime getindex(lininds, 2, 2)\n18.849 ns (0 allocations: 0 bytes)\n6\n\njulia> @btime getindex(linaxes, ==(3.0), 2)\n381.098 ns (6 allocations: 384 bytes)\n7","category":"page"},{"location":"axis/","page":"Axis Interface","title":"Axis Interface","text":"You may notice there's significant overhead for using the filtering syntax. However, the filtering syntax takes advantage of a special type in base, Fix2. This means that we can take advantage of filtering methods that have been optimized for specific types of keys.  Here we do the same thing as above but we create a function that knows it's going to perform filtering.","category":"page"},{"location":"axis/","page":"Axis Interface","title":"Axis Interface","text":"julia> getindex_filter(a, i1, i2) = a[==(i1), ==(i2)]\ngetindex_filter (generic function with 1 method)\n\njulia> @btime getindex_filter(linaxes, 3.0, 2)\n57.216 ns (0 allocations: 0 bytes)\n7\n\njulia> linaxes2 = LinearAxes((Axis(Base.OneTo(4)), Axis(Base.OneTo(4))));\n\njulia> @btime getindex_filter(linaxes2, 3, 2)\n22.070 ns (0 allocations: 0 bytes)\n7","category":"page"},{"location":"axis/","page":"Axis Interface","title":"Axis Interface","text":"Indexing linaxes is much faster now that it can be optimized inside of a function call. However, it's still a little over twice as slow as normal indexing. That's largely because of the cost of searching 1.0:4.0 (which is a StepRangeLen type in this case). The second benchmark demonstrates how close we really are to standard indexing given similar range types.","category":"page"},{"location":"pretty_printing/#Pretty-Printing","page":"Pretty Printing","title":"Pretty Printing","text":"","category":"section"},{"location":"pretty_printing/","page":"Pretty Printing","title":"Pretty Printing","text":"It's important that we can view the custom indices that we assign to arrays. Yet a surprising challenge of implementing and using arrays in interactive programming is how complicated printing them can be. Rather than burdening users with cryptic text readouts this package seeks to provide \"pretty\" printing (quotes because beauty is in the eye of the beholder). This package leans heavily on the PrettyTables.jl package to accomplish this by handing off everything that goes through the show method to pretty_array. pretty_array in turn repeatedly calls PrettyTables.pretty_print along slices of arrays.","category":"page"},{"location":"pretty_printing/","page":"Pretty Printing","title":"Pretty Printing","text":"warning: Warning\nLike much of this package, pretty printing is continually being developed at this time. Unlike most of this package, improvements in visualizing arrays is subjective and more likely to result changes that are noticeable to users. Therefore, users are encouraged to utilize related functionality and provide feedback but should not yet rely on these methods for tests in other packages.","category":"page"},{"location":"styles/#AxisIndices-Styles","page":"AxisIndices Styles","title":"AxisIndices Styles","text":"","category":"section"},{"location":"styles/","page":"AxisIndices Styles","title":"AxisIndices Styles","text":"TODO","category":"page"},{"location":"styles/#Documentation","page":"AxisIndices Styles","title":"Documentation","text":"","category":"section"},{"location":"styles/","page":"AxisIndices Styles","title":"AxisIndices Styles","text":"Modules = [AxisIndices.Styles]","category":"page"},{"location":"styles/#AxisIndices.Styles.AxisIndicesStyle","page":"AxisIndices Styles","title":"AxisIndices.Styles.AxisIndicesStyle","text":"AxisIndicesStyle\n\nSupertype for traits that control the behavior of AxisIndices.to_index and AxisIndices.to_key.\n\n\n\n\n\n","category":"type"},{"location":"styles/#AxisIndices.Styles.BoolElement","page":"AxisIndices Styles","title":"AxisIndices.Styles.BoolElement","text":"BoolElement\n\nA subtype of AxisIndicesStyle for mapping an argument that refers to a single Bool to a single index.\n\n\n\n\n\n","category":"type"},{"location":"styles/#AxisIndices.Styles.BoolsCollection","page":"AxisIndices Styles","title":"AxisIndices.Styles.BoolsCollection","text":"BoolsCollection\n\nA subtype of AxisIndicesStyle for mapping a collection of Bools to a collection of indices.\n\n\n\n\n\n","category":"type"},{"location":"styles/#AxisIndices.Styles.CartesianElement","page":"AxisIndices Styles","title":"AxisIndices.Styles.CartesianElement","text":"CartesianElement\n\nA subtype of AxisIndicesStyle for mapping an argument that refers to a CartesianIndex to a single index.\n\n\n\n\n\n","category":"type"},{"location":"styles/#AxisIndices.Styles.CartesianIndexCollection","page":"AxisIndices Styles","title":"AxisIndices.Styles.CartesianIndexCollection","text":"CartesianIndexCollection\n\nA subtype of AxisIndicesStyle for propagating an argument to a collection of indices.\n\n\n\n\n\n","category":"type"},{"location":"styles/#AxisIndices.Styles.IndexElement","page":"AxisIndices Styles","title":"AxisIndices.Styles.IndexElement","text":"IndexElement\n\nA subtype of AxisIndicesStyle for propagating an argument to a single index.\n\n\n\n\n\n","category":"type"},{"location":"styles/#AxisIndices.Styles.IndexEquals","page":"AxisIndices Styles","title":"AxisIndices.Styles.IndexEquals","text":"IndexEquals\n\nA subtype of AxisIndicesStyle for mapping a single index in a isequal(index) argument to a single index.\n\n\n\n\n\n","category":"type"},{"location":"styles/#AxisIndices.Styles.Indices","page":"AxisIndices Styles","title":"AxisIndices.Styles.Indices","text":"Indices(arg)\n\nForces arg to refer to indices when indexing.\n\n\n\n\n\n","category":"type"},{"location":"styles/#AxisIndices.Styles.IndicesCollection","page":"AxisIndices Styles","title":"AxisIndices.Styles.IndicesCollection","text":"IndicesCollection\n\nA subtype of AxisIndicesStyle for propagating an argument to a collection of indices.\n\n\n\n\n\n","category":"type"},{"location":"styles/#AxisIndices.Styles.IndicesFix2","page":"AxisIndices Styles","title":"AxisIndices.Styles.IndicesFix2","text":"IndicesFix2\n\nA subtype of AxisIndicesStyle for mapping all indices from fixed argument (e.g., >(indices)) to the corresponding collection of indices.\n\n\n\n\n\n","category":"type"},{"location":"styles/#AxisIndices.Styles.IndicesIn","page":"AxisIndices Styles","title":"AxisIndices.Styles.IndicesIn","text":"IndicesIn\n\nA subtype of AxisIndicesStyle for mapping all keys given in(keys) to a collection of indices.\n\n\n\n\n\n","category":"type"},{"location":"styles/#AxisIndices.Styles.IntervalCollection","page":"AxisIndices Styles","title":"AxisIndices.Styles.IntervalCollection","text":"IntervalCollection\n\nA subtype of AxisIndicesStyle for mapping an interval argument (start..stop) from keys within said interval to a collection of indices.\n\n\n\n\n\n","category":"type"},{"location":"styles/#AxisIndices.Styles.KeyElement","page":"AxisIndices Styles","title":"AxisIndices.Styles.KeyElement","text":"KeyElement\n\nA subtype of AxisIndicesStyle for mapping an argument that refers to a single key to a single index.\n\n\n\n\n\n","category":"type"},{"location":"styles/#AxisIndices.Styles.KeyEquals","page":"AxisIndices Styles","title":"AxisIndices.Styles.KeyEquals","text":"KeyEquals\n\nA subtype of AxisIndicesStyle for mapping a single key in a isequal(key) argument to a single index.\n\n\n\n\n\n","category":"type"},{"location":"styles/#AxisIndices.Styles.KeyedStyle","page":"AxisIndices Styles","title":"AxisIndices.Styles.KeyedStyle","text":"KeyedStyle{S}\n\nA subtype of AxisIndicesStyle indicating that the axis is a always defaults to key based indexing.\n\n\n\n\n\n","category":"type"},{"location":"styles/#AxisIndices.Styles.Keys","page":"AxisIndices Styles","title":"AxisIndices.Styles.Keys","text":"Keys(arg)\n\nForces arg to refer to keys when indexing.\n\n\n\n\n\n","category":"type"},{"location":"styles/#AxisIndices.Styles.KeysCollection","page":"AxisIndices Styles","title":"AxisIndices.Styles.KeysCollection","text":"KeysCollection\n\nA subtype of AxisIndicesStyle for mapping a collection of keys a collection of indices.\n\n\n\n\n\n","category":"type"},{"location":"styles/#AxisIndices.Styles.KeysFix2","page":"AxisIndices Styles","title":"AxisIndices.Styles.KeysFix2","text":"KeysFix2\n\nA subtype of AxisIndicesStyle for mapping all keys from fixed argument (e.g., >(key)) to the corresponding collection of indices.\n\n\n\n\n\n","category":"type"},{"location":"styles/#AxisIndices.Styles.KeysIn","page":"AxisIndices Styles","title":"AxisIndices.Styles.KeysIn","text":"KeysIn\n\nA subtype of AxisIndicesStyle for mapping all keys given in(keys) to a collection of indices.\n\n\n\n\n\n","category":"type"},{"location":"styles/#AxisIndices.Styles.SliceCollection","page":"AxisIndices Styles","title":"AxisIndices.Styles.SliceCollection","text":"SliceCollection\n\nA subtype of AxisIndicesStyle indicating that the entire axis should be propagated.\n\n\n\n\n\n","category":"type"},{"location":"styles/#AxisIndices.Styles.is_collection-Tuple{Any}","page":"AxisIndices Styles","title":"AxisIndices.Styles.is_collection","text":"is_collection(x) -> Bool\n\nWhether x is an AxisIndicesStyle, returns true if it's used to index a collection of indices.\n\n\n\n\n\n","category":"method"},{"location":"styles/#AxisIndices.Styles.is_element-Union{Tuple{T}, Tuple{T}} where T","page":"AxisIndices Styles","title":"AxisIndices.Styles.is_element","text":"is_element(x) -> Bool\n\nWhether x is an AxisIndicesStyle, returns true if it's used to index a single element.\n\n\n\n\n\n","category":"method"},{"location":"styles/#AxisIndices.Styles.is_index-Union{Tuple{T}, Tuple{T}} where T","page":"AxisIndices Styles","title":"AxisIndices.Styles.is_index","text":"is_index(x) -> Bool\n\nWhether x is an AxisIndicesStyle, returns true if it's used to search the indices space.\n\n\n\n\n\n","category":"method"},{"location":"styles/#AxisIndices.Styles.is_key-Tuple{Any}","page":"AxisIndices Styles","title":"AxisIndices.Styles.is_key","text":"is_key(x) -> Bool\n\nWhether x is an AxisIndicesStyle, returns true if it's used to search the keys space.\n\n\n\n\n\n","category":"method"},{"location":"compatibility/#Compatibility","page":"Compatibility","title":"Compatibility","text":"","category":"section"},{"location":"compatibility/","page":"Compatibility","title":"Compatibility","text":"The following packages outside of the Base module have some form of support. In addition to creating awareness of existing functionality, the following provides users with a better idea of how exactly these packages are supported. This means features existing outside of those described here are not within the domain of intended coverage and users should seek support linked resources.","category":"page"},{"location":"compatibility/#MappedArrays","page":"Compatibility","title":"MappedArrays","text":"","category":"section"},{"location":"compatibility/","page":"Compatibility","title":"Compatibility","text":"MappedArrays.jl allows \"lazy\" in-place elementwise transformations of arrays. Support is provided by overloading the mappedarray method, which AxisIndices does not export (i.e. users must using mappedArrays to get access to it). In order to avoid method ambiguities multi-mapping of mixed AbstractArray and AbstractAxisIndices cannot be provided. In other words, the current version can only support multi-mapping multiple AbstractAxisIndices.","category":"page"},{"location":"compatibility/#NamedDims","page":"Compatibility","title":"NamedDims","text":"","category":"section"},{"location":"compatibility/","page":"Compatibility","title":"Compatibility","text":"Indexing via named dimensions is supported via the NamedDims.jl package. NamedAxisArray assists in constructing arrays that have both named dimensions and a subtype of AbstractAxis along each axis.","category":"page"},{"location":"compatibility/#EllipsisNotattion","page":"Compatibility","title":"EllipsisNotattion","text":"","category":"section"},{"location":"compatibility/","page":"Compatibility","title":"Compatibility","text":"Use .. when indexing an array for all indices before or after it's use (see Array Interface). ","category":"page"},{"location":"compatibility/#Tables.jl","page":"Compatibility","title":"Tables.jl","text":"","category":"section"},{"location":"compatibility/","page":"Compatibility","title":"Compatibility","text":"The Table.jl API is supported through the Table type (see Tabular Interface)","category":"page"},{"location":"standard_library/#Standard-Library","page":"Standard Library","title":"Standard Library","text":"","category":"section"},{"location":"standard_library/","page":"Standard Library","title":"Standard Library","text":"Base.deleteat!\nBase.rotr90\nBase.rotl90\nBase.rot180\nBase.similar\nBase.reshape\nBase.inv\nLinearAlgebra.diag\nLinearAlgebra.lu\nLinearAlgebra.lq\nLinearAlgebra.qr\nLinearAlgebra.svd\nStatistics.cor\nStatistics.cov","category":"page"},{"location":"standard_library/#Base.deleteat!","page":"Standard Library","title":"Base.deleteat!","text":"deleteat!(a::AbstractAxisVector, arg)\n\nRemove the items corresponding to A[arg], and return the modified a. Subsequent items are shifted to fill the resulting gap. If the axis of a is an SimpleAxis then it is shortened to match the length of a.\n\nExamples\n\njulia> using AxisIndices\n\njulia> x = AxisArray([1, 2, 3, 4]);\n\njulia> axes_keys(deleteat!(x, 3))\n(OneToMRange(3),)\n\njulia> x = AxisArray([1, 2, 3, 4], [\"a\", \"b\", \"c\", \"d\"]);\n\njulia> axes_keys(deleteat!(x, \"c\"))\n([\"a\", \"b\", \"d\"],)\n\n\n\n\n\n\n","category":"function"},{"location":"standard_library/#Base.rotr90","page":"Standard Library","title":"Base.rotr90","text":"rotr90(A::AbstractAxisMatrix)\n\nRotate A right 90 degrees, along with its axes keys.\n\nExamples\n\njulia> using AxisIndices\n\njulia> a = AxisArray([1 2; 3 4], [\"a\", \"b\"], [\"one\", \"two\"]);\n\njulia> b = rotr90(a);\n\njulia> axes_keys(b)\n([\"one\", \"two\"], [\"b\", \"a\"])\n\njulia> a[\"a\", \"one\"] == b[\"one\", \"a\"]\ntrue\n\n\n\n\n\n","category":"function"},{"location":"standard_library/#Base.rotl90","page":"Standard Library","title":"Base.rotl90","text":"rotl90(A::AbstractAxisMatrix)\n\nRotate A left 90 degrees, along with its axes keys.\n\nExamples\n\njulia> using AxisIndices\n\njulia> a = AxisArray([1 2; 3 4], [\"a\", \"b\"], [\"one\", \"two\"]);\n\njulia> b = rotl90(a);\n\njulia> axes_keys(b)\n([\"two\", \"one\"], [\"a\", \"b\"])\n\njulia> a[\"a\", \"one\"] == b[\"one\", \"a\"]\ntrue\n\n\n\n\n\n\n","category":"function"},{"location":"standard_library/#Base.rot180","page":"Standard Library","title":"Base.rot180","text":"rot180(A::AbstractAxisMatrix)\n\nRotate A 180 degrees, along with its axes keys.\n\nExamples\n\njulia> using AxisIndices\n\njulia> a = AxisArray([1 2; 3 4], [\"a\", \"b\"], [\"one\", \"two\"]);\n\njulia> b = rot180(a);\n\njulia> axes_keys(b)\n([\"b\", \"a\"], [\"two\", \"one\"])\n\njulia> c = rotr90(rotr90(a));\n\njulia> axes_keys(c)\n([\"b\", \"a\"], [\"two\", \"one\"])\n\njulia> a[\"a\", \"one\"] == b[\"a\", \"one\"] == c[\"a\", \"one\"]\ntrue\n\n\n\n\n\n","category":"function"},{"location":"standard_library/#Base.similar","page":"Standard Library","title":"Base.similar","text":"similar(axis::AbstractAxis, new_keys::AbstractVector) -> AbstractAxis\n\nCreate a new instance of an axis of the same type as axis but with the keys new_keys\n\nExamples\n\njulia> using AxisIndices\n\njulia> similar(Axis(1.0:10.0, 1:10), [:one, :two])\nAxis([:one, :two] => 1:2)\n\n\n\n\n\nsimilar(axis::AbstractAxis, new_keys::AbstractVector, new_indices::AbstractUnitRange{Integer} [, check_length::Bool=true] ) -> AbstractAxis\n\nCreate a new instance of an axis of the same type as axis but with the keys new_keys and indices new_indices. If check_length is true then the lengths of new_keys and new_indices are checked to ensure they have the same length before construction.\n\nExamples\n\njulia> using AxisIndices\n\njulia> similar(Axis(1.0:10.0, 1:10), [:one, :two], UInt(1):UInt(2))\nAxis([:one, :two] => 0x0000000000000001:0x0000000000000002)\n\njulia> similar(Axis(1.0:10.0, 1:10), [:one, :two], UInt(1):UInt(3))\nERROR: DimensionMismatch(\"keys and indices must have same length, got length(keys) = 2 and length(indices) = 3.\")\n[...]\n\n\n\n\n\nsimilar(axis::AbstractAxis, new_indices::AbstractUnitRange)\n\nCreate a new instance of an axis of the same type as axis but with the keys new_keys\n\nExamples\n\njulia> using AxisIndices\n\njulia> similar(SimpleAxis(1:10), 1:3)\nSimpleAxis(1:3)\n\n\n\n\n\n","category":"function"},{"location":"standard_library/#Base.reshape","page":"Standard Library","title":"Base.reshape","text":"reshape(A::AbstractAxisArray, shape)\n\nReshape the array and axes of A.\n\nExamples\n\njulia> using AxisIndices\n\njulia> A = reshape(AxisArray(Vector(1:8), [:a, :b, :c, :d, :e, :f, :g, :h]), 4, 2);\n\njulia> axes(A)\n(Axis([:a, :b, :c, :d] => Base.OneTo(4)), SimpleAxis(Base.OneTo(2)))\n\njulia> axes(reshape(A, 2, :))\n(Axis([:a, :b] => Base.OneTo(2)), SimpleAxis(Base.OneTo(4)))\n\n\n\n\n\n","category":"function"},{"location":"standard_library/#Base.inv","page":"Standard Library","title":"Base.inv","text":"inv(M::AbstractAxisMatrix)\n\nComputes the inverse of an AbstractAxisMatrixMatrix\n\njulia> using AxisIndices, LinearAlgebra\n\njulia> M = AxisArray([2 5; 1 3], [\"a\", \"b\"], [:one, :two]);\n\njulia> axes_keys(inv(M))\n([:one, :two], [\"a\", \"b\"])\n\n\n\n\n\n\n","category":"function"},{"location":"standard_library/#LinearAlgebra.diag","page":"Standard Library","title":"LinearAlgebra.diag","text":"diag(M::AbstractAxisMatrix, k::Integer=0; dim::Val=Val(1))\n\nThe kth diagonal of an AbstractAxisMatrixMatrix, M. The keyword argument dim specifies which which dimension's axis to preserve, with the default being the first dimension. This can be change by specifying dim=Val(2) instead.\n\njulia> using AxisIndices, LinearAlgebra\n\njulia> A = AxisArray([1 2 3; 4 5 6; 7 8 9], [\"a\", \"b\", \"c\"], [:one, :two, :three]);\n\njulia> axes_keys(diag(A))\n([\"a\", \"b\", \"c\"],)\n\njulia> axes_keys(diag(A, 1; dim=Val(2)))\n([:one, :two],)\n\n\n\n\n\n\n","category":"function"},{"location":"standard_library/#LinearAlgebra.lu","page":"Standard Library","title":"LinearAlgebra.lu","text":"lu(A::AbstractAxisArray, args...; kwargs...)\n\nCompute the LU factorization of an AbstractAxisArray A.\n\nExamples\n\njulia> using AxisIndices, LinearAlgebra\n\njulia> m = AxisArray([1.0 2; 3 4], (Axis(2:3 => Base.OneTo(2)), Axis(3:4 => Base.OneTo(2))));\n\njulia> F = lu(m);\n\njulia> keys.(axes(F.L))\n(2:3, Base.OneTo(2))\n\njulia> keys.(axes(F.U))\n(Base.OneTo(2), 3:4)\n\njulia> keys.(axes(F.p))\n(2:3,)\n\njulia> keys.(axes(F.P))\n(2:3, 2:3)\n\njulia> keys.(axes(F.P * m))\n(2:3, 3:4)\n\njulia> keys.(axes(F.L * F.U))\n(2:3, 3:4)\n\n\n\n\n\n","category":"function"},{"location":"standard_library/#LinearAlgebra.lq","page":"Standard Library","title":"LinearAlgebra.lq","text":"lq(A::AbstractAxisArray, args...; kwargs...)\n\nCompute the LQ factorization of an AbstractAxisArray A.\n\nExamples\n\njulia> using AxisIndices, LinearAlgebra\n\njulia> m = AxisArray([1.0 2; 3 4], (Axis(2:3 => Base.OneTo(2)), Axis(3:4 => Base.OneTo(2))));\n\njulia> F = lq(m);\n\njulia> keys.(axes(F.L))\n(2:3, Base.OneTo(2))\n\njulia> keys.(axes(F.Q))\n(Base.OneTo(2), 3:4)\n\njulia> keys.(axes(F.L * F.Q))\n(2:3, 3:4)\n\n\n\n\n\n","category":"function"},{"location":"standard_library/#LinearAlgebra.qr","page":"Standard Library","title":"LinearAlgebra.qr","text":"qr(F::AbstractAxisArray, args...; kwargs...)\n\nCompute the QR factorization of an AbstractAxisArray A.\n\nExamples\n\njulia> using AxisIndices, LinearAlgebra\n\njulia> m = AxisArray([1.0 2; 3 4], (Axis(2:3 => Base.OneTo(2)), Axis(3:4 => Base.OneTo(2))));\n\njulia> F = qr(m, Val(true));\n\njulia> keys.(axes(F.Q))\n(2:3, Base.OneTo(2))\n\njulia> keys.(axes(F.R))\n(Base.OneTo(2), 3:4)\n\njulia> keys.(axes(F.Q * F.R))\n(2:3, 3:4)\n\njulia> keys.(axes(F.p))\n(2:3,)\n\njulia> keys.(axes(F.P))\n(2:3, 2:3)\n\njulia> keys.(axes(F.P * AxisArray([1.0 2; 3 4], (2:3, 3:4))))\n(2:3, 3:4)\n\n\n\n\n\n","category":"function"},{"location":"standard_library/#LinearAlgebra.svd","page":"Standard Library","title":"LinearAlgebra.svd","text":"svd(F::AbstractAxisArray, args...; kwargs...)\n\nCompute the singular value decomposition (SVD) of an AbstractAxisArray A.\n\nExamples\n\njulia> using AxisIndices, LinearAlgebra\n\njulia> m = AxisArray([1.0 2; 3 4], (Axis(2:3 => Base.OneTo(2)), Axis(3:4 => Base.OneTo(2))));\n\njulia> F = svd(m);\n\njulia> axes(F.U)\n(Axis(2:3 => Base.OneTo(2)), SimpleAxis(Base.OneTo(2)))\n\njulia> axes(F.V)\n(Axis(3:4 => Base.OneTo(2)), SimpleAxis(Base.OneTo(2)))\n\njulia> axes(F.Vt)\n(SimpleAxis(Base.OneTo(2)), Axis(3:4 => Base.OneTo(2)))\n\njulia> axes(F.U * Diagonal(F.S) * F.Vt)\n(Axis(2:3 => Base.OneTo(2)), Axis(3:4 => Base.OneTo(2)))\n\n\n\n\n\n\n","category":"function"},{"location":"standard_library/#Statistics.cor","page":"Standard Library","title":"Statistics.cor","text":"cor(x::AbstractAxisMatrix; dims=1, kwargs...)\n\nPerforms cor on the parent matrix of x and reconstructs a similar type with the appropriate axes.\n\nExamples\n\njulia> using AxisIndices, Statistics\n\njulia> A = AxisArray([1 2 3; 4 5 6; 7 8 9], [\"a\", \"b\", \"c\"], [:one, :two, :three]);\n\njulia> axes_keys(cor(A, dims = 2))\n([\"a\", \"b\", \"c\"], [\"a\", \"b\", \"c\"])\n\njulia> axes_keys(cor(A, dims = 1))\n([:one, :two, :three], [:one, :two, :three])\n\n\n\n\n\n\n","category":"function"},{"location":"standard_library/#Statistics.cov","page":"Standard Library","title":"Statistics.cov","text":"cov(x::AbstractAxisMatrix; dims=1, kwargs...)\n\nPerforms cov on the parent matrix of x and reconstructs a similar type with the appropriate axes.\n\nExamples\n\njulia> using AxisIndices, Statistics\n\njulia> A = AxisArray([1 2 3; 4 5 6; 7 8 9], [\"a\", \"b\", \"c\"], [:one, :two, :three]);\n\njulia> axes_keys(cov(A, dims = 2))\n([\"a\", \"b\", \"c\"], [\"a\", \"b\", \"c\"])\n\njulia> axes_keys(cov(A, dims = 1))\n([:one, :two, :three], [:one, :two, :three])\n\n\n\n\n\n\n","category":"function"},{"location":"acknowledgments/#Acknowledgments","page":"Acknowledgments","title":"Acknowledgments","text":"","category":"section"},{"location":"acknowledgments/","page":"Acknowledgments","title":"Acknowledgments","text":"This package is the result of many people providing input to make it successful. Hopefully, it will continue to be a product of such collaborations. The following is an incomplete list of individuals who have helped me in some way get this package started. It's mainly a list of people who have tolerated my incessant queries into many minor details that led to this package.","category":"page"},{"location":"acknowledgments/","page":"Acknowledgments","title":"Acknowledgments","text":"Eric Davies\nLyndon White\nMichael Abbott\nRafael Schouten\nTim Holy","category":"page"},{"location":"acknowledgments/","page":"Acknowledgments","title":"Acknowledgments","text":"Also, anyone that has contributed to StaticArrays.jl and NamedDims.jl has probably helped.","category":"page"},{"location":"quick_start/#Quick-Start","page":"Quick Start","title":"Quick Start","text":"","category":"section"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"Custom indexing only requires specifying a tuple of keys[1] for the indices of each dimension.","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"julia> using AxisIndices\n\njulia> A = AxisArray(reshape(1:9, 3,3),\n               (2:4,        # first dimension has keys 2:4\n                3.0:5.0));  # second dimension has keys 3.0:5.0","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"Most code should work just the same for an AxisArray...","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"julia> A[1, 1]\n1\n\njulia> A[1:2, 1:2] == parent(A)[1:2, 1:2]\ntrue\n\njulia> sum(A) == sum(parent(A))\ntrue","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"But now the indices of each dimension have keys that we can filter through.","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"julia> A[==(2), ==(3.0)] == parent(A)[findfirst(==(2), 2:4), findfirst(==(3.0), 3.0:5.0)] == 1\ntrue\n\njulia> A[<(4), <(5.0)] == parent(A)[findall(<(4), 2:4), findall(<(5.0), 3.0:5.0)] == [1 4; 2 5]\ntrue","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"Any value that is not a CartesianIndex or subtype of Real is considered a dedicated key type. In other words, it could never be used for default indexing and will be treated the same as the == filtering syntax above.","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"julia> AxisArray([1, 2, 3], ([\"one\", \"two\", \"three\"],))[\"one\"]\n1","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"Note that the first call only returns a single element, where the last call returns an array. This is because all keys must be unique so there can only be one value that returns true if filtering by ==, which is the same as indexing by 1 (e.g., only one index can equal 1). The last call uses operators that can produce any number of true values and the resulting output is an array. This is the same as indexing an array by any vector (i.e., returns another array).","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"[1]: Terminology here is important here. Keys, indices, and axes each have a specific meaning. Throughout the documentation the following functional definitions apply:axis: maps a set of keys to a set of indices.\nindices: a set of integers (e.g., <:Integer) that locate the in memory locations of elements.\nkeys: maps a set of any type to a set of indices\nindexing: anytime one calls getindex or uses square brackets to navigate the elements of a collectionAlso note the use of argument (abbreviated arg in code) and arguments (abbreviated args in code). These terms specifically refer to what users pass to an indexing method. Therefore, an argument may be a key (:a), index (1), or something else that maps to one of the two (==(1)).","category":"page"},{"location":"axis_arrays/#AxisArrays","page":"AxisArrays","title":"AxisArrays","text":"","category":"section"},{"location":"axis_arrays/#References","page":"AxisArrays","title":"References","text":"","category":"section"},{"location":"axis_arrays/","page":"AxisArrays","title":"AxisArrays","text":"AxisIndices.indices\nAxisIndices.indices_type\nAxisIndices.keys_type\n\nAxisIndices.row_axis\nAxisIndices.row_keys\nAxisIndices.row_type\n\nAxisIndices.col_axis\nAxisIndices.col_keys\nAxisIndices.col_type\n\nAxisIndices.AbstractAxis\nAxisIndices.Axis\nAxisIndices.SimpleAxis\n\nAxisIndices.StructAxis\nAxisIndices.struct_view\nAxisIndices.CartesianAxes\nAxisIndices.LinearAxes\n\nAxisIndices.AbstractAxisArray\nAxisIndices.AxisArray","category":"page"},{"location":"axis_arrays/#AxisIndices.Interface.indices","page":"AxisArrays","title":"AxisIndices.Interface.indices","text":"indices(x::AbstractUnitRange)\n\nReturns the indices x.\n\nExamples\n\njulia> using AxisIndices\n\njulia> indices(Axis([\"a\"], 1:1))\n1:1\n\njulia> indices(CartesianIndex(1,1))\n(1, 1)\n\n\n\n\n\n\nindices(x, i)\n\nReturns the indices corresponding to the i axis\n\nExamples\n\njulia> using AxisIndices\n\njulia> indices(AxisArray(ones(2,2), (2:3, 3:4)), 1)\nBase.OneTo(2)\n\n\n\n\n\nindices(x) -> Tuple\n\nReturns the indices corresponding to all axes of x.\n\nExamples\n\njulia> using AxisIndices\n\njulia> indices(AxisArray(ones(2,2), (2:3, 3:4)))\n(Base.OneTo(2), Base.OneTo(2))\n\njulia> indices(Axis([\"a\"], 1:1))\n1:1\n\njulia> indices(CartesianIndex(1,1))\n(1, 1)\n\n\n\n\n\n\n","category":"function"},{"location":"axis_arrays/#AxisIndices.Interface.indices_type","page":"AxisArrays","title":"AxisIndices.Interface.indices_type","text":"indices_type(x, i)\n\nRetrieves axis values of the ith dimension of x.\n\nExamples\n\njulia> using AxisIndices\n\njulia> indices_type([1], 1)\nBase.OneTo{Int64}\n\njulia> indices_type(typeof([1]), 1)\nBase.OneTo{Int64}\n\n\n\n\n\nindices_type(x)\n\nRetrieves the type of the values of x. This should be functionally equivalent to typeof(values(x)).\n\nExamples\n\njulia> using AxisIndices\n\njulia>  indices_type(Axis(1:2))\nBase.OneTo{Int64}\n\njulia> indices_type(typeof(Axis(1:2)))\nBase.OneTo{Int64}\n\njulia> indices_type(typeof(1:2))\nUnitRange{Int64}\n\n\n\n\n\n","category":"function"},{"location":"axis_arrays/#AxisIndices.Interface.keys_type","page":"AxisArrays","title":"AxisIndices.Interface.keys_type","text":"keys_type(x, i)\n\nRetrieves axis keys of the ith dimension of x.\n\nExamples\n\njulia> using AxisIndices\n\njulia> keys_type(AxisArray([1], [\"a\"]), 1)\nArray{String,1}\n\n\n\n\n\nkeys_type(x)\n\nRetrieves the type of the keys of x.\n\nExamples\n\njulia> using AxisIndices\n\njulia> keys_type(Axis(1:2))\nUnitRange{Int64}\n\njulia> keys_type(typeof(Axis(1:2)))\nUnitRange{Int64}\n\njulia> keys_type(UnitRange{Int})\nBase.OneTo{Int64}\n\n\n\n\n\n","category":"function"},{"location":"axis_arrays/#AxisIndices.Interface.row_axis","page":"AxisArrays","title":"AxisIndices.Interface.row_axis","text":"row_axis(x) -> axis\n\nReturns the axis corresponding to the first dimension of x.\n\nExamples\n\njulia> using AxisIndices\n\njulia> row_axis(AxisArray(ones(2,2), [\"a\", \"b\"], [:one, :two]))\nAxis([\"a\", \"b\"] => Base.OneTo(2))\n\n\n\n\n\n\n","category":"function"},{"location":"axis_arrays/#AxisIndices.Interface.row_keys","page":"AxisArrays","title":"AxisIndices.Interface.row_keys","text":"row_keys(x) -> axis\n\nReturns the keys corresponding to the first dimension of x.\n\nExamples\n\njulia> using AxisIndices\n\njulia> row_keys(AxisArray(ones(2,2), [\"a\", \"b\"], [:one, :two]))\n2-element Array{String,1}:\n \"a\"\n \"b\"\n\n\n\n\n\n\n","category":"function"},{"location":"axis_arrays/#AxisIndices.Interface.row_type","page":"AxisArrays","title":"AxisIndices.Interface.row_type","text":"row_type(x)\n\nReturns the type of the axis corresponding to the first dimension of x.\n\nExamples\n\njulia> using AxisIndices\n\njulia> row_type(AxisArray(ones(2,2), [\"a\", \"b\"], [:one, :two]))\nAxis{String,Int64,Array{String,1},Base.OneTo{Int64}}\n\n\n\n\n\n","category":"function"},{"location":"axis_arrays/#AxisIndices.Interface.col_axis","page":"AxisArrays","title":"AxisIndices.Interface.col_axis","text":"col_axis(x) -> axis\n\nReturns the axis corresponding to the second dimension of x.\n\nExamples\n\njulia> using AxisIndices\n\njulia> col_axis(AxisArray(ones(2,2), [\"a\", \"b\"], [:one, :two]))\nAxis([:one, :two] => Base.OneTo(2))\n\n\n\n\n\n\n","category":"function"},{"location":"axis_arrays/#AxisIndices.Interface.col_keys","page":"AxisArrays","title":"AxisIndices.Interface.col_keys","text":"col_keys(x) -> axis\n\nReturns the keys corresponding to the second dimension of x.\n\nExamples\n\njulia> using AxisIndices\n\njulia> col_keys(AxisArray(ones(2,2), [\"a\", \"b\"], [:one, :two]))\n2-element Array{Symbol,1}:\n :one\n :two\n\n\n\n\n\n\n","category":"function"},{"location":"axis_arrays/#AxisIndices.Interface.col_type","page":"AxisArrays","title":"AxisIndices.Interface.col_type","text":"col_type(x)\n\nReturns the type of the axis corresponding to the second dimension of x.\n\nExamples\n\njulia> using AxisIndices\n\njulia> col_type(AxisArray(ones(2,2), [\"a\", \"b\"], [:one, :two]))\nAxis{Symbol,Int64,Array{Symbol,1},Base.OneTo{Int64}}\n\n\n\n\n\n","category":"function"},{"location":"axis_arrays/#AxisIndices.Axes.AbstractAxis","page":"AxisArrays","title":"AxisIndices.Axes.AbstractAxis","text":"AbstractAxis\n\nAn AbstractVector subtype optimized for indexing.\n\n\n\n\n\n","category":"type"},{"location":"axis_arrays/#AxisIndices.Axes.Axis","page":"AxisArrays","title":"AxisIndices.Axes.Axis","text":"Axis(k[, v=OneTo(length(k))])\n\nSubtypes of AbstractAxis that maps keys to values. The first argument specifies the keys and the second specifies the values. If only one argument is specified then the values span from 1 to the length of k.\n\nExamples\n\nThe value for all of these is the same.\n\njulia> using AxisIndices\n\njulia> x = Axis(2.0:11.0, 1:10)\nAxis(2.0:1.0:11.0 => 1:10)\n\njulia> y = Axis(2.0:11.0)  # when only one argument is specified assume it's the keys\nAxis(2.0:1.0:11.0 => Base.OneTo(10))\n\njulia> z = Axis(1:10)\nAxis(1:10 => Base.OneTo(10))\n\nStandard indexing returns the same values\n\njulia> x[2]\n2\n\njulia> x[2] == y[2] == z[2]\ntrue\n\njulia> x[1:2]\nAxis(2.0:1.0:3.0 => 1:2)\n\njulia> y[1:2]\nAxis(2.0:1.0:3.0 => 1:2)\n\njulia> z[1:2]\nAxis(1:2 => 1:2)\n\njulia> x[1:2] == y[1:2] == z[1:2]\ntrue\n\nFunctions that return true or false may be used to search the keys for their corresponding index. The following is equivalent to the previous example.\n\njulia> x[==(3.0)]\n2\n\njulia> x[==(3.0)] ==       # 3.0 is the 2nd key of x\n       y[isequal(3.0)] ==  # 3.0 is the 2nd key of y\n       z[==(2)]            # 2 is the 2nd key of z\ntrue\n\njulia> x[<(4.0)]  # all keys less than 4.0 are 2.0:3.0 which correspond to values 1:2\nAxis(2.0:1.0:3.0 => 1:2)\n\njulia> y[<=(3.0)]  # all keys less than or equal to 3.0 are 2.0:3.0 which correspond to values 1:2\nAxis(2.0:1.0:3.0 => 1:2)\n\njulia> z[<(3)]  # all keys less than or equal to 3 are 1:2 which correspond to values 1:2\nAxis(1:2 => 1:2)\n\njulia> x[<(4.0)] == y[<=(3.0)] == z[<(3)]\ntrue\n\nNotice that == returns a single value instead of a collection of all elements where the key was found to be true. This is because all keys must be unique so there can only ever be one element returned.\n\n\n\n\n\n","category":"type"},{"location":"axis_arrays/#AxisIndices.Axes.SimpleAxis","page":"AxisArrays","title":"AxisIndices.Axes.SimpleAxis","text":"SimpleAxis(v)\n\nPovides an AbstractAxis interface for any AbstractUnitRange, v. v will be considered both the values and keys of the return instance. \n\nExamples\n\nA SimpleAxis is useful for giving a standard set of indices the ability to use the filtering syntax for indexing.\n\njulia> using AxisIndices, StaticRanges\n\njulia> x = SimpleAxis(2:10)\nSimpleAxis(2:10)\n\njulia> x[2]\n2\n\njulia> x[==(2)]\n2\n\njulia> x[2] == x[==(2)]  # keys and values are same\ntrue\n\njulia> x[>(2)]\nSimpleAxis(3:10)\n\njulia> x[>(2)]\nSimpleAxis(3:10)\n\njulia> x[1]\nERROR: BoundsError: attempt to access 9-element SimpleAxis(2:10 => 2:10) at index [1]\n[...]\n\n\n\n\n\n","category":"type"},{"location":"axis_arrays/#AxisIndices.Axes.StructAxis","page":"AxisArrays","title":"AxisIndices.Axes.StructAxis","text":"StructAxis{T}\n\nAn axis that uses a structure T to form its keys. the field names of\n\n\n\n\n\n","category":"type"},{"location":"axis_arrays/#AxisIndices.Axes.struct_view","page":"AxisArrays","title":"AxisIndices.Axes.struct_view","text":"struct_view(A)\n\nCreates a MappedArray using the StructAxis of A to identify the dimension that needs to be collapsed into a series of SubArrays as views that composed the MappedArray\n\n\n\n\n\n","category":"function"},{"location":"axis_arrays/#AxisIndices.Axes.CartesianAxes","page":"AxisArrays","title":"AxisIndices.Axes.CartesianAxes","text":"CartesianAxes\n\nAlias for LinearIndices where indices are subtypes of AbstractAxis.\n\nExamples\n\njulia> using AxisIndices\n\njulia> cartaxes = CartesianAxes((Axis(2.0:5.0), Axis(1:4)));\n\njulia> cartinds = CartesianIndices((1:4, 1:4));\n\njulia> cartaxes[2, 2]\nCartesianIndex(2, 2)\n\njulia> cartinds[2, 2]\nCartesianIndex(2, 2)\n\n\n\n\n\n","category":"type"},{"location":"axis_arrays/#AxisIndices.Axes.LinearAxes","page":"AxisArrays","title":"AxisIndices.Axes.LinearAxes","text":"LinearAxes\n\nAlias for LinearIndices where indices are subtypes of AbstractAxis.\n\nExamples\n\njulia> using AxisIndices\n\njulia> linaxes = LinearAxes((Axis(2.0:5.0), Axis(1:4)));\n\njulia> lininds = LinearIndices((1:4, 1:4));\n\njulia> linaxes[2, 2]\n6\n\njulia> lininds[2, 2]\n6\n\n\n\n\n\n","category":"type"},{"location":"axis_arrays/#AxisIndices.Arrays.AbstractAxisArray","page":"AxisArrays","title":"AxisIndices.Arrays.AbstractAxisArray","text":"AbstractAxisArray\n\nAbstractAxisArray is a subtype of AbstractArray that offers integration with the AbstractAxis interface. The only methods that absolutely needs to be defined for a subtype of AbstractAxisArray are axes, parent, similar_type, and similar. Most users should find the provided AxisArray subtype is sufficient for the majority of use cases. Although custom behavior may be accomplished through a new subtype of AbstractAxisArray, customizing the behavior of many methods described herein can be accomplished through a unique subtype of AbstractAxis.\n\nThis implementation is meant to be basic, well documented, and have sane defaults that can be overridden as necessary. In other words, default methods for manipulating arrays that return an AxisArray should not cause unexpected downstream behavior for users; and developers should be able to freely customize the behavior of AbstractAxisArray subtypes with minimal effort. \n\n\n\n\n\n","category":"type"},{"location":"axis_arrays/#AxisIndices.Arrays.AxisArray","page":"AxisArrays","title":"AxisIndices.Arrays.AxisArray","text":"AxisArray{T,N,P,AI}\n\nAn array struct that wraps any parent array and assigns it an AbstractAxis for each dimension. The first argument is the parent array and the second argument is a tuple of subtypes to AbstractAxis or keys that will be converted to subtypes of AbstractAxis with the provided keys.\n\n\n\n\n\n","category":"type"},{"location":"coeftable/#Making-a-CoefTable","page":"CoefTable","title":"Making a CoefTable","text":"","category":"section"},{"location":"coeftable/","page":"CoefTable","title":"CoefTable","text":"This example will guide you through manipulating the pretty printing framework. We'll motivate this by trying to recreate the coefficient table from StatsBase.jl.","category":"page"},{"location":"coeftable/#Creating-the-Table","page":"CoefTable","title":"Creating the Table","text":"","category":"section"},{"location":"coeftable/","page":"CoefTable","title":"CoefTable","text":"julia> using AxisIndices, DataFrames, GLM, Distributions\n\njulia> function coefarray(mm::StatsModels.TableRegressionModel; level::Real=0.95)\n           cc = coef(mm)\n           se = stderror(mm)\n           tt = cc ./ se\n           p = ccdf.(Ref(FDist(1, dof_residual(mm))), abs2.(tt))\n           ci = se*quantile(TDist(dof_residual(mm)), (1-level)/2)\n           levstr = isinteger(level*100) ? string(Integer(level*100)) : string(level*100)\n           ct = AxisArray(\n               hcat(cc,se,tt,p,cc+ci,cc-ci),\n               (coefnames(mm),\n               [\"Estimate\",\"Std. Error\",\"t value\",\"Pr(>|t|)\",\"Lower $levstr%\",\"Upper $levstr%\"])\n           )\n       end\ncoefarray (generic function with 1 method)\n\njulia> ols = lm(@formula(Y ~ X), DataFrame(X=[1,2,3], Y=[2,4,7]));\n\njulia> cfa = coefarray(ols)\n2-dimensional AxisArray{Float64,2,Array{Float64,2}...}\n                   Estimate   Std. Error       t value     Pr(>|t|)     Lower 95%    Upper 95%\n  (Intercept)   -0.66666667   0.62360956   -1.06904497   0.47876359   -8.59037747   7.25704413\n            X           2.5   0.28867513    8.66025404    0.0731864   -1.16796536   6.16796536\n","category":"page"},{"location":"coeftable/","page":"CoefTable","title":"CoefTable","text":"But we can do better. Let's use the underlying pretty_array method to get this into shape.","category":"page"},{"location":"coeftable/","page":"CoefTable","title":"CoefTable","text":"julia> using PrettyTables\n\nctf = array_text_format = TextFormat(\n    up_right_corner = ' ',\n    up_left_corner = ' ',\n    bottom_left_corner=' ',\n    bottom_right_corner= ' ',\n    up_intersection= '─',\n    left_intersection= ' ',\n    right_intersection= ' ',\n    middle_intersection= '─',\n    bottom_intersection= '─',\n    column= ' ',\n    hlines=[ :begin, :header, :end]\n    #    row= ' ',\n)\n\njulia> pretty_array(cfa; tf=ctf)\n ──────────────────────────────────────────────────────────────────────────────────────────────\n                   Estimate   Std. Error       t value     Pr(>|t|)     Lower 95%    Upper 95%\n ──────────────────────────────────────────────────────────────────────────────────────────────\n  (Intercept)   -0.66666667   0.62360956   -1.06904497   0.47876359   -8.59037747   7.25704413\n            X           2.5   0.28867513    8.66025404    0.0731864   -1.16796536   6.16796536\n ──────────────────────────────────────────────────────────────────────────────────────────────","category":"page"},{"location":"coeftable/","page":"CoefTable","title":"CoefTable","text":"This looks pretty good but the nicest part is that we can now treat this as a typical matrix.","category":"page"},{"location":"coeftable/","page":"CoefTable","title":"CoefTable","text":"julia> cfa[1,\"Estimate\"]\n-0.6666666666666738\n\njulia> cfa[1:2,1:2]\n2-dimensional AxisArray{Float64,2,Array{Float64,2}...}\n                Estimate   Std. Error\n  (Intercept)     -0.667        0.624\n            X        2.5        0.289","category":"page"},{"location":"coeftable/","page":"CoefTable","title":"CoefTable","text":"Because keys and indices are bound together we don't lose track of what each element is when we index.","category":"page"},{"location":"coeftable/","page":"CoefTable","title":"CoefTable","text":"julia> cfa[1,:]\n1-dimensional AxisArray{Float64,1,Array{Float64,1}...}\n\n    Estimate   -0.667\n  Std. Error    0.624\n     t value   -1.069\n    Pr(>|t|)    0.479\n   Lower 95%    -8.59\n   Upper 95%    7.257\n","category":"page"},{"location":"coeftable/#Automating-the-table","page":"CoefTable","title":"Automating the table","text":"","category":"section"},{"location":"coeftable/","page":"CoefTable","title":"CoefTable","text":"We can actually do even better if this format should always be the default by making a new axis type and redefining the coefarray method. The following will result in any array with a CoefHeader printing exactly how we'd like it to by default. Note that this is a quick and dirty way of getting a new axis. See TimeAxis Guide for a better guide on making an axis.","category":"page"},{"location":"coeftable/","page":"CoefTable","title":"CoefTable","text":"julia> struct CoefHeader <: AbstractAxis{String,Int,Vector{String},Base.OneTo{Int}} end\n\njulia> Base.keys(::CoefHeader) = [\"Estimate\",\"Std. Error\",\"t value\",\"Pr(>|t|)\",\"Lower 95%\",\"Upper 95%\"]\n\njulia> Base.values(::CoefHeader) = Base.OneTo(5)\n\njulia> AxisIndices.text_format(axis, ::CoefHeader) = ctf\n\njulia> AxisIndices.unsafe_reconstruct(::CoefHeader, args...) = CoefHeader()\n\njulia> function coefarray(mm::StatsModels.TableRegressionModel; level::Real=0.95)\n           cc = coef(mm)\n           se = stderror(mm)\n           tt = cc ./ se\n           p = ccdf.(Ref(FDist(1, dof_residual(mm))), abs2.(tt))\n           ci = se*quantile(TDist(dof_residual(mm)), (1-level)/2)\n           levstr = isinteger(level*100) ? string(Integer(level*100)) : string(level*100)\n           ct = AxisArray(\n               hcat(cc,se,tt,p,cc+ci,cc-ci),\n               (coefnames(mm),\n               CoefHeader())\n           )\n       end;\n\njulia> cfa = coefarray(ols)\n2-dimensional AxisArray{Float64,2,Array{Float64,2}...}\n ──────────────────────────────────────────────────────────────────────────────────────────────\n                   Estimate   Std. Error       t value     Pr(>|t|)     Lower 95%    Upper 95%\n ──────────────────────────────────────────────────────────────────────────────────────────────\n  (Intercept)   -0.66666667   0.62360956   -1.06904497   0.47876359   -8.59037747   7.25704413\n            X           2.5   0.28867513    8.66025404    0.0731864   -1.16796536   6.16796536\n ──────────────────────────────────────────────────────────────────────────────────────────────\n","category":"page"},{"location":"offset_axes/#OffsetAxes","page":"OffsetAxes","title":"OffsetAxes","text":"","category":"section"},{"location":"offset_axes/#References","page":"OffsetAxes","title":"References","text":"","category":"section"},{"location":"offset_axes/","page":"OffsetAxes","title":"OffsetAxes","text":"Modules = [AxisIndices.OffsetAxes]","category":"page"},{"location":"offset_axes/#AxisIndices.OffsetAxes","page":"OffsetAxes","title":"AxisIndices.OffsetAxes","text":"OffsetAxes\n\nThe OffsetAxes module provides the CenteredAxis, [IdentityAxis], and OffsetAxis types, with the respective array types CenteredArray, IdentityArray, OffsetArray. All of these array types are aliases for the AxisArray type with the type of the axes specified for a certain type of offset. Alternatively, the center, idaxis, and offset can be used as shorthand for specifying that a specific axis of an AxisArray has ceretain type of offset indexing behavior.\n\n\n\n\n\n","category":"module"},{"location":"offset_axes/#AxisIndices.OffsetAxes.AbstractOffsetAxis","page":"OffsetAxes","title":"AxisIndices.OffsetAxes.AbstractOffsetAxis","text":"AbstractOffsetAxis{I,Ks,Inds}\n\nSupertype for axes that begin indexing offset from one. All subtypes of AbstractOffsetAxis use the keys for indexing and only convert to the underlying indices when to_index(::OffsetAxis, ::Integer) is called (i.e. when indexing the an array with an AbstractOffsetAxis. See OffsetAxis, CenteredAxis, and IdentityAxis for more details and examples.\n\n\n\n\n\n","category":"type"},{"location":"offset_axes/#AxisIndices.OffsetAxes.CenteredArray","page":"OffsetAxes","title":"AxisIndices.OffsetAxes.CenteredArray","text":"CenteredArray(A::AbstractArray)\n\nProvides centered axes for indexing A.\n\nExamples\n\njulia> using AxisIndices\n\njulia> CenteredArray(ones(3,3))\n3×3 AxisArray{Float64,2}\n • dim_1 - -1:1\n • dim_2 - -1:1\n        -1     0     1\n  -1   1.0   1.0   1.0\n   0   1.0   1.0   1.0\n   1   1.0   1.0   1.0\n\n\n\n\n\n\n","category":"type"},{"location":"offset_axes/#AxisIndices.OffsetAxes.CenteredAxis","page":"OffsetAxes","title":"AxisIndices.OffsetAxes.CenteredAxis","text":"CenteredAxis(indices)\n\nA CenteredAxis takes indices and provides a user facing set of keys centered around zero. The CenteredAxis is a subtype of AbstractOffsetAxis and its keys are treated as the predominant indexing style. Note that the element type of a CenteredAxis cannot be unsigned because any instance with a length greater than 1 will begin at a negative value.\n\nExamples\n\nA CenteredAxis sends all indexing arguments to the keys and only maps to the indices when to_index is called.\n\njulia> using AxisIndices\n\njulia> axis = CenteredAxis(1:10)\nCenteredAxis(-5:4 => 1:10)\n\njulia> axis[10]  # the indexing goes straight to keys and is centered around zero\nERROR: BoundsError: attempt to access 10-element CenteredAxis(-5:4 => 1:10) at index [10]\n[...]\n\njulia> axis[-5]\n-5\n\njulia> AxisIndices.to_index(axis, -5)\n1\n\n\n\n\n\n\n","category":"type"},{"location":"offset_axes/#AxisIndices.OffsetAxes.CenteredVector","page":"OffsetAxes","title":"AxisIndices.OffsetAxes.CenteredVector","text":"CenteredVector(v::AbstractVector)\n\nProvides a centered axis for indexing v.\n\nExamples\n\njulia> using AxisIndices\n\njulia> CenteredVector(ones(3))\n3-element AxisArray{Float64,1}\n • dim_1 - -1:1\n\n  -1   1.0\n   0   1.0\n   1   1.0\n\n\n\n\n\n\n","category":"type"},{"location":"offset_axes/#AxisIndices.OffsetAxes.CenteredVector-Union{Tuple{T}, Tuple{Union{Missing, Nothing, UndefInitializer},Any}} where T","page":"OffsetAxes","title":"AxisIndices.OffsetAxes.CenteredVector","text":"CenteredVector{T}(init::ArrayInitializer, sz::Integer)\n\nCreates a vector with elements of type T of size sz and a centered axis.\n\nExamples\n\njulia> using AxisIndices\n\njulia> CenteredVector{Union{Missing, Int}}(missing, 3)\n3-element AxisArray{Union{Missing, Int64},1}\n • dim_1 - -1:1\n\n  -1   missing\n   0   missing\n   1   missing\n\n\n\n\n\n","category":"method"},{"location":"offset_axes/#AxisIndices.OffsetAxes.IdentityArray","page":"OffsetAxes","title":"AxisIndices.OffsetAxes.IdentityArray","text":"IdentityArray(A::AbstractArray)\n\nProvides IdentityAxiss for indexing A.\n\nExamples\n\njulia> using AxisIndices\n\njulia> IdentityArray(ones(3,3))[2:3, 2:3]\n2×2 AxisArray{Float64,2}\n • dim_1 - 2:3\n • dim_2 - 2:3\n        2     3\n  2   1.0   1.0\n  3   1.0   1.0\n\n\n\n\n\n\n","category":"type"},{"location":"offset_axes/#AxisIndices.OffsetAxes.IdentityAxis","page":"OffsetAxes","title":"AxisIndices.OffsetAxes.IdentityAxis","text":"IdentityAxis(start, stop) -> axis\nIdentityAxis(keys::AbstractUnitRange) -> axis\nIdentityAxis(keys::AbstractUnitRange, indices::AbstractUnitRange) -> axis\n\nThese are particularly useful for creating views of arrays that preserve the supplied axes:\n\njulia> a = rand(8);\n\njulia> v1 = view(a, 3:5);\n\njulia> axes(v1, 1)\nBase.OneTo(3)\n\njulia> idr = IdentityAxis(3:5)\nIdentityAxis(3:5 => Base.OneTo(3))\n\njulia> v2 = view(a, idr);\n\njulia> axes(v2, 1)\n3:5\n\n\n\n\n\n","category":"type"},{"location":"offset_axes/#AxisIndices.OffsetAxes.IdentityVector","page":"OffsetAxes","title":"AxisIndices.OffsetAxes.IdentityVector","text":"IdentityVector(v::AbstractVector)\n\nProvides an IdentityAxis for indexing v.\n\nExamples\n\njulia> using AxisIndices\n\njulia> IdentityVector(ones(4))[3:4]\n2-element AxisArray{Float64,1}\n • dim_1 - 3:4\n\n  3   1.0\n  4   1.0\n\n\n\n\n\n\n","category":"type"},{"location":"offset_axes/#AxisIndices.OffsetAxes.IdentityVector-Union{Tuple{T}, Tuple{Union{Missing, Nothing, UndefInitializer},Any}} where T","page":"OffsetAxes","title":"AxisIndices.OffsetAxes.IdentityVector","text":"IdentityVector{T}(init::ArrayInitializer, sz::Integer)\n\nCreates a vector with elements of type T of size sz an IdentityAxis.\n\nExamples\n\njulia> using AxisIndices\n\njulia> IdentityVector{Union{Missing, Int}}(missing, 3)[2:3]\n2-element AxisArray{Union{Missing, Int64},1}\n • dim_1 - 2:3\n\n  2   missing\n  3   missing\n\n\n\n\n\n\n","category":"method"},{"location":"offset_axes/#AxisIndices.OffsetAxes.OffsetArray","page":"OffsetAxes","title":"AxisIndices.OffsetAxes.OffsetArray","text":"OffsetArray\n\nAn array whose axes are all OffsetAxis\n\n\n\n\n\n","category":"type"},{"location":"offset_axes/#AxisIndices.OffsetAxes.OffsetAxis","page":"OffsetAxes","title":"AxisIndices.OffsetAxes.OffsetAxis","text":"OffsetAxis(keys::AbstractUnitRange{<:Integer}, indices::AbstractUnitRange{<:Integer}[, check_length::Bool=true])\nOffsetAxis(offset::Integer, indices::AbstractUnitRange{<:Integer})\n\nAn axis that has the indexing behavior of an AbstractOffsetAxis and retains an offset from its underlying indices in its keys.\n\nExamples\n\nUsers may construct an OffsetAxis by providing an from a set of indices.\n\njulia> using AxisIndices\n\njulia> axis = OffsetAxis(-2, 1:3)\nOffsetAxis(-1:1 => 1:3)\n\nIn this instance the first index of the wrapped indices is 1 (firstindex(indices(axis))) but adding the offset (-2) moves it to -1.\n\njulia> firstindex(axis)\n-1\n\njulia> axis[-1]\n-1\n\nSimilarly, the last index is move by -2.\n\njulia> lastindex(axis)\n1\n\njulia> axis[1]\n1\n\n\nThis means that traditional one based indexing no longer applies and may result in errors.\n\njulia> axis[3]\nERROR: BoundsError: attempt to access 3-element OffsetAxis(-1:1 => 1:3) at index [3]\n[...]\n\nWhen an OffsetAxis is reconstructed the offset from indices are presserved.\n\njulia> axis[0:1]  # offset of -2 still applies\nOffsetAxis(0:1 => 2:3)\n\n\n\n\n\n\n","category":"type"},{"location":"offset_axes/#AxisIndices.OffsetAxes.OffsetVector","page":"OffsetAxes","title":"AxisIndices.OffsetAxes.OffsetVector","text":"OffsetVector\n\nA vector whose axis is OffsetAxis\n\n\n\n\n\n","category":"type"},{"location":"offset_axes/#AxisIndices.OffsetAxes.center-Tuple{Any}","page":"OffsetAxes","title":"AxisIndices.OffsetAxes.center","text":"center(inds::AbstractUnitRange{<:Integer}) -> CenteredAxis(inds)\n\nShortcut for creating CenteredAxis.\n\nExamples\n\njulia> using AxisIndices\n\njulia> AxisArray(ones(3), center)\n3-element AxisArray{Float64,1}\n • dim_1 - -1:1\n\n  -1   1.0\n   0   1.0\n   1   1.0\n\n\n\n\n\n\n","category":"method"},{"location":"offset_axes/#AxisIndices.OffsetAxes.idaxis-Tuple{Any}","page":"OffsetAxes","title":"AxisIndices.OffsetAxes.idaxis","text":"idaxis(inds::AbstractUnitRange{<:Integer}) -> IdentityAxis\n\nShortcut for creating IdentityAxis.\n\nExamples\n\njulia> using AxisIndices\n\njulia> AxisArray(ones(3), idaxis)[2:3]\n2-element AxisArray{Float64,1}\n • dim_1 - 2:3\n\n  2   1.0\n  3   1.0\n\n\n\n\n\n\n\n","category":"method"},{"location":"offset_axes/#AxisIndices.OffsetAxes.offset-Tuple{Any}","page":"OffsetAxes","title":"AxisIndices.OffsetAxes.offset","text":"offset(x)\n\nShortcut for creating OffsetAxis where x is the first argument to OffsetAxis.\n\nExamples\n\njulia> using AxisIndices\n\njulia> AxisArray(ones(3), offset(2))\n3-element AxisArray{Float64,1}\n • dim_1 - 3:5\n\n  3   1.0\n  4   1.0\n  5   1.0\n\n\n\n\n\n\n","category":"method"},{"location":"metadata/#Metadata","page":"Metadata","title":"Metadata","text":"","category":"section"},{"location":"metadata/","page":"Metadata","title":"Metadata","text":"Metadata.MetadataArray\nMetadata.MetaAxis\nMetadata.MetaAxisArray\nMetadata.MetaCartesianAxes\nMetadata.MetaLinearAxes\nMetadata.NamedMetaAxisArray\nMetadata.NamedMetaCartesianAxes\nMetadata.NamedMetaLinearAxes\nMetadata.has_metadata\nMetadata.has_metaproperty\nMetadata.axis_meta\nMetadata.axis_metaproperty\nMetadata.axis_metaproperty!\nMetadata.meta\nMetadata.metadata\nMetadata.metaproperty\nMetadata.metaproperty!\nMetadata.metadata_type","category":"page"},{"location":"metadata/#AxisIndices.Metadata.MetadataArray","page":"Metadata","title":"AxisIndices.Metadata.MetadataArray","text":"MetadataArray(parent::AbstractArray, metadata)\n\nCustom AbstractArray object to store an AbstractArray parent as well as some metadata.\n\nExamples\n\njulia> using AxisIndices\n\njulia> v = [\"John\", \"John\", \"Jane\", \"Louise\"];\n\njulia> s = MetadataArray(v, Dict(\"John\" => \"Treatment\", \"Louise\" => \"Placebo\", \"Jane\" => \"Placebo\"))\n4-element MetadataArray{String,1,Dict{String,String},Array{String,1}}:\n \"John\"\n \"John\"\n \"Jane\"\n \"Louise\"\n\njulia> metadata(s)\nDict{String,String} with 3 entries:\n  \"John\"   => \"Treatment\"\n  \"Jane\"   => \"Placebo\"\n  \"Louise\" => \"Placebo\"\n\n\n\n\n\n","category":"type"},{"location":"metadata/#AxisIndices.Metadata.MetaAxis","page":"Metadata","title":"AxisIndices.Metadata.MetaAxis","text":"MetaAxis\n\nAn axis type that allows storage of arbitraty metadata.\n\n\n\n\n\n","category":"type"},{"location":"metadata/#AxisIndices.Metadata.MetaAxisArray","page":"Metadata","title":"AxisIndices.Metadata.MetaAxisArray","text":"MetaAxisArray\n\nAn AxisArray with metadata.\n\nExamples\n\njulia> using AxisIndices\n\njulia> MetaAxisArray([1 2; 3 4], ([\"a\", \"b\"], [:one, :two]), metadata = \"some metadata\")\n2×2 MetaAxisArray{Int64,2}\n • dim_1 - [\"a\", \"b\"]\n • dim_2 - [:one, :two]\nmetadata: String\n • some metadata\n      one   two\n  a     1     2\n  b     3     4\n\n\n\n\n\n\n\n","category":"type"},{"location":"metadata/#AxisIndices.Metadata.MetaCartesianAxes","page":"Metadata","title":"AxisIndices.Metadata.MetaCartesianAxes","text":"MetaCartesianAxes\n\nConveniently construct a CartesianAxes that has metadata.\n\nExamples\n\njulia> using AxisIndices\n\njulia> MetaCartesianAxes(([:a, :b], [\"one\", \"two\"]); metadata=\"some metadata\")\n2×2 MetaCartesianAxes{CartesianIndex{2},2}\n • dim_1 - [:a, :b]\n • dim_2 - [\"one\", \"two\"]\nmetadata: String\n • some metadata\n                       one                    two\n  a   CartesianIndex(1, 1)   CartesianIndex(1, 2)\n  b   CartesianIndex(2, 1)   CartesianIndex(2, 2)\n\n\n\n\n\n\n","category":"type"},{"location":"metadata/#AxisIndices.Metadata.MetaLinearAxes","page":"Metadata","title":"AxisIndices.Metadata.MetaLinearAxes","text":"MetaLinearAxes\n\nConveniently construct a LinearAxes that has metadata.\n\nExamples\n\njulia> using AxisIndices\n\njulia> MetaLinearAxes(([:a, :b], [\"one\", \"two\"]); metadata=\"some metadata\")\n2×2 MetaLinearAxes{Int64,2}\n • dim_1 - [:a, :b]\n • dim_2 - [\"one\", \"two\"]\nmetadata: String\n • some metadata\n      one   two\n  a     1     3\n  b     2     4\n\n\n\n\n\n\n","category":"type"},{"location":"metadata/#AxisIndices.Metadata.NamedMetaAxisArray","page":"Metadata","title":"AxisIndices.Metadata.NamedMetaAxisArray","text":"NamedMetaAxisArray\n\nAn AxisArray with metadata and named dimensions.\n\n\n\n\n\n","category":"type"},{"location":"metadata/#AxisIndices.Metadata.NamedMetaCartesianAxes","page":"Metadata","title":"AxisIndices.Metadata.NamedMetaCartesianAxes","text":"NamedMetaCartesianAxes\n\nConveniently construct a CartesianAxes that has metadata and each dimension has a name.\n\nExamples\n\njulia> using AxisIndices\n\njulia> x = NamedMetaCartesianAxes{(:dimx,:dimy)}(([:a, :b], [\"one\", \"two\"]); metadata=\"some metadata\")\n2×2 NamedMetaCartesianAxes{CartesianIndex{2},2}\n • dimx - [:a, :b]\n • dimy - [\"one\", \"two\"]\nmetadata: String\n • some metadata\n                       one                    two\n  a   CartesianIndex(1, 1)   CartesianIndex(1, 2)\n  b   CartesianIndex(2, 1)   CartesianIndex(2, 2)\n\njulia> x == NamedMetaCartesianAxes((dimx = [:a, :b], dimy = [\"one\", \"two\"]); metadata=\"some metadata\")\ntrue\n\n\n\n\n\n\n","category":"type"},{"location":"metadata/#AxisIndices.Metadata.NamedMetaLinearAxes","page":"Metadata","title":"AxisIndices.Metadata.NamedMetaLinearAxes","text":"NamedMetaLinearAxes\n\nConveniently construct a LinearAxes that has metadata and each dimension has a name.\n\nExamples\n\njulia> using AxisIndices\n\njulia> x = NamedMetaLinearAxes{(:dimx,:dimy)}(([:a, :b], [\"one\", \"two\"]); metadata=\"some metadata\")\n2×2 NamedMetaLinearAxes{Int64,2}\n • dimx - [:a, :b]\n • dimy - [\"one\", \"two\"]\nmetadata: String\n • some metadata\n      one   two\n  a     1     3\n  b     2     4\n\njulia> x == NamedMetaLinearAxes((dimx = [:a, :b], dimy = [\"one\", \"two\"]); metadata=\"some metadata\")\ntrue\n\n\n\n\n\n\n","category":"type"},{"location":"metadata/#AxisIndices.Metadata.has_metadata","page":"Metadata","title":"AxisIndices.Metadata.has_metadata","text":"has_metadata(x) -> Bool\n\nReturns true if x contains additional fields besides those for keys or indices\n\n\n\n\n\n","category":"function"},{"location":"metadata/#AxisIndices.Metadata.has_metaproperty","page":"Metadata","title":"AxisIndices.Metadata.has_metaproperty","text":"has_metaproperty(x, meta_key) -> Bool\n\nReturns true if x has a property in its metadata structure paired to meta_key.\n\n\n\n\n\n","category":"function"},{"location":"metadata/#AxisIndices.Metadata.axis_meta","page":"Metadata","title":"AxisIndices.Metadata.axis_meta","text":"axis_meta(x)\n\nReturns metadata (i.e. not keys or indices) associated with each axis of the array x.\n\n\n\n\n\naxis_meta(x, i)\n\nReturns metadata (i.e. not keys or indices) associated with the ith axis of the array x.\n\n\n\n\n\n","category":"function"},{"location":"metadata/#AxisIndices.Metadata.axis_metaproperty","page":"Metadata","title":"AxisIndices.Metadata.axis_metaproperty","text":"axis_metaproperty(x, i, meta_key)\n\nReturn the metadata of x paired to meta_key at axis i.\n\n\n\n\n\n","category":"function"},{"location":"metadata/#AxisIndices.Metadata.axis_metaproperty!","page":"Metadata","title":"AxisIndices.Metadata.axis_metaproperty!","text":"axis_metaproperty!(x, meta_key, val)\n\nSet the metadata of x paired to meta_key at axis i.\n\n\n\n\n\n","category":"function"},{"location":"metadata/#AxisIndices.Metadata.meta","page":"Metadata","title":"AxisIndices.Metadata.meta","text":"meta(x)\n\nShortcut for creating MetaAxis.\n\nExamples\n\njulia> using AxisIndices\n\njulia> A = AxisArray(ones(3), meta(\"a life well, Steved\"));\n\njulia> axis_meta(A)\n(\"a life well, Steved\",)\n\n\n\n\n\n\n","category":"function"},{"location":"metadata/#AxisIndices.Metadata.metadata","page":"Metadata","title":"AxisIndices.Metadata.metadata","text":"metadata(x)\n\nReturns metadata for x.\n\n\n\n\n\n","category":"function"},{"location":"metadata/#AxisIndices.Metadata.metaproperty","page":"Metadata","title":"AxisIndices.Metadata.metaproperty","text":"metaproperty(x, meta_key)\n\nReturn the metadata of x paired to meta_key.\n\n\n\n\n\n","category":"function"},{"location":"metadata/#AxisIndices.Metadata.metaproperty!","page":"Metadata","title":"AxisIndices.Metadata.metaproperty!","text":"metadata!(x, meta_key, val)\n\nSet the metadata of x paired to meta_key.\n\n\n\n\n\n","category":"function"},{"location":"metadata/#AxisIndices.Metadata.metadata_type","page":"Metadata","title":"AxisIndices.Metadata.metadata_type","text":"metadata_type(x)\n\nReturns the type of the metadata of x.\n\n\n\n\n\n","category":"function"},{"location":"arrays/#Array-Interface","page":"Array Interface","title":"Array Interface","text":"","category":"section"},{"location":"arrays/#Construction","page":"Array Interface","title":"Construction","text":"","category":"section"},{"location":"arrays/","page":"Array Interface","title":"Array Interface","text":"Take a standard array and attach custom keys along the indices of each dimension.","category":"page"},{"location":"arrays/","page":"Array Interface","title":"Array Interface","text":"julia> using AxisIndices\n\njulia> A_base = [1 2; 3 4];\n\njulia> A_axis = AxisArray(A_base, [\"a\", \"b\"], [:one, :two])\n2×2 AxisArray{Int64,2}\n • dim_1 - [\"a\", \"b\"]\n • dim_2 - [:one, :two]\n      one   two  \n  a     1     2  \n  b     3     4  \n","category":"page"},{"location":"arrays/","page":"Array Interface","title":"Array Interface","text":"Note that the keys provided are converted to a subtype of AbstractAxis.","category":"page"},{"location":"arrays/","page":"Array Interface","title":"Array Interface","text":"julia> axes(A_axis, 1)\nAxis([\"a\", \"b\"] => Base.OneTo(2))\n","category":"page"},{"location":"arrays/","page":"Array Interface","title":"Array Interface","text":"An AxisArray may also be initialized using similar syntax as Array{T}(undef, dims).","category":"page"},{"location":"arrays/","page":"Array Interface","title":"Array Interface","text":"julia> A_axis = AxisArray{Int}(undef, [\"a\", \"b\"], [:one, :two]);\n\njulia> A_axis[:,:] = A_base;\n\njulia> A_axis\n2×2 AxisArray{Int64,2}\n • dim_1 - [\"a\", \"b\"]\n • dim_2 - [:one, :two]\n      one   two  \n  a     1     2  \n  b     3     4  \n","category":"page"},{"location":"arrays/","page":"Array Interface","title":"Array Interface","text":"Names can be attached to each dimension/axis using NamedAxisArray.","category":"page"},{"location":"arrays/","page":"Array Interface","title":"Array Interface","text":"julia> A_named_axis = NamedAxisArray{(:xdim, :ydim)}(A_axis)\n2×2 NamedAxisArray{Int64,2}\n • xdim - [\"a\", \"b\"]\n • ydim - [:one, :two]\n      one   two  \n  a     1     2  \n  b     3     4  \n\njulia> A_named_axis == NamedAxisArray{(:xdim, :ydim)}(A_base, [\"a\", \"b\"], [:one, :two])\ntrue\n","category":"page"},{"location":"arrays/","page":"Array Interface","title":"Array Interface","text":"We can also attach metadata to an an array.","category":"page"},{"location":"arrays/","page":"Array Interface","title":"Array Interface","text":"julia> A_meta_axis = MetaAxisArray(A_base, ([\"a\", \"b\"], [:one, :two]), metadata = \"a life well Steved\")\n2×2 MetaAxisArray{Int64,2}\n • dim_1 - [\"a\", \"b\"]\n • dim_2 - [:one, :two]\nmetadata: String\n • a life well Steved\n      one   two\n  a     1     2\n  b     3     4\n\n\njulia> A_meta_axis == MetaAxisArray(A_axis, metadata = \"a life well Steved\")\ntrue\n\njulia> NamedMetaAxisArray{(:xdim, :ydim)}(A_base, [\"a\", \"b\"], [:one, :two], metadata = \"a life well Steved\")\n2×2 NamedMetaAxisArray{Int64,2}\n • xdim - [\"a\", \"b\"]\n • ydim - [:one, :two]\nmetadata: String\n • a life well Steved\n      one   two\n  a     1     2\n  b     3     4\n","category":"page"},{"location":"arrays/#Indexing","page":"Array Interface","title":"Indexing","text":"","category":"section"},{"location":"arrays/","page":"Array Interface","title":"Array Interface","text":"Behavior of an AxisArray is similar to that of the common Array type.","category":"page"},{"location":"arrays/","page":"Array Interface","title":"Array Interface","text":"julia> using AxisIndices\n\njulia> import Unitful: s\n\njulia> A_base = reshape(1:9, 3,3);\n\njulia> A_axis = AxisArray(A_base, ((.1:.1:.3)s, [\"a\", \"b\", \"c\"]))\n3×3 AxisArray{Int64,2}\n • dim_1 - 0.1 s:0.1 s:0.3 s\n • dim_2 - [\"a\", \"b\", \"c\"]\n          a   b   c\n  0.1 s   1   4   7\n  0.2 s   2   5   8\n  0.3 s   3   6   9\n\njulia> A_axis[1,1] == A_base[1,1]\ntrue\n\njulia> A_axis[1] == A_base[1] # linear indexing works too\ntrue\n\njulia> A_axis[1,:]\n3-element AxisArray{Int64,1}\n • dim_1 - [\"a\", \"b\", \"c\"]\n\n  a   1\n  b   4\n  c   7\n\n\njulia> A_axis[1:2, 1:2]\n2×2 AxisArray{Int64,2}\n • dim_1 - 0.1 s:0.1 s:0.2 s\n • dim_2 - [\"a\", \"b\"]\n          a   b\n  0.1 s   1   4\n  0.2 s   2   5\n\n\njulia> A_axis[1:3]\n3-element AxisArray{Int64,1}\n • dim_1 - 0.1 s:0.1 s:0.3 s\n\n  0.1 s   1\n  0.2 s   2\n  0.3 s   3\n","category":"page"},{"location":"arrays/","page":"Array Interface","title":"Array Interface","text":"In addition to standard indexing, an AxisArray can be indexed by its keys...","category":"page"},{"location":"arrays/","page":"Array Interface","title":"Array Interface","text":"julia> A_axis[.1s, \"a\"]\n1\n\njulia> A_axis[0.1s..0.3s, [\"a\", \"b\"]]\n3×2 AxisArray{Int64,2}\n • dim_1 - 0.1 s:0.1 s:0.3 s\n • dim_2 - [\"a\", \"b\"]\n          a   b\n  0.1 s   1   4\n  0.2 s   2   5\n  0.3 s   3   6\n","category":"page"},{"location":"arrays/","page":"Array Interface","title":"Array Interface","text":"...or functions that filter the keys.","category":"page"},{"location":"arrays/","page":"Array Interface","title":"Array Interface","text":"julia> A_axis[!=(.2s), in([\"a\", \"c\"])]\n2×2 AxisArray{Int64,2}\n • dim_1 - Unitful.Quantity{Float64,𝐓,Unitful.FreeUnits{(s,),𝐓,nothing}}[0.1 s, 0.3 s]\n • dim_2 - [\"a\", \"c\"]\n          a   c\n  0.1 s   1   7\n  0.3 s   3   9\n","category":"page"},{"location":"arrays/","page":"Array Interface","title":"Array Interface","text":"Indexing notation from the EllipsisNotation.jl packages is also supported.","category":"page"},{"location":"arrays/","page":"Array Interface","title":"Array Interface","text":"julia> A = AxisArray{Int}(undef, 2, 4, 2);\n\njulia> A[.., 1] = [2 1 4 5\n                   2 2 3 6];\n\njulia> A[.., 2] = [3 2 6 5 3 2 6 6];\n\njulia> A[:, :, 1] == [2 1 4 5\n                      2 2 3 6]\ntrue\n\njulia> A = AxisArray(ones(3,3,3,3,3));\n\njulia> size(A[1:1, .., 1:1])\n(1, 3, 3, 3, 1)\n","category":"page"},{"location":"arrays/#Combining-Different-Axes","page":"Array Interface","title":"Combining Different Axes","text":"","category":"section"},{"location":"arrays/","page":"Array Interface","title":"Array Interface","text":"One of benefits of AxisIndices using a unified backend for multiple axis types is that they can be arbitrarily mixed together. For example, here's an example the first indices are offset by 4 and the last indices are centered.","category":"page"},{"location":"arrays/","page":"Array Interface","title":"Array Interface","text":"julia> AxisArray(ones(3,3), offset(4), center)\n3×3 AxisArray{Float64,2}\n • dim_1 - 5:7\n • dim_2 - -1:1\n       -1     0     1  \n  5   1.0   1.0   1.0  \n  6   1.0   1.0   1.0  \n  7   1.0   1.0   1.0  \n","category":"page"},{"location":"arrays/","page":"Array Interface","title":"Array Interface","text":"Although this example isn't particularly useful, being able to arbitrarily mix axes with static characteristics, metadata, offset indices, semantic keys, etc. lends itself to easy custom designs and algorithms.","category":"page"},{"location":"time/#TimeAxis-Guide","page":"TimeAxis Guide","title":"TimeAxis Guide","text":"","category":"section"},{"location":"time/","page":"TimeAxis Guide","title":"TimeAxis Guide","text":"Here we define an axis that specifically supports time. Users aren't typically expected to create a unique axis type, and a more featureful implementation is available through the TimeAxes.jl package. However, this section may still be a useful starting point for those wishing to create a novel axis type, because the process should generally be the same:","category":"page"},{"location":"time/","page":"TimeAxis Guide","title":"TimeAxis Guide","text":"Compose the type and necessary methods for accessing it's properties and constructing it.\nDefine a new trait that changes indexing.","category":"page"},{"location":"time/#.-The-TimeAxis-Type","page":"TimeAxis Guide","title":"1. The TimeAxis Type","text":"","category":"section"},{"location":"time/","page":"TimeAxis Guide","title":"TimeAxis Guide","text":"This first section defines the minimum keys, values, similar_type and constructors for the TimeAxis type.","category":"page"},{"location":"time/","page":"TimeAxis Guide","title":"TimeAxis Guide","text":"julia> using AxisIndices, Dates, Unitful, ChainedFixes\n\njulia> struct TimeAxis{K,V,Ks,Vs} <: AbstractAxis{K,V,Ks,Vs}\n           axis::Axis{K,V,Ks,Vs}\n           times::Dict{Symbol,Any}\n           function TimeAxis{K,V,Ks,Vs}(axis::Axis{K,V,Ks,Vs}, times::Dict{Symbol,Pair{K,K}}) where {K,V,Ks,Vs}\n               return new{K,V,Ks,Vs}(axis, times)\n           end\n           function TimeAxis{K,V,Ks,Vs}(args...; kwargs...) where {K,V,Ks,Vs}\n               d = Dict{Symbol,Pair{K,K}}()\n               for (k,v) in kwargs\n                   d[k] = v\n               end\n               return new{K,V,Ks,Vs}(Axis{K,V,Ks,Vs}(args...), d)\n           end\n           function TimeAxis(args...; kwargs...)\n               ax = Axis(args...)\n               d = Dict{Symbol,Pair{keytype(ax),keytype(ax)}}()\n               for (k,v) in kwargs\n                   d[k] = v\n               end\n               return new{keytype(ax),valtype(ax),keys_type(ax),indices_type(ax)}(ax, d)\n           end\n       end\n\njulia> Base.keys(t::TimeAxis) = keys(getfield(t, :axis))\n\njulia> Base.values(t::TimeAxis) = values(getfield(t, :axis))\n\njulia> function AxisIndices.similar_type(\n           t::TimeAxis{K,V,Ks,Vs},\n           new_keys_type::Type=Ks,\n           new_indices_type::Type=Vs\n       ) where {K,V,Ks,Vs}\n           return TimeAxis{eltype(new_keys_type),eltype(new_indices_type),new_keys_type,new_indices_type}\n       end","category":"page"},{"location":"time/#.-The-TimeStampCollection-Trait","page":"TimeAxis Guide","title":"2. The TimeStampCollection Trait","text":"","category":"section"},{"location":"time/","page":"TimeAxis Guide","title":"TimeAxis Guide","text":"Not only do we want to store discrete intervals of time with labels in the axis, but we want to reference them in a very simple way for indexing. In other words, if we have previously assigned :time1 the interval of 1 to 3 seconds, then we should be able to do axis[:time1] to index the axis instead of doing axis[axis.times[:time1]]. However, the default indexing behavior is to look for a Symbol in the keys of an axis. We want to tell the indexing pipeline that when we provide a Symbol with a TimeAxis we want to lookup the argument in axis.times and then pass the result to the typical indexing protocol. So we make a new trait that for this.","category":"page"},{"location":"time/","page":"TimeAxis Guide","title":"TimeAxis Guide","text":"julia> Base.setindex!(t::TimeAxis, val, i::Symbol) = t.times[i] = val\n\njulia> struct TimeStampCollection <: AxisIndices.AxisIndicesStyle end\n\njulia> AxisIndices.is_element(::Type{TimeStampCollection}) = false\n\njulia> function AxisIndices.AxisIndicesStyle(::Type{<:TimeAxis}, ::Type{Symbol})\n           return TimeStampCollection()\n       end\n\njulia> function AxisIndices.to_index(::TimeStampCollection, axis, arg)\n           return AxisIndices.to_index(t.axis, t.times[arg])\n       end\n\njulia> function AxisIndices.to_keys(::TimeStampCollection, axis, arg, index)\n           return AxisIndices.to_keys(t.axis, t.times[arg], index)\n       end","category":"page"},{"location":"time/#TimeAxis-in-Action","page":"TimeAxis Guide","title":"TimeAxis in Action","text":"","category":"section"},{"location":"time/","page":"TimeAxis Guide","title":"TimeAxis Guide","text":"Now we can access the time points of this access by the Symbols that correspond to intervals of time.","category":"page"},{"location":"time/","page":"TimeAxis Guide","title":"TimeAxis Guide","text":"julia> t = TimeAxis(Second(1):Second(1):Second(10));\n\njulia> t[:time_1] = Second(1):Second(1):Second(3);\n\njulia> t[:time_1] == 1:3\ntrue\n","category":"page"},{"location":"time/","page":"TimeAxis Guide","title":"TimeAxis Guide","text":"This can also be done with Unitful elements.","category":"page"},{"location":"time/","page":"TimeAxis Guide","title":"TimeAxis Guide","text":"julia> using Unitful: s\n\njulia> t2 = TimeAxis((1:10)s);\n\njulia> t2[:time_1] = 1s..3s;\n\njulia> t[:time_1] == 1:3\ntrue\n","category":"page"},{"location":"time/","page":"TimeAxis Guide","title":"TimeAxis Guide","text":"This can naturally turn any array that is an AbstractAxisIndices subtype into a collection of time series data.","category":"page"},{"location":"time/","page":"TimeAxis Guide","title":"TimeAxis Guide","text":"julia> x = AxisArray(collect(1:2:20), t);\n\njulia> x[:time_1]\n3-element AxisArray{Int64,1}\n • dim_1 - 1 second:1 second:3 seconds\n\n   1 second   1\n  2 seconds   3\n  3 seconds   5\n\n","category":"page"},{"location":"table/#Tabular-Interface","page":"Tabular Interface","title":"Tabular Interface","text":"","category":"section"},{"location":"table/","page":"Tabular Interface","title":"Tabular Interface","text":"warning: Warning\nCurrently the Table interface isn't complete. Details of REPL printing and construction may change.","category":"page"},{"location":"table/","page":"Tabular Interface","title":"Tabular Interface","text":"AxisIndices.jl integrates with the Tables.jl interface via AxisTable.","category":"page"},{"location":"table/#Construction","page":"Tabular Interface","title":"Construction","text":"","category":"section"},{"location":"table/#Key-Word-Construction","page":"Tabular Interface","title":"Key Word Construction","text":"","category":"section"},{"location":"table/","page":"Tabular Interface","title":"Tabular Interface","text":"julia> using AxisIndices\n\njulia> t = Table(A = 1:4, B = [\"M\", \"F\", \"F\", \"M\"])\nTable\n┌───┬───┐\n│ A │ B │\n├───┼───┤\n│ 1 │ M │\n│ 2 │ F │\n│ 3 │ F │\n│ 4 │ M │\n└───┴───┘\n","category":"page"},{"location":"table/#Property-Name-Assignment","page":"Tabular Interface","title":"Property Name Assignment","text":"","category":"section"},{"location":"table/","page":"Tabular Interface","title":"Tabular Interface","text":"julia> t = Table();\n\njulia> t.A = 1:8;\n\njulia> t.B = [\"M\", \"F\", \"F\", \"M\", \"F\", \"M\", \"M\", \"F\"];\n\njulia> t\nTable\n┌───┬───┐\n│ A │ B │\n├───┼───┤\n│ 1 │ M │\n│ 2 │ F │\n│ 3 │ F │\n│ 4 │ M │\n│ 5 │ F │\n│ 6 │ M │\n│ 7 │ M │\n│ 8 │ F │\n└───┴───┘\n","category":"page"},{"location":"table/#Adding-Rows","page":"Tabular Interface","title":"Adding Rows","text":"","category":"section"},{"location":"table/","page":"Tabular Interface","title":"Tabular Interface","text":"TODO","category":"page"},{"location":"table/#Reference","page":"Tabular Interface","title":"Reference","text":"","category":"section"},{"location":"table/","page":"Tabular Interface","title":"Tabular Interface","text":"Pages   = [\"table.md\"]\nModules = [AxisIndices.Tabular]\nOrder   = [:function, :type]","category":"page"},{"location":"table/","page":"Tabular Interface","title":"Tabular Interface","text":"Modules = [AxisIndices.Tabular]","category":"page"},{"location":"table/#AxisIndices.Tabular.AbstractTable","page":"Tabular Interface","title":"AxisIndices.Tabular.AbstractTable","text":"AbstractTable\n\nSupertype for which tables that utilize an AbstractAxis interface for tabular data.\n\n\n\n\n\n","category":"type"},{"location":"table/#AxisIndices.Tabular.Table","page":"Tabular Interface","title":"AxisIndices.Tabular.Table","text":"Table\n\nStores a vector of columns that may be acccessed via the Tables.jl interface.\n\n\n\n\n\n","category":"type"},{"location":"table/#AxisIndices.Tabular.TableRow","page":"Tabular Interface","title":"AxisIndices.Tabular.TableRow","text":"TableRow\n\nA view of one row of an AbstractTable.\n\n\n\n\n\n","category":"type"},{"location":"named_axes/#Named-Axes","page":"Named Axes","title":"Named Axes","text":"","category":"section"},{"location":"named_axes/","page":"Named Axes","title":"Named Axes","text":"AxisIndices.NamedAxes.NamedAxisArray\nAxisIndices.NamedAxes.NamedCartesianAxes\nAxisIndices.NamedAxes.NamedLinearAxes\nAxisIndices.NamedAxes.has_dimnames\nAxisIndices.NamedAxes.named_axes","category":"page"},{"location":"named_axes/#AxisIndices.NamedAxes.NamedAxisArray","page":"Named Axes","title":"AxisIndices.NamedAxes.NamedAxisArray","text":"NamedAxisArray(parent::AbstractArray; kwargs...) = NamedAxisArray(parent, kwargs)\nNamedAxisArray(parent::AbstractArray, axes::NamedTuple{L,AbstractAxes})\n\nType alias for NamedDimsArray whose parent array is a subtype of AxisArray. An abbreviated alias and constructor for NamedAxisArray. If key word arguments are provided then each key word becomes the name of a dimension and its assigned value is sent to the corresponding axis when constructing the underlying AxisArray.\n\nExamples\n\njulia> using AxisIndices\n\njulia> A = NamedAxisArray{(:x, :y, :z)}(reshape(1:24, 2, 3, 4), [\"a\", \"b\"], [\"one\", \"two\", \"three\"], 2:5)\n2×3×4 NamedAxisArray{Int64,3}\n • x - [\"a\", \"b\"]\n • y - [\"one\", \"two\", \"three\"]\n • z - 2:5\n[x, y, z[2]] =\n      one   two   three\n  a     1     3       5\n  b     2     4       6\n\n[x, y, z[3]] =\n      one   two   three\n  a     7     9      11\n  b     8    10      12\n\n[x, y, z[4]] =\n      one   two   three\n  a    13    15      17\n  b    14    16      18\n\n[x, y, z[5]] =\n      one   two   three\n  a    19    21      23\n  b    20    22      24\n\njulia> dimnames(A)\n(:x, :y, :z)\n\njulia> axes_keys(A)\n([\"a\", \"b\"], [\"one\", \"two\", \"three\"], 2:5)\n\njulia> B = A[\"a\", :, :]\n3×4 NamedAxisArray{Int64,2}\n • y - [\"one\", \"two\", \"three\"]\n • z - 2:5\n          2    3    4    5\n    one   1    7   13   19\n    two   3    9   15   21\n  three   5   11   17   23\n\njulia> C = B[\"one\",:]\n4-element NamedAxisArray{Int64,1}\n • z - 2:5\n\n  2    1\n  3    7\n  4   13\n  5   19\n\n\n\n\n\n\n","category":"type"},{"location":"named_axes/#AxisIndices.NamedAxes.NamedCartesianAxes","page":"Named Axes","title":"AxisIndices.NamedAxes.NamedCartesianAxes","text":"NamedCartesianAxes\n\nConveniently construct a CartesianAxes where each dimension has a name.\n\nExamples\n\njulia> using AxisIndices\n\njulia> x = NamedCartesianAxes{(:dimx, :dimy)}(([:a, :b], [\"one\", \"two\"]))\n2×2 NamedCartesianAxes{CartesianIndex{2},2}\n • dimx - [:a, :b]\n • dimy - [\"one\", \"two\"]\n                       one                    two\n  a   CartesianIndex(1, 1)   CartesianIndex(1, 2)\n  b   CartesianIndex(2, 1)   CartesianIndex(2, 2)\n\njulia> x == NamedCartesianAxes((dimx = [:a, :b], dimy = [\"one\", \"two\"]))\ntrue\n\n\n\n\n\n\n","category":"type"},{"location":"named_axes/#AxisIndices.NamedAxes.NamedLinearAxes","page":"Named Axes","title":"AxisIndices.NamedAxes.NamedLinearAxes","text":"NamedLinearAxes\n\nProvides LinearAxes where each dimension has a name.\n\nExamples\n\njulia> using AxisIndices\n\njulia> x = NamedLinearAxes{(:dimx,:dimy)}(([:a, :b], [\"one\", \"two\"]))\n2×2 NamedLinearAxes{Int64,2}\n • dimx - [:a, :b]\n • dimy - [\"one\", \"two\"]\n      one   two\n  a     1     3\n  b     2     4\n\njulia> x == NamedLinearAxes((dimx = [:a, :b], dimy = [\"one\", \"two\"]))\ntrue\n\n\n\n\n\n\n","category":"type"},{"location":"named_axes/#AxisIndices.NamedAxes.has_dimnames","page":"Named Axes","title":"AxisIndices.NamedAxes.has_dimnames","text":"has_dimnames(x) -> Bool\n\nReturns true if x has names for each dimension.\n\n\n\n\n\n","category":"function"},{"location":"named_axes/#AxisIndices.NamedAxes.named_axes","page":"Named Axes","title":"AxisIndices.NamedAxes.named_axes","text":"named_axes(A) -> NamedTuple{names}(axes)\n\nReturns a NamedTuple where the names are the dimension names and each indice is the corresponding dimensions's axis. If dimnesion names are not defined for x default names are returned. x should have an axes method.\n\njulia> using AxisIndices\n\njulia> A = reshape(1:24, 2,3,4);\n\njulia> named_axes(A)\n(dim_1 = Base.OneTo(2), dim_2 = Base.OneTo(3), dim_3 = Base.OneTo(4))\n\njulia> named_axes(NamedAxisArray{(:a, :b, :c)}(A))\n(a = SimpleAxis(Base.OneTo(2)), b = SimpleAxis(Base.OneTo(3)), c = SimpleAxis(Base.OneTo(4)))\n\n\n\n\n\n","category":"function"},{"location":"#AxisIndices","page":"Introduction","title":"AxisIndices","text":"","category":"section"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The goals of this package are:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Facilitate multidimensional indexing (e.g., instance_of_an_array[indices]) that supports semantic user facing indices (e.g., indices = Second(1)).\nAccomplishing the first goal should not interfere in the ability to perform the vast majority of array related methods (e.g, vcat, append!, etc.).\nIt should be easy to implement new subtypes of AbstractAxis that accommodate novel behavior and needs.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"These goals are accomplished predominantly through the AbstractAxis type. It is a subtype of AbstractUnitRange{<:Integer} with an additional interface for creating keys and interacting with them. This additional interface is intended to be easily extended to new types that may be needed for a variety of different situations. An additional AxisArray type is provided that uses any subtype of AbstractAxis for each axis. However, many methods are provided and documented internally so that it's easy for users to alter the behavior of an AxisArray with a new AbstractAxis subtype or create an entirely unique multidimensional structure.","category":"page"},{"location":"#Where-to-go-from-here","page":"Introduction","title":"Where to go from here","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"I just want to get something done.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Then start with the Quick Start section.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"I want to make my own axis type.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Look at the TimeAxis Guide, which implements a custom axis type.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"I want to understand why/how something works","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"If you've read the appropriate docstrings (under \"References\" or available in the REPL) and still have questions then various sections under \"Manual\" are a good place to look. If that doesn't help then create an issue in the AxisIndices repo.","category":"page"},{"location":"internals_of_indexing/#Internals-of-Indexing","page":"Internals of Indexing","title":"Internals of Indexing","text":"","category":"section"},{"location":"internals_of_indexing/","page":"Internals of Indexing","title":"Internals of Indexing","text":"This section is for those who want to understand how indexing is implemented in AxisIndices and some of the logic behind it. It goes over:","category":"page"},{"location":"internals_of_indexing/","page":"Internals of Indexing","title":"Internals of Indexing","text":"The three steps of indexing.\nMapping to indices\nRetrieving elements\nReconstructing axes\nIntroduction to AxisIndicesStyle traits","category":"page"},{"location":"internals_of_indexing/","page":"Internals of Indexing","title":"Internals of Indexing","text":"Although the basic concepts used here are very unlikely to change, small details (such as internally used naming and types) may change. Therefore, the exact implementation of these concepts are actively being developed and improved.","category":"page"},{"location":"internals_of_indexing/#Mapping-to-Indices","page":"Internals of Indexing","title":"Mapping to Indices","text":"","category":"section"},{"location":"internals_of_indexing/","page":"Internals of Indexing","title":"Internals of Indexing","text":"AxisIndices attempts to redirect the uses its own internal implementation of to_indices. Where the the method from base looks somewhate like the following...","category":"page"},{"location":"internals_of_indexing/","page":"Internals of Indexing","title":"Internals of Indexing","text":"function Base.to_indices(A, axes::Tuple, args::Tuple)\n    return (Base.to_index(A, first(args)), Base.to_indices(A, tail(axes), tail(args))...)\nend","category":"page"},{"location":"internals_of_indexing/","page":"Internals of Indexing","title":"Internals of Indexing","text":"AxisIndices looks more like...","category":"page"},{"location":"internals_of_indexing/","page":"Internals of Indexing","title":"Internals of Indexing","text":"function AxisIndices.to_indices(A, axes::Tuple, args::Tuple)\n    return (AxisIndices.to_index(first(axes), first(args)), AxisIndices.to_indices(A, tail(axes), tail(args))...)\nend","category":"page"},{"location":"internals_of_indexing/","page":"Internals of Indexing","title":"Internals of Indexing","text":"This allows each axis to influence how an argument maps to indices. The combination of a given axis and argument produce a trait that directs this mapping.","category":"page"},{"location":"internals_of_indexing/","page":"Internals of Indexing","title":"Internals of Indexing","text":"AxisIndices.to_index(axis, arg) = to_index(AxisIndicesStyle(axis, arg), axis, arg)","category":"page"},{"location":"internals_of_indexing/","page":"Internals of Indexing","title":"Internals of Indexing","text":"Note that this to_index method is completely unique from the one implemented in Base [1].","category":"page"},{"location":"internals_of_indexing/","page":"Internals of Indexing","title":"Internals of Indexing","text":"Functionally, this translates to retrieving the elements of an AbstractIndicesArray like so:","category":"page"},{"location":"internals_of_indexing/","page":"Internals of Indexing","title":"Internals of Indexing","text":"A[arg1, arg2] ->\nparent(A)[to_indices(A, (arg1, arg2))...] ->\nparent(A)[to_indices(A, axes(A), (arg1, arg2))...] ->\nparent(A)[indices...] -> sub_A","category":"page"},{"location":"internals_of_indexing/#Reconstructing-Axes","page":"Internals of Indexing","title":"Reconstructing Axes","text":"","category":"section"},{"location":"internals_of_indexing/","page":"Internals of Indexing","title":"Internals of Indexing","text":"Once the new array is composed axes need to be reconstructed through to_axes, which essentially is the reverse of to_indices. Instead of passing each argument to to_index they're passed to to_key [2].","category":"page"},{"location":"internals_of_indexing/","page":"Internals of Indexing","title":"Internals of Indexing","text":"AxisIndices.to_key(axis, arg, index) = to_key(AxisIndicesStyle(axis, arg), axis, arg, index)","category":"page"},{"location":"internals_of_indexing/","page":"Internals of Indexing","title":"Internals of Indexing","text":"The resulting keys produced are combined with the relevant indices of the new array to reconstruct the axis[3].","category":"page"},{"location":"internals_of_indexing/#AxisIndicesStyle","page":"Internals of Indexing","title":"AxisIndicesStyle","text":"","category":"section"},{"location":"internals_of_indexing/","page":"Internals of Indexing","title":"Internals of Indexing","text":"You may have noticed that AxisIndicesStyle is in the last part of to_index and to_key described. AxisIndicesStyle is the supertype for a set of traits that determine what each argument means in the context of an axis. For example, AxisIndicesStyle(::AbstractAxis, ::Integer) returns IndexElement, telling to_index and to_key that the provided argument directly corresponds to an index with an axis. Contrast this with KeyElement which tells to_index to find the position of the provided argument within the keys and return the corresponding index. These traits are fully responsible for dispatch to to_index and to_keys. Therefore, new subtypes of AxisIndicesStyle must define a to_index and to_keys method.","category":"page"},{"location":"internals_of_indexing/","page":"Internals of Indexing","title":"Internals of Indexing","text":"[1]: There's absolutely no functionality provided from Base.to_index that isn't already available with AxisIndices.to_index. Providing a seperate implementation is meant to avoid causing any unecessary ambiguities in this or any other packages that may be simultaneously loaded.","category":"page"},{"location":"internals_of_indexing/","page":"Internals of Indexing","title":"Internals of Indexing","text":"[2]: Why do we need the index produced in the previous to_index method to reconstruct keys? Technically we don't, but it avoids looking up indices a second time and ensuring they are inbounds.","category":"page"},{"location":"internals_of_indexing/","page":"Internals of Indexing","title":"Internals of Indexing","text":"[3]: It is at this point that unsafe_reconstruct is called. This is only important to know if you want to create a new axis type that has keys that require some unique procedure to reconstruct.","category":"page"}]
}
