var documenterSearchIndex = {"docs":
[{"location":"comparison/#Comparison-to-Other-Packages-1","page":"Comparison to Other Packages","title":"Comparison to Other Packages","text":"","category":"section"},{"location":"comparison/#","page":"Comparison to Other Packages","title":"Comparison to Other Packages","text":"This is very brief overview of how AxisIndices compares to other packages. Rather than a comprehensive comparison of available alternatives and integrations, this is intended to provide a general idea of how AxisIndices fits in the Julia ecosystem.","category":"page"},{"location":"comparison/#","page":"Comparison to Other Packages","title":"Comparison to Other Packages","text":"AxisArrays.jl similarly supports mapping some sort of keys to each set of indices. AxisIndices is intended to be a more comprehensive, well documented, and flexible implementation of this concept. AxisArays natively offers the ability to name each dimension. In contrast AxisIndices was developed with the intention of using packages like NamedDims.jl to more fully implement such features in a complementary way.","category":"page"},{"location":"comparison/#","page":"Comparison to Other Packages","title":"Comparison to Other Packages","text":"DimensionalData.jl is a notable package that covers many similar funcitonalities as AxisArrays did. There are numerous differences in design decisions between this package and DimensionalData. It's likely that the majority of these differences represent personal preferences rather than strictly objective advantages over one another. In terms of approach, DimensionalData offers a more comprehensive alternative to the functionality of AxisArrays, where AxisIndices is intended only to be a highly customizable component of some of the features AxisArrays offers. Therefore, this package expects users seeking a complete replacement for AxisArrays to ultimately use another package that composes a modular solution to replacing AxisArrays.","category":"page"},{"location":"comparison/#","page":"Comparison to Other Packages","title":"Comparison to Other Packages","text":"There are many packages that offer overlapping features. For example, Dictionaries.jl implements a focused improvement on dictionaries where mapping keys to indices highly overlaps. However, as Dictionaries.jl continues to evolve many of the types provided therein may prove extremely useful in constructing the keys of an Axis type thereby giving these dictionaries multidimensional functionality. Similarly, many packages provide overlapping features that could actually be extended with the addition of AxisIndices.","category":"page"},{"location":"development/#Development-1","page":"Development","title":"Development","text":"","category":"section"},{"location":"development/#Style-1","page":"Development","title":"Style","text":"","category":"section"},{"location":"development/#","page":"Development","title":"Development","text":"In addition to attempting to follow the BlueStyle guide this package also attempts to consistently use the following conventions internally.","category":"page"},{"location":"development/#","page":"Development","title":"Development","text":"axis - refers to an AbstractAxis\nks - refers to the keys of an axis\ninds - refers to the indices of an axis\narg(s) - ","category":"page"},{"location":"observations/#Observations-1","page":"Observations","title":"Observations","text":"","category":"section"},{"location":"observations/#","page":"Observations","title":"Observations","text":"The AxisIndices.ObservationDims module is experimental and demonstrates the convenience of generating methods using the @defdim macro.","category":"page"},{"location":"observations/#Example-usage-1","page":"Observations","title":"Example usage","text":"","category":"section"},{"location":"observations/#","page":"Observations","title":"Observations","text":"Let's create some data where each observation represents a unique set of subject measurements.","category":"page"},{"location":"observations/#","page":"Observations","title":"Observations","text":"julia> using AxisIndices\n\njulia> data = NamedAxisArray(reshape(1:6, 2, 3), x = 2:3, observations = [:subject_1, :subject_2, :subject_3])\n2×3 NamedAxisArray{Int64,2}\n • x - 2:3\n • observations - [:subject_1, :subject_2, :subject_3]\n      subject_1   subject_2   subject_3\n  2           1           3           5\n  3           2           4           6\n","category":"page"},{"location":"observations/#","page":"Observations","title":"Observations","text":"The ObservationDims module isn't necessary to access observations or subject specific data...","category":"page"},{"location":"observations/#","page":"Observations","title":"Observations","text":"julia> data[observations = :subject_1]\n2-element NamedAxisArray{Int64,1}\n • x - 2:3\n\n  2   1\n  3   2\n","category":"page"},{"location":"observations/#","page":"Observations","title":"Observations","text":"But there are a number of convenient methods for accessing observation data with this module.","category":"page"},{"location":"observations/#","page":"Observations","title":"Observations","text":"julia> using AxisIndices.ObservationDims\n\njulia> obsdim(data)  # the dimension along which observations are enumerated\n2\n\njulia> nobs(data)  # the number of distinct observations\n3\n\njulia> obs_keys(data)  # the key for each observation\n3-element Array{Symbol,1}:\n :subject_1\n :subject_2\n :subject_3\n","category":"page"},{"location":"observations/#","page":"Observations","title":"Observations","text":"There are several other useful methods such as each_obs which supports iterating along the observation dimension. Such methods may be helpful in development of an API. For example, multiple dispatch could be used to return an observation iterator with each_obs on non array types also.","category":"page"},{"location":"observations/#Reference-1","page":"Observations","title":"Reference","text":"","category":"section"},{"location":"observations/#","page":"Observations","title":"Observations","text":"Pages   = [\"observations.md\"]\nModules = [AxisIndices.ObservationDims]\nOrder   = [:function, :type]","category":"page"},{"location":"observations/#","page":"Observations","title":"Observations","text":"Modules = [AxisIndices.ObservationDims]","category":"page"},{"location":"observations/#AxisIndices.ObservationDims.each_obs-Tuple{Any}","page":"Observations","title":"AxisIndices.ObservationDims.each_obs","text":"each_obs(x)\n\nCreate a generator that iterates over the obs dimensions A, returning views that select all the data from the other dimensions in A.\n\n\n\n\n\n","category":"method"},{"location":"observations/#AxisIndices.ObservationDims.has_obsdim-Tuple{Any}","page":"Observations","title":"AxisIndices.ObservationDims.has_obsdim","text":"has_obsdim(x) -> Bool\n\nReturns true if x has a dimension corresponding to obs.\n\n\n\n\n\n","category":"method"},{"location":"observations/#AxisIndices.ObservationDims.nobs-Tuple{Any}","page":"Observations","title":"AxisIndices.ObservationDims.nobs","text":"nobs(x) -> Int\n\nReturns the size along the dimension corresponding to the obs.\n\n\n\n\n\n","category":"method"},{"location":"observations/#AxisIndices.ObservationDims.obs_axis-Tuple{Any}","page":"Observations","title":"AxisIndices.ObservationDims.obs_axis","text":"obs_axis(x)\n\nReturns the axis corresponding to the obs dimension.\n\n\n\n\n\n","category":"method"},{"location":"observations/#AxisIndices.ObservationDims.obs_axis_type-Tuple{Any}","page":"Observations","title":"AxisIndices.ObservationDims.obs_axis_type","text":"obs_axis_type(x)\n\nReturns the key type corresponding to the obs axis.\n\n\n\n\n\n","category":"method"},{"location":"observations/#AxisIndices.ObservationDims.obs_indices-Tuple{Any}","page":"Observations","title":"AxisIndices.ObservationDims.obs_indices","text":"obs_indices(x)\n\nReturns the indices corresponding to the obs axis\n\n\n\n\n\n","category":"method"},{"location":"observations/#AxisIndices.ObservationDims.obs_keys-Tuple{Any}","page":"Observations","title":"AxisIndices.ObservationDims.obs_keys","text":"obs_keys(x)\n\nReturns the keys corresponding to the obs axis\n\n\n\n\n\n","category":"method"},{"location":"observations/#AxisIndices.ObservationDims.obsdim-Tuple{Any}","page":"Observations","title":"AxisIndices.ObservationDims.obsdim","text":"obsdim(x) -> Int\n\nReturns the dimension corresponding to the obs.\n\n\n\n\n\n","category":"method"},{"location":"observations/#AxisIndices.ObservationDims.select_obsdim-Tuple{Any,Any}","page":"Observations","title":"AxisIndices.ObservationDims.select_obsdim","text":"select_obsdim(x, i)\n\nReturn a view of all the data of x where the index for the obs dimension equals i.\n\n\n\n\n\n","category":"method"},{"location":"axis/#The-Axis-Interface-1","page":"Axis Interface","title":"The Axis Interface","text":"","category":"section"},{"location":"axis/#","page":"Axis Interface","title":"Axis Interface","text":"The following describes the components necessary to construct and manipulate existing and new subtypes of AbstractAxis.","category":"page"},{"location":"axis/#Introduction-1","page":"Axis Interface","title":"Introduction","text":"","category":"section"},{"location":"axis/#","page":"Axis Interface","title":"Axis Interface","text":"The supertype to all axis types herein is the AbstractAxis, which is a subtype of AbstractUnitRange{<:Integer}.","category":"page"},{"location":"axis/#","page":"Axis Interface","title":"Axis Interface","text":"If we have a set of keys a b c and a set of indices 1 2 3 then the key a maps to the index 1. Given these definitions, the AbstractAxis differs from the classic dictionary in the following two ways:","category":"page"},{"location":"axis/#","page":"Axis Interface","title":"Axis Interface","text":"The valtype of AbstractAxis is always an integer.\nThe values are always unique and continuous.","category":"page"},{"location":"axis/#","page":"Axis Interface","title":"Axis Interface","text":"The two main axis types defined here are Axis and SimpleAxis. The standard syntax for indexing doesn't change at all for these types.","category":"page"},{"location":"axis/#","page":"Axis Interface","title":"Axis Interface","text":"julia> using AxisIndices\n\njulia> using Dates\n\njulia> using ChainedFixes  # provides `and`, `or`, `⩓`, `⩔` methods\n\njulia> sa = SimpleAxis(1:10)\nSimpleAxis(1:10)\n\njulia> sa[2]\n2\n\njulia> sa[>(2)]\nSimpleAxis(3:10)\n\njulia> a = Axis(1:10)\nAxis(1:10 => Base.OneTo(10))\n\njulia> a[2]\n2\n\njulia> a[2:3]\nAxis(2:3 => 2:3)","category":"page"},{"location":"axis/#","page":"Axis Interface","title":"Axis Interface","text":"But now we can also use functions to index by the keys of an AbstractAxis.","category":"page"},{"location":"axis/#","page":"Axis Interface","title":"Axis Interface","text":"julia> a = Axis(2.0:11.0, 1:10)\nAxis(2.0:1.0:11.0 => 1:10)\n\njulia> a[1]\n1\n\njulia> a[isequal(2.0)]\n1\n\njulia> a[>(2)]\nAxis(3.0:1.0:11.0 => 2:10)\n\njulia> a[>(2.0)]\nAxis(3.0:1.0:11.0 => 2:10)\n\njulia> a[and(>(2.0), <(8.0))]\nAxis(3.0:1.0:7.0 => 2:6)\n\njulia> sa[in(3:5)]\nSimpleAxis(3:5)","category":"page"},{"location":"axis/#","page":"Axis Interface","title":"Axis Interface","text":"This also allows certain syntax special treatment because they are obviously not referring to traditional integer based indexing.","category":"page"},{"location":"axis/#","page":"Axis Interface","title":"Axis Interface","text":"julia> x, y, z = Axis([:one, :two, :three]), Axis([\"one\", \"two\", \"three\"]), Axis(Second(1):Second(1):Second(3));\n\njulia> x[:one]\n1\n\njulia> x[:one] == y[\"one\"] == z[Second(1)]\ntrue\n\njulia> x[[:one, :two]]\n2-element Array{Int64,1}:\n 1\n 2","category":"page"},{"location":"axis/#","page":"Axis Interface","title":"Axis Interface","text":"Note in the last example that a vector was returned instead of an AbstractAxis. An AbstractAxis is a subtype of AbstractUnitRange and therefore cannot be reformed after any operation that does not guarantee the return of another unit range. This is similar to the behavior of UnitRange in base.","category":"page"},{"location":"axis/#Indexing-an-Axis-1","page":"Axis Interface","title":"Indexing an Axis","text":"","category":"section"},{"location":"axis/#","page":"Axis Interface","title":"Axis Interface","text":"Setup for running axis examples.","category":"page"},{"location":"axis/#","page":"Axis Interface","title":"Axis Interface","text":"julia> using AxisIndices, Unitful, IntervalSets, ChainedFixes\n\njulia> using Unitful: s\n\njulia> time1 = Axis((1.5:.5:10)s)\nAxis((1.5:0.5:10.0) s => Base.OneTo(18))\n\njulia> time2 = Axis((1.5:.5:10)s, 2:19)\nAxis((1.5:0.5:10.0) s => 2:19)","category":"page"},{"location":"axis/#Indexing-With-Integers-1","page":"Axis Interface","title":"Indexing With Integers","text":"","category":"section"},{"location":"axis/#","page":"Axis Interface","title":"Axis Interface","text":"Integers will map directly to the indices of an axis.","category":"page"},{"location":"axis/#","page":"Axis Interface","title":"Axis Interface","text":"julia> time1[1]\n1\n\njulia> time1[2]\n2\n\njulia> time2[2]\n2\n\njulia> time2[1]\nERROR: BoundsError: attempt to access 18-element Axis((1.5:0.5:10.0) s => 2:19) at index [1]\n[...]","category":"page"},{"location":"axis/#","page":"Axis Interface","title":"Axis Interface","text":"Notice that time2[1] throws an error. This is because the indices of the time2 axis don't contain a 1 and begins at 2. This allows an axis to map to any single dimensional memory mapping, even if it doesn't start at 1.","category":"page"},{"location":"axis/#","page":"Axis Interface","title":"Axis Interface","text":"Indexing an axis with a collection of integers works similarly to indexing any other AbstractUnitRange. That is, using other subtypes of AbstractUnitRange preserves the structure...","category":"page"},{"location":"axis/#","page":"Axis Interface","title":"Axis Interface","text":"julia> time1[1:2]\nAxis((1.5:0.5:2.0) s => 1:2)\n\njulia> time2[2:3]\nAxis((1.5:0.5:2.0) s => 2:3)","category":"page"},{"location":"axis/#","page":"Axis Interface","title":"Axis Interface","text":"However, we can't ensure that the resulting range will have a step of one in other cases so only the indices are returned.","category":"page"},{"location":"axis/#","page":"Axis Interface","title":"Axis Interface","text":"julia> time1[1:2:4]\n1:2:3\n\njulia> time1[[1, 2, 3]]\n3-element Array{Int64,1}:\n 1\n 2\n 3\n\njulia> time1[firstindex(time1):end]\nAxis((1.5:0.5:10.0) s => 1:18)\n","category":"page"},{"location":"axis/#Indexing-With-Keys-1","page":"Axis Interface","title":"Indexing With Keys","text":"","category":"section"},{"location":"axis/#","page":"Axis Interface","title":"Axis Interface","text":"julia> time1[1.5s]\n1\n\njulia> time2[1.5s]\n2","category":"page"},{"location":"axis/#","page":"Axis Interface","title":"Axis Interface","text":"julia> time1[1.5s..3s]\nAxis((1.5:0.5:3.0) s => 1:4)\n\njulia> time1[3s..4.5s]\nAxis((3.0:0.5:4.5) s => 4:7)","category":"page"},{"location":"axis/#Keys-and-Indices-1","page":"Axis Interface","title":"Keys and Indices","text":"","category":"section"},{"location":"axis/#","page":"Axis Interface","title":"Axis Interface","text":"If our keys are integers and we want to ensure that we always refer keys we can use Keys","category":"page"},{"location":"axis/#","page":"Axis Interface","title":"Axis Interface","text":"julia> Axis((2:11), 1:10)[Keys(<(5))]\nAxis(2:4 => 1:3)\n\njulia> Axis((2:11), 1:10)[Indices(<(5))]\nAxis(2:5 => 1:4)\n\njulia> Axis((2:11), 1:10)[Keys(3)]\n2\n\njulia> Axis((2:11), 1:10)[Indices(3)]\n3\n","category":"page"},{"location":"axis/#Approximate-Indexing-1","page":"Axis Interface","title":"Approximate Indexing","text":"","category":"section"},{"location":"axis/#","page":"Axis Interface","title":"Axis Interface","text":"julia> axis = Axis([pi + 0, pi + 1]);\n\njulia> axis[3.141592653589793]\n1\n\njulia> axis[3.14159265358979]\nERROR: BoundsError: attempt to access 2-element Axis([3.141592653589793, 4.141592653589793] => OneToMRange(2)) at index [3.14159265358979]\n[...]\n\njulia> axis[isapprox(3.14159265358979)]\n1\n\njulia> axis[isapprox(3.14, atol=1e-2)]\n1","category":"page"},{"location":"axis/#Indexing-With-Functions-1","page":"Axis Interface","title":"Indexing With Functions","text":"","category":"section"},{"location":"axis/#","page":"Axis Interface","title":"Axis Interface","text":"Operators that typically return true or false can often ","category":"page"},{"location":"axis/#","page":"Axis Interface","title":"Axis Interface","text":"julia> time1[<(3.0s)]\nAxis((1.5:0.5:2.5) s => 1:3)\n\njulia> time1[>(3.0s)]\nAxis((3.5:0.5:10.0) s => 5:18)\n\njulia> time1[==(6.0s)]\n10\n\njulia> time1[!=(6.0s)] == vcat(1:9, 11:18)\ntrue","category":"page"},{"location":"axis/#","page":"Axis Interface","title":"Axis Interface","text":"These operators can also be combined to get more specific regions of an axis.","category":"page"},{"location":"axis/#","page":"Axis Interface","title":"Axis Interface","text":"julia> time1[and(>(2.5s), <(10.0s))]\nAxis((3.0:0.5:9.5) s => 4:17)\n\njulia> time1[>(2.5s) ⩓ <(10.0s)]  # equivalent to `and` you can use \\And<TAB>\nAxis((3.0:0.5:9.5) s => 4:17)\n\njulia> time1[or(<(2.5s),  >(9.0s))] == vcat(1:2, 17:18)\ntrue\n\njulia> time1[<(2.5s) ⩔ >(9.0s)] == vcat(1:2, 17:18) # equivalent to `or` you can use \\Or<TAB>\ntrue\n","category":"page"},{"location":"axis/#Performance-1","page":"Axis Interface","title":"Performance","text":"","category":"section"},{"location":"axis/#","page":"Axis Interface","title":"Axis Interface","text":"Indexing CartesianAxes is comparable to that of CartesianIndices.","category":"page"},{"location":"axis/#","page":"Axis Interface","title":"Axis Interface","text":"julia> using AxisIndices, BenchmarkTools\n\njulia> cartaxes = CartesianAxes((Axis(2.0:5.0), Axis(1:4)));\n\njulia> cartinds = CartesianIndices((1:4, 1:4));\n\njulia> @btime getindex(cartaxes, 2, 2)\n20.848 ns (1 allocation: 32 bytes)\nCartesianIndex(2, 2)\n\njulia> @btime getindex(cartinds, 2, 2)\n22.317 ns (1 allocation: 32 bytes)\nCartesianIndex(2, 2)\n\njulia> @btime getindex(cartaxes, ==(3.0), 2)\n444.374 ns (7 allocations: 416 bytes)\nCartesianIndex(2, 2)","category":"page"},{"location":"axis/#","page":"Axis Interface","title":"Axis Interface","text":"Indexing LinearAxes is comparable to that of LinearIndices","category":"page"},{"location":"axis/#","page":"Axis Interface","title":"Axis Interface","text":"julia> using AxisIndices, BenchmarkTools\n\njulia> linaxes = LinearAxes((Axis(1.0:4.0), Axis(1:4)));\n\njulia> lininds = LinearIndices((1:4, 1:4));\n\njulia> @btime getindex(linaxes, 2, 2)\n18.275 ns (0 allocations: 0 bytes)\n6\n\njulia> @btime getindex(lininds, 2, 2)\n18.849 ns (0 allocations: 0 bytes)\n6\n\njulia> @btime getindex(linaxes, ==(3.0), 2)\n381.098 ns (6 allocations: 384 bytes)\n7","category":"page"},{"location":"axis/#","page":"Axis Interface","title":"Axis Interface","text":"You may notice there's significant overhead for using the filtering syntax. However, the filtering syntax takes advantage of a special type in base, Fix2. This means that we can take advantage of filtering methods that have been optimized for specific types of keys.  Here we do the same thing as above but we create a function that knows it's going to perform filtering.","category":"page"},{"location":"axis/#","page":"Axis Interface","title":"Axis Interface","text":"julia> getindex_filter(a, i1, i2) = a[==(i1), ==(i2)]\ngetindex_filter (generic function with 1 method)\n\njulia> @btime getindex_filter(linaxes, 3.0, 2)\n57.216 ns (0 allocations: 0 bytes)\n7\n\njulia> linaxes2 = LinearAxes((Axis(Base.OneTo(4)), Axis(Base.OneTo(4))));\n\njulia> @btime getindex_filter(linaxes2, 3, 2)\n22.070 ns (0 allocations: 0 bytes)\n7","category":"page"},{"location":"axis/#","page":"Axis Interface","title":"Axis Interface","text":"Indexing linaxes is much faster now that it can be optimized inside of a function call. However, it's still a little over twice as slow as normal indexing. That's largely because of the cost of searching 1.0:4.0 (which is a StepRangeLen type in this case). The second benchmark demonstrates how close we really are to standard indexing given similar range types.","category":"page"},{"location":"axis/#Reference-1","page":"Axis Interface","title":"Reference","text":"","category":"section"},{"location":"axis/#","page":"Axis Interface","title":"Axis Interface","text":"Pages   = [\"axis.md\"]\nModules = [AxisIndices.Interface, AxisIndices.Axes]\nOrder   = [:function, :type]","category":"page"},{"location":"axis/#","page":"Axis Interface","title":"Axis Interface","text":"Modules = [AxisIndices.Interface]","category":"page"},{"location":"axis/#AxisIndices.Interface.axes_keys-Tuple{Any,Any}","page":"Axis Interface","title":"AxisIndices.Interface.axes_keys","text":"axes_keys(x, i)\n\nReturns the axis keys corresponding of ith dimension of x.\n\nExamples\n\njulia> using AxisIndices\n\njulia> axes_keys(AxisArray(ones(2,2), (2:3, 3:4)), 1)\n2:3\n\n\n\n\n\n","category":"method"},{"location":"axis/#AxisIndices.Interface.axes_keys-Tuple{Any}","page":"Axis Interface","title":"AxisIndices.Interface.axes_keys","text":"axes_keys(x) -> Tuple\n\nReturns the keys corresponding to all axes of x.\n\nExamples\n\njulia> using AxisIndices\n\njulia> axes_keys(AxisArray(ones(2,2), (2:3, 3:4)))\n(2:3, 3:4)\n\njulia> axes_keys(Axis(1:2))\n(1:2,)\n\n\n\n\n\n","category":"method"},{"location":"axis/#AxisIndices.Interface.axis_eltype-Tuple{Any,Any}","page":"Axis Interface","title":"AxisIndices.Interface.axis_eltype","text":"axis_eltype(x)\n\nReturns the type corresponds to the type of the ith element returned when slicing along that dimension.\n\n\n\n\n\n","category":"method"},{"location":"axis/#AxisIndices.Interface.axis_meta-Tuple{AbstractArray,Any}","page":"Axis Interface","title":"AxisIndices.Interface.axis_meta","text":"axis_meta(x, i)\n\nReturns metadata (i.e. not keys or indices) associated with the ith axis of the array x.\n\n\n\n\n\n","category":"method"},{"location":"axis/#AxisIndices.Interface.axis_meta-Tuple{AbstractArray}","page":"Axis Interface","title":"AxisIndices.Interface.axis_meta","text":"axis_meta(x)\n\nReturns metadata (i.e. not keys or indices) associated with each axis of the array x.\n\n\n\n\n\n","category":"method"},{"location":"axis/#AxisIndices.Interface.colaxis-Tuple{Any}","page":"Axis Interface","title":"AxisIndices.Interface.colaxis","text":"colaxis(x) -> axis\n\nReturns the axis corresponding to the second dimension of x.\n\nExamples\n\njulia> using AxisIndices\n\njulia> colaxis(AxisArray(ones(2,2), [\"a\", \"b\"], [:one, :two]))\nAxis([:one, :two] => Base.OneTo(2))\n\n\n\n\n\n\n","category":"method"},{"location":"axis/#AxisIndices.Interface.colkeys-Tuple{Any}","page":"Axis Interface","title":"AxisIndices.Interface.colkeys","text":"colkeys(x) -> axis\n\nReturns the keys corresponding to the second dimension of x.\n\nExamples\n\njulia> using AxisIndices\n\njulia> colkeys(AxisArray(ones(2,2), [\"a\", \"b\"], [:one, :two]))\n2-element Array{Symbol,1}:\n :one\n :two\n\n\n\n\n\n\n","category":"method"},{"location":"axis/#AxisIndices.Interface.coltype-Union{Tuple{T}, Tuple{T}} where T","page":"Axis Interface","title":"AxisIndices.Interface.coltype","text":"coltype(x)\n\nReturns the type of the axis corresponding to the second dimension of x.\n\nExamples\n\njulia> using AxisIndices\n\njulia> coltype(AxisArray(ones(2,2), [\"a\", \"b\"], [:one, :two]))\nAxis{Symbol,Int64,Array{Symbol,1},Base.OneTo{Int64}}\n\n\n\n\n\n","category":"method"},{"location":"axis/#AxisIndices.Interface.drop_axes-Tuple{AbstractArray,Int64}","page":"Axis Interface","title":"AxisIndices.Interface.drop_axes","text":"drop_axes(x, dims)\n\nReturns all axes of x except for those identified by dims. Elements of dims must be unique integers or symbols corresponding to the dimensions or names of dimensions of x.\n\nExamples\n\njulia> using AxisIndices\n\njulia> axs = (Axis(1:5), Axis(1:10));\n\njulia> AxisIndices.drop_axes(axs, 1)\n(Axis(1:10 => Base.OneTo(10)),)\n\njulia> AxisIndices.drop_axes(axs, 2)\n(Axis(1:5 => Base.OneTo(5)),)\n\njulia> AxisIndices.drop_axes(rand(2, 4), 2)\n(Base.OneTo(2),)\n\n\n\n\n\n","category":"method"},{"location":"axis/#AxisIndices.Interface.first_key-Tuple{Any}","page":"Axis Interface","title":"AxisIndices.Interface.first_key","text":"first_key(x)\n\nReturns the first key of x.\n\nExamples\n\njulia> using AxisIndices\n\njulia> first_key(Axis(2:10))\n2\n\n\n\n\n\n","category":"method"},{"location":"axis/#AxisIndices.Interface.has_dimnames-Union{Tuple{T}, Tuple{T}} where T","page":"Axis Interface","title":"AxisIndices.Interface.has_dimnames","text":"has_dimnames(x) -> Bool\n\nReturns true if x has names for each dimension.\n\n\n\n\n\n","category":"method"},{"location":"axis/#AxisIndices.Interface.has_metadata-Union{Tuple{T}, Tuple{T}} where T","page":"Axis Interface","title":"AxisIndices.Interface.has_metadata","text":"has_metadata(x) -> Bool\n\nReturns true if x contains additional fields besides those for keys or indices\n\n\n\n\n\n","category":"method"},{"location":"axis/#AxisIndices.Interface.indices-Tuple{AbstractUnitRange}","page":"Axis Interface","title":"AxisIndices.Interface.indices","text":"indices(x::AbstractUnitRange)\n\nReturns the indices x.\n\nExamples\n\njulia> using AxisIndices\n\njulia> indices(Axis([\"a\"], 1:1))\n1:1\n\njulia> indices(CartesianIndex(1,1))\n(1, 1)\n\n\n\n\n\n\n","category":"method"},{"location":"axis/#AxisIndices.Interface.indices-Tuple{Any,Any}","page":"Axis Interface","title":"AxisIndices.Interface.indices","text":"indices(x, i)\n\nReturns the indices corresponding to the i axis\n\nExamples\n\njulia> using AxisIndices\n\njulia> indices(AxisArray(ones(2,2), (2:3, 3:4)), 1)\nBase.OneTo(2)\n\n\n\n\n\n","category":"method"},{"location":"axis/#AxisIndices.Interface.indices-Tuple{Any}","page":"Axis Interface","title":"AxisIndices.Interface.indices","text":"indices(x) -> Tuple\n\nReturns the indices corresponding to all axes of x.\n\nExamples\n\njulia> using AxisIndices\n\njulia> indices(AxisArray(ones(2,2), (2:3, 3:4)))\n(Base.OneTo(2), Base.OneTo(2))\n\njulia> indices(Axis([\"a\"], 1:1))\n1:1\n\njulia> indices(CartesianIndex(1,1))\n(1, 1)\n\n\n\n\n\n\n","category":"method"},{"location":"axis/#AxisIndices.Interface.indices_type-Union{Tuple{T}, Tuple{T,Any}} where T","page":"Axis Interface","title":"AxisIndices.Interface.indices_type","text":"indices_type(x, i)\n\nRetrieves axis values of the ith dimension of x.\n\nExamples\n\njulia> using AxisIndices\n\njulia> indices_type([1], 1)\nBase.OneTo{Int64}\n\njulia> indices_type(typeof([1]), 1)\nBase.OneTo{Int64}\n\n\n\n\n\n","category":"method"},{"location":"axis/#AxisIndices.Interface.indices_type-Union{Tuple{T}, Tuple{T}} where T","page":"Axis Interface","title":"AxisIndices.Interface.indices_type","text":"indices_type(x)\n\nRetrieves the type of the values of x. This should be functionally equivalent to typeof(values(x)).\n\nExamples\n\njulia> using AxisIndices\n\njulia>  indices_type(Axis(1:2))\nBase.OneTo{Int64}\n\njulia> indices_type(typeof(Axis(1:2)))\nBase.OneTo{Int64}\n\njulia> indices_type(typeof(1:2))\nUnitRange{Int64}\n\n\n\n\n\n","category":"method"},{"location":"axis/#AxisIndices.Interface.is_indices_axis-Tuple{Any}","page":"Axis Interface","title":"AxisIndices.Interface.is_indices_axis","text":"is_indices_axis(x) -> Bool\n\nIf true then x is an axis type where the only field parameterizing the axis is a field for the values.\n\n\n\n\n\n","category":"method"},{"location":"axis/#AxisIndices.Interface.keys_type-Union{Tuple{T}, Tuple{T,Any}} where T","page":"Axis Interface","title":"AxisIndices.Interface.keys_type","text":"keys_type(x, i)\n\nRetrieves axis keys of the ith dimension of x.\n\nExamples\n\njulia> using AxisIndices\n\njulia> keys_type(AxisArray([1], [\"a\"]), 1)\nArray{String,1}\n\n\n\n\n\n","category":"method"},{"location":"axis/#AxisIndices.Interface.keys_type-Union{Tuple{T}, Tuple{T}} where T","page":"Axis Interface","title":"AxisIndices.Interface.keys_type","text":"keys_type(x)\n\nRetrieves the type of the keys of x.\n\nExamples\n\njulia> using AxisIndices\n\njulia> keys_type(Axis(1:2))\nUnitRange{Int64}\n\njulia> keys_type(typeof(Axis(1:2)))\nUnitRange{Int64}\n\njulia> keys_type(UnitRange{Int})\nBase.OneTo{Int64}\n\n\n\n\n\n","category":"method"},{"location":"axis/#AxisIndices.Interface.last_key-Tuple{Any}","page":"Axis Interface","title":"AxisIndices.Interface.last_key","text":"last_key(x)\n\nReturns the last key of x.\n\nExamples\n\njulia> using AxisIndices\n\njulia> last_key(Axis(2:10))\n10\n\n\n\n\n\n","category":"method"},{"location":"axis/#AxisIndices.Interface.metadata-Tuple{Any}","page":"Axis Interface","title":"AxisIndices.Interface.metadata","text":"metadata(x)\n\nReturns metadata for x.\n\n\n\n\n\n","category":"method"},{"location":"axis/#AxisIndices.Interface.metadata_type-Union{Tuple{T}, Tuple{T}} where T","page":"Axis Interface","title":"AxisIndices.Interface.metadata_type","text":"metadata_type(x)\n\nReturns the type of the metadata of x.\n\n\n\n\n\n","category":"method"},{"location":"axis/#AxisIndices.Interface.rowaxis-Tuple{Any}","page":"Axis Interface","title":"AxisIndices.Interface.rowaxis","text":"rowaxis(x) -> axis\n\nReturns the axis corresponding to the first dimension of x.\n\nExamples\n\njulia> using AxisIndices\n\njulia> rowaxis(AxisArray(ones(2,2), [\"a\", \"b\"], [:one, :two]))\nAxis([\"a\", \"b\"] => Base.OneTo(2))\n\n\n\n\n\n\n","category":"method"},{"location":"axis/#AxisIndices.Interface.rowkeys-Tuple{Any}","page":"Axis Interface","title":"AxisIndices.Interface.rowkeys","text":"rowkeys(x) -> axis\n\nReturns the keys corresponding to the first dimension of x.\n\nExamples\n\njulia> using AxisIndices\n\njulia> rowkeys(AxisArray(ones(2,2), [\"a\", \"b\"], [:one, :two]))\n2-element Array{String,1}:\n \"a\"\n \"b\"\n\n\n\n\n\n\n","category":"method"},{"location":"axis/#AxisIndices.Interface.rowtype-Union{Tuple{T}, Tuple{T}} where T","page":"Axis Interface","title":"AxisIndices.Interface.rowtype","text":"rowtype(x)\n\nReturns the type of the axis corresponding to the first dimension of x.\n\nExamples\n\njulia> using AxisIndices\n\njulia> rowtype(AxisArray(ones(2,2), [\"a\", \"b\"], [:one, :two]))\nAxis{String,Int64,Array{String,1},Base.OneTo{Int64}}\n\n\n\n\n\n","category":"method"},{"location":"axis/#AxisIndices.Interface.step_key-Tuple{AbstractArray{T,1} where T}","page":"Axis Interface","title":"AxisIndices.Interface.step_key","text":"step_key(x)\n\nReturns the step size of the keys of x.\n\nExamples\n\njulia> using AxisIndices\n\njulia> AxisIndices.step_key(Axis(1:2:10))\n2\n\njulia> AxisIndices.step_key(rand(2))\n1\n\njulia> AxisIndices.step_key([1])  # LinearIndices are treate like unit ranges\n1\n\n\n\n\n\n","category":"method"},{"location":"axis/#AxisIndices.Interface.unsafe_reconstruct-Tuple{AbstractArray,AbstractArray,Tuple}","page":"Axis Interface","title":"AxisIndices.Interface.unsafe_reconstruct","text":"unsafe_reconstruct(A::AbstractArray, new_parent, new_axes)\n\nReconstructs an AbstractArray of the same type as A but with the parent array parent and axes axes. This method depends on an underlying call to similar_types. It is considered unsafe because it bypasses safety checks to ensure the keys of each axis are unique and match the length of each dimension of parent. Therefore, this is not intended for interactive use and should only be used when it is clear all arguments are composed correctly.\n\n\n\n\n\n","category":"method"},{"location":"axis/#AxisIndices.Interface.unsafe_reconstruct-Tuple{AbstractUnitRange,Any,Any}","page":"Axis Interface","title":"AxisIndices.Interface.unsafe_reconstruct","text":"unsafe_reconstruct(axis, keys, indices)\n\nReconstructs an AbstractAxis of the same type as axis but with keys of type Ks and indices of type Vs. This method is considered unsafe because it bypasses checks  to ensure that keys and values have the same length and the all keys are unique.\n\n\n\n\n\n","category":"method"},{"location":"axis/#AxisIndices.Interface.unsafe_reconstruct-Tuple{AbstractUnitRange,Any}","page":"Axis Interface","title":"AxisIndices.Interface.unsafe_reconstruct","text":"unsafe_reconstruct(axis, indices)\n\nReconstructs an AbstractSimpleAxis of the same type as axis but values of type Vs.\n\n\n\n\n\n","category":"method"},{"location":"axis/#AxisIndices.Interface.@defdim-Tuple{Any,Any}","page":"Axis Interface","title":"AxisIndices.Interface.@defdim","text":"@defdim name condition\n\nProduces a series of methods for conveniently manipulating dimensions with specific names. condition is a method that returns true or false when given a name of a  dimension. For example, the following would produce methods for manipulating and accessing dimensions with the name :time.\n\njulia> is_time(x::Symbol) = x === :time\n\njulia> @defdim time is_time\n\n\nname is used to complete the following method names\n\nname_dim(x): returns the dimension number of dimension\nnname(x): returns the number of elements stored along the dimension\nhas_name_dim(x): returns true or false, indicating if the dimension is present\nname_axis(x): returns the axis corresponding to the dimension.\nname_indices(x): returns the indices corresponding to the dimension.\nname_keys(x): returns the keys corresponding to the dimension\nname_axis_type(x): returns the type of the axis corresponding to the dimension\nselect_name_dim(x, i): equivalent to selectdim(x, name_dim(x), i)\neach_name(x): equivalent to eachslice(x, name_dim(x))\n\nwarning: Warning\n@defdim should be considered experimental and subject to change\n\n\n\n\n\n","category":"macro"},{"location":"axis/#AxisIndices.Interface.append_axis!-Tuple{Any,Any}","page":"Axis Interface","title":"AxisIndices.Interface.append_axis!","text":"append_axis!(x, y)\n\n\n\n\n\n","category":"method"},{"location":"axis/#AxisIndices.Interface.append_keys!-Tuple{AbstractRange,Any}","page":"Axis Interface","title":"AxisIndices.Interface.append_keys!","text":"append_keys!(x, y)\n\n\n\n\n\n","category":"method"},{"location":"axis/#","page":"Axis Interface","title":"Axis Interface","text":"Modules = [AxisIndices.Axes]","category":"page"},{"location":"axis/#AxisIndices.Axes.AbstractAxis","page":"Axis Interface","title":"AxisIndices.Axes.AbstractAxis","text":"AbstractAxis\n\nAn AbstractVector subtype optimized for indexing.\n\n\n\n\n\n","category":"type"},{"location":"axis/#AxisIndices.Axes.AbstractSimpleAxis","page":"Axis Interface","title":"AxisIndices.Axes.AbstractSimpleAxis","text":"AbstractSimpleAxis{V,Vs}\n\nA subtype of AbstractAxis where the keys and values are represented by a single collection.\n\n\n\n\n\n","category":"type"},{"location":"axis/#AxisIndices.Axes.Axis","page":"Axis Interface","title":"AxisIndices.Axes.Axis","text":"Axis(k[, v=OneTo(length(k))])\n\nSubtypes of AbstractAxis that maps keys to values. The first argument specifies the keys and the second specifies the values. If only one argument is specified then the values span from 1 to the length of k.\n\nExamples\n\nThe value for all of these is the same.\n\njulia> using AxisIndices\n\njulia> x = Axis(2.0:11.0, 1:10)\nAxis(2.0:1.0:11.0 => 1:10)\n\njulia> y = Axis(2.0:11.0)  # when only one argument is specified assume it's the keys\nAxis(2.0:1.0:11.0 => Base.OneTo(10))\n\njulia> z = Axis(1:10)\nAxis(1:10 => Base.OneTo(10))\n\nStandard indexing returns the same values\n\njulia> x[2]\n2\n\njulia> x[2] == y[2] == z[2]\ntrue\n\njulia> x[1:2]\nAxis(2.0:1.0:3.0 => 1:2)\n\njulia> y[1:2]\nAxis(2.0:1.0:3.0 => 1:2)\n\njulia> z[1:2]\nAxis(1:2 => 1:2)\n\njulia> x[1:2] == y[1:2] == z[1:2]\ntrue\n\nFunctions that return true or false may be used to search the keys for their corresponding index. The following is equivalent to the previous example.\n\njulia> x[==(3.0)]\n2\n\njulia> x[==(3.0)] ==       # 3.0 is the 2nd key of x\n       y[isequal(3.0)] ==  # 3.0 is the 2nd key of y\n       z[==(2)]            # 2 is the 2nd key of z\ntrue\n\njulia> x[<(4.0)]  # all keys less than 4.0 are 2.0:3.0 which correspond to values 1:2\nAxis(2.0:1.0:3.0 => 1:2)\n\njulia> y[<=(3.0)]  # all keys less than or equal to 3.0 are 2.0:3.0 which correspond to values 1:2\nAxis(2.0:1.0:3.0 => 1:2)\n\njulia> z[<(3)]  # all keys less than or equal to 3 are 1:2 which correspond to values 1:2\nAxis(1:2 => 1:2)\n\njulia> x[<(4.0)] == y[<=(3.0)] == z[<(3)]\ntrue\n\nNotice that == returns a single value instead of a collection of all elements where the key was found to be true. This is because all keys must be unique so there can only ever be one element returned.\n\n\n\n\n\n","category":"type"},{"location":"axis/#AxisIndices.Axes.CartesianAxes","page":"Axis Interface","title":"AxisIndices.Axes.CartesianAxes","text":"CartesianAxes\n\nAlias for LinearIndices where indices are subtypes of AbstractAxis.\n\nExamples\n\njulia> using AxisIndices\n\njulia> cartaxes = CartesianAxes((Axis(2.0:5.0), Axis(1:4)));\n\njulia> cartinds = CartesianIndices((1:4, 1:4));\n\njulia> cartaxes[2, 2]\nCartesianIndex(2, 2)\n\njulia> cartinds[2, 2]\nCartesianIndex(2, 2)\n\n\n\n\n\n","category":"type"},{"location":"axis/#AxisIndices.Axes.CenteredAxis","page":"Axis Interface","title":"AxisIndices.Axes.CenteredAxis","text":"CenteredAxis(indices)\n\nNote: the element type of a CenteredAxis cannot be unsigned because any instance with a length greater than 1 will begin at a negative value.\n\n\n\n\n\n","category":"type"},{"location":"axis/#AxisIndices.Axes.LinearAxes","page":"Axis Interface","title":"AxisIndices.Axes.LinearAxes","text":"LinearAxes\n\nAlias for LinearIndices where indices are subtypes of AbstractAxis.\n\nExamples\n\njulia> using AxisIndices\n\njulia> linaxes = LinearAxes((Axis(2.0:5.0), Axis(1:4)));\n\njulia> lininds = LinearIndices((1:4, 1:4));\n\njulia> linaxes[2, 2]\n6\n\njulia> lininds[2, 2]\n6\n\n\n\n\n\n","category":"type"},{"location":"axis/#AxisIndices.Axes.MetaAxis","page":"Axis Interface","title":"AxisIndices.Axes.MetaAxis","text":"MetaAxis\n\nAn axis type that allows storage of arbitraty metadata.\n\n\n\n\n\n","category":"type"},{"location":"axis/#AxisIndices.Axes.SimpleAxis","page":"Axis Interface","title":"AxisIndices.Axes.SimpleAxis","text":"SimpleAxis(v)\n\nPovides an AbstractAxis interface for any AbstractUnitRange, v. v will be considered both the values and keys of the return instance. \n\nExamples\n\nA SimpleAxis is useful for giving a standard set of indices the ability to use the filtering syntax for indexing.\n\njulia> using AxisIndices, StaticRanges\n\njulia> x = SimpleAxis(2:10)\nSimpleAxis(2:10)\n\njulia> x[2]\n2\n\njulia> x[==(2)]\n2\n\njulia> x[2] == x[==(2)]  # keys and values are same\ntrue\n\njulia> x[>(2)]\nSimpleAxis(3:10)\n\njulia> x[>(2)]\nSimpleAxis(3:10)\n\njulia> x[1]\nERROR: BoundsError: attempt to access 9-element SimpleAxis(2:10 => 2:10) at index [1]\n[...]\n\n\n\n\n\n","category":"type"},{"location":"axis/#AxisIndices.Axes.SimpleAxis-Tuple{Integer,Integer}","page":"Axis Interface","title":"AxisIndices.Axes.SimpleAxis","text":"SimpleAxis(start::Integer, stop::Integer) -> SimpleAxis{UnitRange{Integer}}\n\nPasses start and stop arguments to UnitRange to construct the values of SimpleAxis.\n\nExamples\n\njulia> using AxisIndices\n\njulia> SimpleAxis(1, 10)\nSimpleAxis(1:10)\n\n\n\n\n\n","category":"method"},{"location":"axis/#AxisIndices.Axes.SimpleAxis-Tuple{Integer}","page":"Axis Interface","title":"AxisIndices.Axes.SimpleAxis","text":"SimpleAxis(stop::Integer) -> SimpleAxis{Base.OneTo{Integer}}\n\nPasses stop Base.OneTo to construct the values of SimpleAxis.\n\nExamples\n\njulia> using AxisIndices\n\njulia> SimpleAxis(10)\nSimpleAxis(Base.OneTo(10))\n\n\n\n\n\n","category":"method"},{"location":"axis/#AxisIndices.Axes.StructAxis","page":"Axis Interface","title":"AxisIndices.Axes.StructAxis","text":"StructAxis{T}\n\nAn axis that uses a structure T to form its keys. the field names of\n\n\n\n\n\n","category":"type"},{"location":"axis/#AxisIndices.Axes.structview-Tuple{Any}","page":"Axis Interface","title":"AxisIndices.Axes.structview","text":"structview(A)\n\nCreates a MappedArray using the StructAxis of A to identify the dimension that needs to be collapsed into a series of SubArrays as views that composed the MappedArray\n\n\n\n\n\n","category":"method"},{"location":"axis/#AxisIndices.Axes.permute_axes-Tuple{AbstractArray{T,1} where T}","page":"Axis Interface","title":"AxisIndices.Axes.permute_axes","text":"permute_axes(x::AbstractVector)\n\nReturns the permuted axes of x as axes of size 1 × length(x)\n\nExamples\n\njulia> using AxisIndices, StaticRanges\n\njulia> length.(AxisIndices.permute_axes(rand(4))) == (1, 4)\ntrue\n\njulia> AxisIndices.permute_axes((Axis(1:4),))\n(SimpleAxis(Base.OneTo(1)), Axis(1:4 => Base.OneTo(4)))\n\njulia> AxisIndices.permute_axes((Axis(mrange(1, 4)),))\n(SimpleAxis(OneToMRange(1)), Axis(UnitMRange(1:4) => OneToMRange(4)))\n\njulia> AxisIndices.permute_axes((Axis(srange(1, 4)),))\n(SimpleAxis(OneToSRange(1)), Axis(UnitSRange(1:4) => OneToSRange(4)))\n\n\n\n\n\n\n","category":"method"},{"location":"axis/#AxisIndices.Axes.permute_axes-Tuple{AbstractArray{T,2} where T}","page":"Axis Interface","title":"AxisIndices.Axes.permute_axes","text":"permute_axes(m::AbstractMatrix) -> NTuple{2}\n\nPermute the axes of the matrix m, by flipping the elements across the diagonal of the matrix. Differs from LinearAlgebra's transpose in that the operation is not recursive.\n\nExamples\n\njulia> using AxisIndices\n\njulia> AxisIndices.permute_axes(rand(4, 2))\n(Base.OneTo(2), Base.OneTo(4))\n\njulia> AxisIndices.permute_axes((Axis(1:4), Axis(1:2)))\n(Axis(1:2 => Base.OneTo(2)), Axis(1:4 => Base.OneTo(4)))\n\n\n\n\n\n\n","category":"method"},{"location":"axis/#AxisIndices.Axes.permute_axes-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T,N},Any}} where N where T","page":"Axis Interface","title":"AxisIndices.Axes.permute_axes","text":"permute_axes(x::AbstractArray, perms::Tuple) = permute_axes(axes(x), p)\npermute_axes(x::NTuple{N}, perms::NTuple{N}) -> NTuple{N}\n\nReturns axes of x in the order of p.\n\nExamples\n\njulia> using AxisIndices\n\njulia> AxisIndices.permute_axes(rand(2, 4, 6), (1, 3, 2))\n(Base.OneTo(2), Base.OneTo(6), Base.OneTo(4))\n\njulia> AxisIndices.permute_axes((Axis(1:2), Axis(1:4), Axis(1:6)), (1, 3, 2))\n(Axis(1:2 => Base.OneTo(2)), Axis(1:6 => Base.OneTo(6)), Axis(1:4 => Base.OneTo(4)))\n\n\n\n\n\n\n","category":"method"},{"location":"axis/#Base.similar","page":"Axis Interface","title":"Base.similar","text":"similar(axis::AbstractAxis, new_keys::AbstractVector, new_indices::AbstractUnitRange{Integer} [, check_length::Bool=true] ) -> AbstractAxis\n\nCreate a new instance of an axis of the same type as axis but with the keys new_keys and indices new_indices. If check_length is true then the lengths of new_keys and new_indices are checked to ensure they have the same length before construction.\n\nExamples\n\njulia> using AxisIndices\n\njulia> similar(Axis(1.0:10.0, 1:10), [:one, :two], UInt(1):UInt(2))\nAxis([:one, :two] => 0x0000000000000001:0x0000000000000002)\n\njulia> similar(Axis(1.0:10.0, 1:10), [:one, :two], UInt(1):UInt(3))\nERROR: DimensionMismatch(\"keys and indices must have same length, got length(keys) = 2 and length(indices) = 3.\")\n[...]\n\n\n\n\n\n","category":"function"},{"location":"axis/#Base.similar-Tuple{AbstractAxis,AbstractArray{T,1} where T}","page":"Axis Interface","title":"Base.similar","text":"similar(axis::AbstractAxis, new_keys::AbstractVector) -> AbstractAxis\n\nCreate a new instance of an axis of the same type as axis but with the keys new_keys\n\nExamples\n\njulia> using AxisIndices\n\njulia> similar(Axis(1.0:10.0, 1:10), [:one, :two])\nAxis([:one, :two] => 1:2)\n\n\n\n\n\n","category":"method"},{"location":"axis/#Base.similar-Tuple{AbstractAxis,AbstractUnitRange{#s36} where #s36<:Integer}","page":"Axis Interface","title":"Base.similar","text":"similar(axis::AbstractAxis, new_indices::AbstractUnitRange)\n\nCreate a new instance of an axis of the same type as axis but with the keys new_keys\n\nExamples\n\njulia> using AxisIndices\n\njulia> similar(SimpleAxis(1:10), 1:3)\nSimpleAxis(1:3)\n\n\n\n\n\n","category":"method"},{"location":"pretty_printing/#Pretty-Printing-1","page":"Pretty Printing","title":"Pretty Printing","text":"","category":"section"},{"location":"pretty_printing/#","page":"Pretty Printing","title":"Pretty Printing","text":"It's important that we can view the custom indices that we assign to arrays. Yet a surprising challenge of implementing and using arrays in interactive programming is how complicated printing them can be. Rather than burdening users with cryptic text readouts this package seeks to provide \"pretty\" printing (quotes because beauty is in the eye of the beholder). This package leans heavily on the PrettyTables.jl package to accomplish this by handing off everything that goes through the show method to pretty_array. pretty_array in turn repeatedly calls PrettyTables.pretty_print along slices of arrays.","category":"page"},{"location":"pretty_printing/#","page":"Pretty Printing","title":"Pretty Printing","text":"warning: Warning\nLike much of this package, pretty printing is continually being developed at this time. Unlike most of this package, improvements in visualizing arrays is subjective and more likely to result changes that are noticeable to users. Therefore, users are encouraged to utilize related functionality and provide feedback but should not yet rely on these methods for tests in other packages.","category":"page"},{"location":"styles/#AxisIndices-Styles-1","page":"AxisIndices Styles","title":"AxisIndices Styles","text":"","category":"section"},{"location":"styles/#","page":"AxisIndices Styles","title":"AxisIndices Styles","text":"TODO","category":"page"},{"location":"styles/#Documentation-1","page":"AxisIndices Styles","title":"Documentation","text":"","category":"section"},{"location":"styles/#","page":"AxisIndices Styles","title":"AxisIndices Styles","text":"Modules = [AxisIndices.Styles]","category":"page"},{"location":"styles/#AxisIndices.Styles.AxisIndicesStyle","page":"AxisIndices Styles","title":"AxisIndices.Styles.AxisIndicesStyle","text":"AxisIndicesStyle\n\nSupertype for traits that control the behavior of AxisIndices.to_index and AxisIndices.to_key.\n\n\n\n\n\n","category":"type"},{"location":"styles/#AxisIndices.Styles.BoolElement","page":"AxisIndices Styles","title":"AxisIndices.Styles.BoolElement","text":"BoolElement\n\nA subtype of AxisIndicesStyle for mapping an argument that refers to a single Bool to a single index.\n\n\n\n\n\n","category":"type"},{"location":"styles/#AxisIndices.Styles.BoolsCollection","page":"AxisIndices Styles","title":"AxisIndices.Styles.BoolsCollection","text":"BoolsCollection\n\nA subtype of AxisIndicesStyle for mapping a collection of Bools to a collection of indices.\n\n\n\n\n\n","category":"type"},{"location":"styles/#AxisIndices.Styles.CartesianElement","page":"AxisIndices Styles","title":"AxisIndices.Styles.CartesianElement","text":"CartesianElement\n\nA subtype of AxisIndicesStyle for mapping an argument that refers to a CartesianIndex to a single index.\n\n\n\n\n\n","category":"type"},{"location":"styles/#AxisIndices.Styles.IndexElement","page":"AxisIndices Styles","title":"AxisIndices.Styles.IndexElement","text":"IndexElement\n\nA subtype of AxisIndicesStyle for propagating an argument to a single index.\n\n\n\n\n\n","category":"type"},{"location":"styles/#AxisIndices.Styles.IndexEquals","page":"AxisIndices Styles","title":"AxisIndices.Styles.IndexEquals","text":"IndexEquals\n\nA subtype of AxisIndicesStyle for mapping a single index in a isequal(index) argument to a single index.\n\n\n\n\n\n","category":"type"},{"location":"styles/#AxisIndices.Styles.Indices","page":"AxisIndices Styles","title":"AxisIndices.Styles.Indices","text":"Indices(arg)\n\nForces arg to refer to indices when indexing.\n\n\n\n\n\n","category":"type"},{"location":"styles/#AxisIndices.Styles.IndicesCollection","page":"AxisIndices Styles","title":"AxisIndices.Styles.IndicesCollection","text":"IndicesCollection\n\nA subtype of AxisIndicesStyle for propagating an argument to a collection of indices.\n\n\n\n\n\n","category":"type"},{"location":"styles/#AxisIndices.Styles.IndicesFix2","page":"AxisIndices Styles","title":"AxisIndices.Styles.IndicesFix2","text":"IndicesFix2\n\nA subtype of AxisIndicesStyle for mapping all indices from fixed argument (e.g., >(indices)) to the corresponding collection of indices.\n\n\n\n\n\n","category":"type"},{"location":"styles/#AxisIndices.Styles.IndicesIn","page":"AxisIndices Styles","title":"AxisIndices.Styles.IndicesIn","text":"IndicesIn\n\nA subtype of AxisIndicesStyle for mapping all keys given in(keys) to a collection of indices.\n\n\n\n\n\n","category":"type"},{"location":"styles/#AxisIndices.Styles.IntervalCollection","page":"AxisIndices Styles","title":"AxisIndices.Styles.IntervalCollection","text":"IntervalCollection\n\nA subtype of AxisIndicesStyle for mapping an interval argument (start..stop) from keys within said interval to a collection of indices.\n\n\n\n\n\n","category":"type"},{"location":"styles/#AxisIndices.Styles.KeyElement","page":"AxisIndices Styles","title":"AxisIndices.Styles.KeyElement","text":"KeyElement\n\nA subtype of AxisIndicesStyle for mapping an argument that refers to a single key to a single index.\n\n\n\n\n\n","category":"type"},{"location":"styles/#AxisIndices.Styles.KeyEquals","page":"AxisIndices Styles","title":"AxisIndices.Styles.KeyEquals","text":"KeyEquals\n\nA subtype of AxisIndicesStyle for mapping a single key in a isequal(key) argument to a single index.\n\n\n\n\n\n","category":"type"},{"location":"styles/#AxisIndices.Styles.KeyedStyle","page":"AxisIndices Styles","title":"AxisIndices.Styles.KeyedStyle","text":"KeyedStyle{S}\n\nA subtype of AxisIndicesStyle indicating that the axis is a always defaults to key based indexing.\n\n\n\n\n\n","category":"type"},{"location":"styles/#AxisIndices.Styles.Keys","page":"AxisIndices Styles","title":"AxisIndices.Styles.Keys","text":"Keys(arg)\n\nForces arg to refer to keys when indexing.\n\n\n\n\n\n","category":"type"},{"location":"styles/#AxisIndices.Styles.KeysCollection","page":"AxisIndices Styles","title":"AxisIndices.Styles.KeysCollection","text":"KeysCollection\n\nA subtype of AxisIndicesStyle for mapping a collection of keys a collection of indices.\n\n\n\n\n\n","category":"type"},{"location":"styles/#AxisIndices.Styles.KeysFix2","page":"AxisIndices Styles","title":"AxisIndices.Styles.KeysFix2","text":"KeysFix2\n\nA subtype of AxisIndicesStyle for mapping all keys from fixed argument (e.g., >(key)) to the corresponding collection of indices.\n\n\n\n\n\n","category":"type"},{"location":"styles/#AxisIndices.Styles.KeysIn","page":"AxisIndices Styles","title":"AxisIndices.Styles.KeysIn","text":"KeysIn\n\nA subtype of AxisIndicesStyle for mapping all keys given in(keys) to a collection of indices.\n\n\n\n\n\n","category":"type"},{"location":"styles/#AxisIndices.Styles.SliceCollection","page":"AxisIndices Styles","title":"AxisIndices.Styles.SliceCollection","text":"SliceCollection\n\nA subtype of AxisIndicesStyle indicating that the entire axis should be propagated.\n\n\n\n\n\n","category":"type"},{"location":"styles/#AxisIndices.Styles.is_collection-Tuple{Any}","page":"AxisIndices Styles","title":"AxisIndices.Styles.is_collection","text":"is_collection(x) -> Bool\n\nWhether x is an AxisIndicesStyle, returns true if it's used to index a collection of indices.\n\n\n\n\n\n","category":"method"},{"location":"styles/#AxisIndices.Styles.is_element-Union{Tuple{T}, Tuple{T}} where T","page":"AxisIndices Styles","title":"AxisIndices.Styles.is_element","text":"is_element(x) -> Bool\n\nWhether x is an AxisIndicesStyle, returns true if it's used to index a single element.\n\n\n\n\n\n","category":"method"},{"location":"styles/#AxisIndices.Styles.is_index-Union{Tuple{T}, Tuple{T}} where T","page":"AxisIndices Styles","title":"AxisIndices.Styles.is_index","text":"is_index(x) -> Bool\n\nWhether x is an AxisIndicesStyle, returns true if it's used to search the indices space.\n\n\n\n\n\n","category":"method"},{"location":"styles/#AxisIndices.Styles.is_key-Tuple{Any}","page":"AxisIndices Styles","title":"AxisIndices.Styles.is_key","text":"is_key(x) -> Bool\n\nWhether x is an AxisIndicesStyle, returns true if it's used to search the keys space.\n\n\n\n\n\n","category":"method"},{"location":"styles/#AxisIndices.Styles.to_index-Tuple{Any,Any}","page":"AxisIndices Styles","title":"AxisIndices.Styles.to_index","text":"to_index(axis, arg) -> to_index(AxisIndicesStyle(axis, arg), axis, arg)\n\nUnique implementation of to_index for the AxisIndices package that specializes based on each axis and indexing argument (as opposed to the array and indexing argument).\n\n\n\n\n\n","category":"method"},{"location":"styles/#AxisIndices.Styles.to_keys-Tuple{Any,Any,Any}","page":"AxisIndices Styles","title":"AxisIndices.Styles.to_keys","text":"to_keys([::AxisIndicesStyle,] axis, arg, index)\n\nThis method is the reverse of AxisIndices.to_index. arg refers to an argument originally passed to AxisIndices.to_index and index refers to the index produced by that same call to AxisIndices.to_index.\n\nThis method assumes to all arguments have passed through AxisIndices.to_index and have been checked to be in bounds. Therefore, this is unsafe and intended only for internal use.\n\n\n\n\n\n","category":"method"},{"location":"compatibility/#Compatibility-1","page":"Compatibility","title":"Compatibility","text":"","category":"section"},{"location":"compatibility/#","page":"Compatibility","title":"Compatibility","text":"The following packages outside of the Base module have some form of support. In addition to creating awareness of existing functionality, the following provides users with a better idea of how exactly these packages are supported. This means features existing outside of those described here are not within the domain of intended coverage and users should seek support linked resources.","category":"page"},{"location":"compatibility/#MappedArrays-1","page":"Compatibility","title":"MappedArrays","text":"","category":"section"},{"location":"compatibility/#","page":"Compatibility","title":"Compatibility","text":"MappedArrays.jl allows \"lazy\" in-place elementwise transformations of arrays. Support is provided by overloading the mappedarray method, which AxisIndices does not export (i.e. users must using mappedArrays to get access to it). In order to avoid method ambiguities multi-mapping of mixed AbstractArray and AbstractAxisIndices cannot be provided. In other words, the current version can only support multi-mapping multiple AbstractAxisIndices.","category":"page"},{"location":"compatibility/#NamedDims-1","page":"Compatibility","title":"NamedDims","text":"","category":"section"},{"location":"compatibility/#","page":"Compatibility","title":"Compatibility","text":"Indexing via named dimensions is supported via the NamedDims.jl package. NamedAxisArray assists in constructing arrays that have both named dimensions and a subtype of AbstractAxis along each axis.","category":"page"},{"location":"acknowledgments/#Acknowledgments-1","page":"Acknowledgments","title":"Acknowledgments","text":"","category":"section"},{"location":"acknowledgments/#","page":"Acknowledgments","title":"Acknowledgments","text":"This package is the result of many people providing input to make it successful. Hopefully, it will continue to be a product of such collaborations. The following is an incomplete list of individuals who have helped me in some way get this package started. It's mainly a list of people who have tolerated my incessant queries into many minor details that led to this package.","category":"page"},{"location":"acknowledgments/#","page":"Acknowledgments","title":"Acknowledgments","text":"Eric Davies\nLyndon White\nMichael Abbott\nRafael Schouten\nTim Holy","category":"page"},{"location":"acknowledgments/#","page":"Acknowledgments","title":"Acknowledgments","text":"Also, anyone that has contributed to StaticArrays.jl and NamedDims.jl has probably helped.","category":"page"},{"location":"quick_start/#Quick-Start-1","page":"Quick Start","title":"Quick Start","text":"","category":"section"},{"location":"quick_start/#","page":"Quick Start","title":"Quick Start","text":"Custom indexing only requires specifying a tuple of keys[1] for the indices of each dimension.","category":"page"},{"location":"quick_start/#","page":"Quick Start","title":"Quick Start","text":"julia> using AxisIndices\n\njulia> A = AxisArray(reshape(1:9, 3,3),\n               (2:4,        # first dimension has keys 2:4\n                3.0:5.0));  # second dimension has keys 3.0:5.0","category":"page"},{"location":"quick_start/#","page":"Quick Start","title":"Quick Start","text":"Most code should work just the same for an AxisArray...","category":"page"},{"location":"quick_start/#","page":"Quick Start","title":"Quick Start","text":"julia> A[1, 1]\n1\n\njulia> A[1:2, 1:2] == parent(A)[1:2, 1:2]\ntrue\n\njulia> sum(A) == sum(parent(A))\ntrue","category":"page"},{"location":"quick_start/#","page":"Quick Start","title":"Quick Start","text":"But now the indices of each dimension have keys that we can filter through.","category":"page"},{"location":"quick_start/#","page":"Quick Start","title":"Quick Start","text":"julia> A[==(2), ==(3.0)] == parent(A)[findfirst(==(2), 2:4), findfirst(==(3.0), 3.0:5.0)] == 1\ntrue\n\njulia> A[<(4), <(5.0)] == parent(A)[findall(<(4), 2:4), findall(<(5.0), 3.0:5.0)] == [1 4; 2 5]\ntrue","category":"page"},{"location":"quick_start/#","page":"Quick Start","title":"Quick Start","text":"Any value that is not a CartesianIndex or subtype of Real is considered a dedicated key type. In other words, it could never be used for default indexing and will be treated the same as the == filtering syntax above.","category":"page"},{"location":"quick_start/#","page":"Quick Start","title":"Quick Start","text":"julia> AxisArray([1, 2, 3], ([\"one\", \"two\", \"three\"],))[\"one\"]\n1","category":"page"},{"location":"quick_start/#","page":"Quick Start","title":"Quick Start","text":"Note that the first call only returns a single element, where the last call returns an array. This is because all keys must be unique so there can only be one value that returns true if filtering by ==, which is the same as indexing by 1 (e.g., only one index can equal 1). The last call uses operators that can produce any number of true values and the resulting output is an array. This is the same as indexing an array by any vector (i.e., returns another array).","category":"page"},{"location":"quick_start/#","page":"Quick Start","title":"Quick Start","text":"[1]: Terminology here is important here. Keys, indices, and axes each have a specific meaning. Throughout the documentation the following functional definitions apply:axis: maps a set of keys to a set of indices.\nindices: a set of integers (e.g., <:Integer) that locate the in memory locations of elements.\nkeys: maps a set of any type to a set of indices\nindexing: anytime one calls getindex or uses square brackets to navigate the elements of a collectionAlso note the use of argument (abbreviated arg in code) and arguments (abbreviated args in code). These terms specifically refer to what users pass to an indexing method. Therefore, an argument may be a key (:a), index (1), or something else that maps to one of the two (==(1)).","category":"page"},{"location":"coeftable/#Making-a-CoefTable-1","page":"CoefTable","title":"Making a CoefTable","text":"","category":"section"},{"location":"coeftable/#","page":"CoefTable","title":"CoefTable","text":"This example will guide you through manipulating the pretty printing framework. We'll motivate this by trying to recreate the coefficient table from StatsBase.jl.","category":"page"},{"location":"coeftable/#Creating-the-Table-1","page":"CoefTable","title":"Creating the Table","text":"","category":"section"},{"location":"coeftable/#","page":"CoefTable","title":"CoefTable","text":"julia> using AxisIndices, DataFrames, GLM, Distributions\n\njulia> function coefarray(mm::StatsModels.TableRegressionModel; level::Real=0.95)\n           cc = coef(mm)\n           se = stderror(mm)\n           tt = cc ./ se\n           p = ccdf.(Ref(FDist(1, dof_residual(mm))), abs2.(tt))\n           ci = se*quantile(TDist(dof_residual(mm)), (1-level)/2)\n           levstr = isinteger(level*100) ? string(Integer(level*100)) : string(level*100)\n           ct = AxisArray(\n               hcat(cc,se,tt,p,cc+ci,cc-ci),\n               (coefnames(mm),\n               [\"Estimate\",\"Std. Error\",\"t value\",\"Pr(>|t|)\",\"Lower $levstr%\",\"Upper $levstr%\"])\n           )\n       end\ncoefarray (generic function with 1 method)\n\njulia> ols = lm(@formula(Y ~ X), DataFrame(X=[1,2,3], Y=[2,4,7]));\n\njulia> cfa = coefarray(ols)\n2-dimensional AxisArray{Float64,2,Array{Float64,2}...}\n                   Estimate   Std. Error       t value     Pr(>|t|)     Lower 95%    Upper 95%\n  (Intercept)   -0.66666667   0.62360956   -1.06904497   0.47876359   -8.59037747   7.25704413\n            X           2.5   0.28867513    8.66025404    0.0731864   -1.16796536   6.16796536\n","category":"page"},{"location":"coeftable/#","page":"CoefTable","title":"CoefTable","text":"But we can do better. Let's use the underlying pretty_array method to get this into shape.","category":"page"},{"location":"coeftable/#","page":"CoefTable","title":"CoefTable","text":"julia> using PrettyTables\n\nctf = array_text_format = TextFormat(\n    up_right_corner = ' ',\n    up_left_corner = ' ',\n    bottom_left_corner=' ',\n    bottom_right_corner= ' ',\n    up_intersection= '─',\n    left_intersection= ' ',\n    right_intersection= ' ',\n    middle_intersection= '─',\n    bottom_intersection= '─',\n    column= ' ',\n    hlines=[ :begin, :header, :end]\n    #    row= ' ',\n)\n\njulia> pretty_array(cfa; tf=ctf)\n ──────────────────────────────────────────────────────────────────────────────────────────────\n                   Estimate   Std. Error       t value     Pr(>|t|)     Lower 95%    Upper 95%\n ──────────────────────────────────────────────────────────────────────────────────────────────\n  (Intercept)   -0.66666667   0.62360956   -1.06904497   0.47876359   -8.59037747   7.25704413\n            X           2.5   0.28867513    8.66025404    0.0731864   -1.16796536   6.16796536\n ──────────────────────────────────────────────────────────────────────────────────────────────","category":"page"},{"location":"coeftable/#","page":"CoefTable","title":"CoefTable","text":"This looks pretty good but the nicest part is that we can now treat this as a typical matrix.","category":"page"},{"location":"coeftable/#","page":"CoefTable","title":"CoefTable","text":"julia> cfa[1,\"Estimate\"]\n-0.6666666666666738\n\njulia> cfa[1:2,1:2]\n2-dimensional AxisArray{Float64,2,Array{Float64,2}...}\n                Estimate   Std. Error\n  (Intercept)     -0.667        0.624\n            X        2.5        0.289","category":"page"},{"location":"coeftable/#","page":"CoefTable","title":"CoefTable","text":"Because keys and indices are bound together we don't lose track of what each element is when we index.","category":"page"},{"location":"coeftable/#","page":"CoefTable","title":"CoefTable","text":"julia> cfa[1,:]\n1-dimensional AxisArray{Float64,1,Array{Float64,1}...}\n\n    Estimate   -0.667\n  Std. Error    0.624\n     t value   -1.069\n    Pr(>|t|)    0.479\n   Lower 95%    -8.59\n   Upper 95%    7.257\n","category":"page"},{"location":"coeftable/#Automating-the-table-1","page":"CoefTable","title":"Automating the table","text":"","category":"section"},{"location":"coeftable/#","page":"CoefTable","title":"CoefTable","text":"We can actually do even better if this format should always be the default by making a new axis type and redefining the coefarray method. The following will result in any array with a CoefHeader printing exactly how we'd like it to by default. Note that this is a quick and dirty way of getting a new axis. See TimeAxis Guide for a better guide on making an axis.","category":"page"},{"location":"coeftable/#","page":"CoefTable","title":"CoefTable","text":"julia> struct CoefHeader <: AbstractAxis{String,Int,Vector{String},Base.OneTo{Int}} end\n\njulia> Base.keys(::CoefHeader) = [\"Estimate\",\"Std. Error\",\"t value\",\"Pr(>|t|)\",\"Lower 95%\",\"Upper 95%\"]\n\njulia> Base.values(::CoefHeader) = Base.OneTo(5)\n\njulia> AxisIndices.text_format(axis, ::CoefHeader) = ctf\n\njulia> AxisIndices.unsafe_reconstruct(::CoefHeader, args...) = CoefHeader()\n\njulia> function coefarray(mm::StatsModels.TableRegressionModel; level::Real=0.95)\n           cc = coef(mm)\n           se = stderror(mm)\n           tt = cc ./ se\n           p = ccdf.(Ref(FDist(1, dof_residual(mm))), abs2.(tt))\n           ci = se*quantile(TDist(dof_residual(mm)), (1-level)/2)\n           levstr = isinteger(level*100) ? string(Integer(level*100)) : string(level*100)\n           ct = AxisArray(\n               hcat(cc,se,tt,p,cc+ci,cc-ci),\n               (coefnames(mm),\n               CoefHeader())\n           )\n       end;\n\njulia> cfa = coefarray(ols)\n2-dimensional AxisArray{Float64,2,Array{Float64,2}...}\n ──────────────────────────────────────────────────────────────────────────────────────────────\n                   Estimate   Std. Error       t value     Pr(>|t|)     Lower 95%    Upper 95%\n ──────────────────────────────────────────────────────────────────────────────────────────────\n  (Intercept)   -0.66666667   0.62360956   -1.06904497   0.47876359   -8.59037747   7.25704413\n            X           2.5   0.28867513    8.66025404    0.0731864   -1.16796536   6.16796536\n ──────────────────────────────────────────────────────────────────────────────────────────────\n","category":"page"},{"location":"arrays/#Array-Interface-1","page":"Array Interface","title":"Array Interface","text":"","category":"section"},{"location":"arrays/#Construction-1","page":"Array Interface","title":"Construction","text":"","category":"section"},{"location":"arrays/#","page":"Array Interface","title":"Array Interface","text":"Take a standard array and attach custom keys along the indices of each dimension.","category":"page"},{"location":"arrays/#","page":"Array Interface","title":"Array Interface","text":"julia> using AxisIndices\n\njulia> A_base = [1 2; 3 4];\n\njulia> A_axis = AxisArray(A_base, [\"a\", \"b\"], [:one, :two])\n2×2 AxisArray{Int64,2}\n • dim_1 - [\"a\", \"b\"]\n • dim_2 - [:one, :two]\n      one   two  \n  a     1     2  \n  b     3     4  \n","category":"page"},{"location":"arrays/#","page":"Array Interface","title":"Array Interface","text":"Note that the keys provided are converted to a subtype of AbstractAxis.","category":"page"},{"location":"arrays/#","page":"Array Interface","title":"Array Interface","text":"julia> axes(A_axis, 1)\nAxis([\"a\", \"b\"] => Base.OneTo(2))\n","category":"page"},{"location":"arrays/#","page":"Array Interface","title":"Array Interface","text":"An AxisArray may also be initiliazed using similar syntax as Array{T}(undef, dims).","category":"page"},{"location":"arrays/#","page":"Array Interface","title":"Array Interface","text":"julia> A_axis = AxisArray{Int}(undef, [\"a\", \"b\"], [:one, :two]);\n\njulia> A_axis[:,:] = A_base;\n\njulia> A_axis\n2×2 AxisArray{Int64,2}\n • dim_1 - [\"a\", \"b\"]\n • dim_2 - [:one, :two]\n      one   two  \n  a     1     2  \n  b     3     4  \n","category":"page"},{"location":"arrays/#","page":"Array Interface","title":"Array Interface","text":"Names can be attached to each dimension/axis using NamedAxisArray.","category":"page"},{"location":"arrays/#","page":"Array Interface","title":"Array Interface","text":"julia> A_named_axis = NamedAxisArray{(:xdim, :ydim)}(A_axis)\n2×2 NamedAxisArray{Int64,2}\n • xdim - [\"a\", \"b\"]\n • ydim - [:one, :two]\n      one   two  \n  a     1     2  \n  b     3     4  \n\njulia> A_named_axis == NamedAxisArray{(:xdim, :ydim)}(A_base, [\"a\", \"b\"], [:one, :two])\ntrue\n","category":"page"},{"location":"arrays/#","page":"Array Interface","title":"Array Interface","text":"We can also attach metadata to an an array.","category":"page"},{"location":"arrays/#","page":"Array Interface","title":"Array Interface","text":"julia> A_meta_axis = MetaAxisArray(A_base, ([\"a\", \"b\"], [:one, :two]), metadata = \"a life well Steved\")\n2×2 MetaAxisArray{Int64,2}\n • dim_1 - [\"a\", \"b\"]\n • dim_2 - [:one, :two]\nmetadata: String\n • a life well Steved\n      one   two\n  a     1     2\n  b     3     4\n\n\njulia> A_meta_axis == MetaAxisArray(A_axis, metadata = \"a life well Steved\")\ntrue\n\njulia> NamedMetaAxisArray{(:xdim, :ydim)}(A_base, [\"a\", \"b\"], [:one, :two], metadata = \"a life well Steved\")\n2×2 MetaAxisArray{(:xdim, :ydim),Int64}\n • xdim - [\"a\", \"b\"]\n • ydim - [:one, :two]\nmetadata: String\n • a life well Steved\n      one   two\n  a     1     2\n  b     3     4\n","category":"page"},{"location":"arrays/#Indexing-1","page":"Array Interface","title":"Indexing","text":"","category":"section"},{"location":"arrays/#","page":"Array Interface","title":"Array Interface","text":"Behavior of an AxisArray is similar to that of the common Array type.","category":"page"},{"location":"arrays/#","page":"Array Interface","title":"Array Interface","text":"julia> using AxisIndices\n\njulia> import Unitful: s\n\njulia> A_base = reshape(1:9, 3,3);\n\njulia> A_axis = AxisArray(A_base, ((.1:.1:.3)s, [\"a\", \"b\", \"c\"]))\n3×3 AxisArray{Int64,2}\n • dim_1 - 0.1 s:0.1 s:0.3 s\n • dim_2 - [\"a\", \"b\", \"c\"]\n          a   b   c\n  0.1 s   1   4   7\n  0.2 s   2   5   8\n  0.3 s   3   6   9\n\njulia> A_axis[1,1] == A_base[1,1]\ntrue\n\njulia> A_axis[1] == A_base[1] # linear indexing works too\ntrue\n\njulia> A_axis[1,:]\n3-element AxisArray{Int64,1}\n • dim_1 - [\"a\", \"b\", \"c\"]\n\n  a   1\n  b   4\n  c   7\n\n\njulia> A_axis[1:2, 1:2]\n2×2 AxisArray{Int64,2}\n • dim_1 - 0.1 s:0.1 s:0.2 s\n • dim_2 - [\"a\", \"b\"]\n          a   b\n  0.1 s   1   4\n  0.2 s   2   5\n\n\njulia> A_axis[1:3]\n3-element AxisArray{Int64,1}\n • dim_1 - 0.1 s:0.1 s:0.3 s\n\n  0.1 s   1\n  0.2 s   2\n  0.3 s   3\n","category":"page"},{"location":"arrays/#","page":"Array Interface","title":"Array Interface","text":"In addition to standard indexing, an AxisArray can be indexed by its keys...","category":"page"},{"location":"arrays/#","page":"Array Interface","title":"Array Interface","text":"julia> A_axis[.1s, \"a\"]\n1\n\njulia> A_axis[0.1s..0.3s, [\"a\", \"b\"]]\n3×2 AxisArray{Int64,2}\n • dim_1 - 0.1 s:0.1 s:0.3 s\n • dim_2 - [\"a\", \"b\"]\n          a   b\n  0.1 s   1   4\n  0.2 s   2   5\n  0.3 s   3   6\n","category":"page"},{"location":"arrays/#","page":"Array Interface","title":"Array Interface","text":"...or functions that filter the keys.","category":"page"},{"location":"arrays/#","page":"Array Interface","title":"Array Interface","text":"julia> A_axis[!=(.2s), in([\"a\", \"c\"])]\n2×2 AxisArray{Int64,2}\n • dim_1 - Unitful.Quantity{Float64,𝐓,Unitful.FreeUnits{(s,),𝐓,nothing}}[0.1 s, 0.3 s]\n • dim_2 - [\"a\", \"c\"]\n          a   c\n  0.1 s   1   7\n  0.3 s   3   9\n","category":"page"},{"location":"arrays/#Combining-Different-Axes-TODO-1","page":"Array Interface","title":"Combining Different Axes TODO","text":"","category":"section"},{"location":"arrays/#Reference-1","page":"Array Interface","title":"Reference","text":"","category":"section"},{"location":"arrays/#","page":"Array Interface","title":"Array Interface","text":"Pages   = [\"arrays.md\"]\nModules = [AxisIndices.Arrays]\nOrder   = [:function, :type]","category":"page"},{"location":"arrays/#","page":"Array Interface","title":"Array Interface","text":"Modules = [AxisIndices.Arrays]","category":"page"},{"location":"arrays/#AxisIndices.Arrays.AbstractAxisArray","page":"Array Interface","title":"AxisIndices.Arrays.AbstractAxisArray","text":"AbstractAxisArray\n\nAbstractAxisArray is a subtype of AbstractArray that offers integration with the AbstractAxis interface. The only methods that absolutely needs to be defined for a subtype of AbstractAxisArray are axes, parent, similar_type, and similar. Most users should find the provided AxisArray subtype is sufficient for the majority of use cases. Although custom behavior may be accomplished through a new subtype of AbstractAxisArray, customizing the behavior of many methods described herein can be accomplished through a unique subtype of AbstractAxis.\n\nThis implementation is meant to be basic, well documented, and have sane defaults that can be overridden as necessary. In other words, default methods for manipulating arrays that return an AxisArray should not cause unexpected downstream behavior for users; and developers should be able to freely customize the behavior of AbstractAxisArray subtypes with minimal effort. \n\n\n\n\n\n","category":"type"},{"location":"arrays/#AxisIndices.Arrays.AxisArray","page":"Array Interface","title":"AxisIndices.Arrays.AxisArray","text":"AxisArray{T,N,P,AI}\n\nAn array struct that wraps any parent array and assigns it an AbstractAxis for each dimension. The first argument is the parent array and the second argument is a tuple of subtypes to AbstractAxis or keys that will be converted to subtypes of AbstractAxis with the provided keys.\n\n\n\n\n\n","category":"type"},{"location":"arrays/#AxisIndices.Arrays.AxisArray-Tuple{AbstractArray,Vararg{Any,N} where N}","page":"Array Interface","title":"AxisIndices.Arrays.AxisArray","text":"AxisArray(parent::AbstractArray, args...) -> AxisArray(parent, tuple(args))\n\nPasses args to a tuple for constructing an AxisArray.\n\nExamples\n\njulia> using AxisIndices\n\njulia> A = AxisArray(reshape(1:9, 3,3), 2:4, 3.0:5.0);\n\njulia> A[1, 1]\n1\n\njulia> A[==(2), ==(3.0)]\n1\n\njulia> A[1:2, 1:2] == [1 4; 2 5]\ntrue\n\njulia> A[<(4), <(5.0)] == [1 4; 2 5]\ntrue\n\n\n\n\n\n","category":"method"},{"location":"arrays/#AxisIndices.Arrays.AxisArray-Union{Tuple{N2}, Tuple{N}, Tuple{T}, Tuple{AbstractArray{T,N},Tuple{Vararg{Any,N2}}}, Tuple{AbstractArray{T,N},Tuple{Vararg{Any,N2}},Tuple}, Tuple{AbstractArray{T,N},Tuple{Vararg{Any,N2}},Tuple,Bool}} where N2 where N where T","page":"Array Interface","title":"AxisIndices.Arrays.AxisArray","text":"AxisArray(parent::AbstractArray, keys::Tuple[, values=axes(parent), check_length=true])\n\nGiven an the some array parent and a tuple of vectors keys corresponding to each dimension of parent constructs an AxisArray. Each element of keys is paired with an element of values to compose a subtype of AbstractAxis. values map the keys to the indices of parent.\n\nExamples\n\njulia> using AxisIndices\n\njulia> AxisArray(ones(2,2), ([\"a\", \"b\"], [\"one\", \"two\"]))\n2×2 AxisArray{Float64,2}\n • dim_1 - [\"a\", \"b\"]\n • dim_2 - [\"one\", \"two\"]\n      one   two\n  a   1.0   1.0\n  b   1.0   1.0\n\n\n\n\n\n\n","category":"method"},{"location":"arrays/#AxisIndices.Arrays.AxisArray-Union{Tuple{N}, Tuple{T2}, Tuple{T}, Tuple{AbstractArray{T2,N},Tuple}, Tuple{AbstractArray{T2,N},Tuple,Bool}} where N where T2 where T","page":"Array Interface","title":"AxisIndices.Arrays.AxisArray","text":"AxisArray{T,N}(undef, dims::NTuple{N,Integer})\nAxisArray{T,N}(undef, keys::NTuple{N,AbstractVector})\n\nConstruct an uninitialized N-dimensional array containing elements of type T were the size of each dimension is equal to the corresponding integer in dims.\n\nConstruct an uninitialized N-dimensional array containing elements of type T were the size of each dimension is determined by the length of the corresponding collection in `keys.\n\nExamples\n\n```jldoctest julia> using AxisIndices\n\njulia> size(AxisArray{Int,2}(undef, (2,2))) (2, 2)\n\njulia> size(AxisArray{Int,2}(undef, ([\"a\", \"b\"], [:one, :two]))) (2, 2)\n\n\n\n\n\n","category":"method"},{"location":"arrays/#AxisIndices.Arrays.AxisArray-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T,N},Tuple{Vararg{AbstractAxis,N}}}, Tuple{AbstractArray{T,N},Tuple{Vararg{AbstractAxis,N}},Bool}} where N where T","page":"Array Interface","title":"AxisIndices.Arrays.AxisArray","text":"AxisArray(parent::AbstractArray, axes::Tuple{Vararg{AbstractAxis}}[, check_length=true])\n\nConstruct an AxisArray using parent and explicit subtypes of AbstractAxis. If check_length is true then each dimension of parent's length is checked to match the length of the corresponding axis (e.g., size(parent 1) == length(axes[1]).\n\nExamples\n\njulia> using AxisIndices\n\njulia> AxisArray(ones(2,2), (SimpleAxis(2), SimpleAxis(2)))\n2×2 AxisArray{Float64,2}\n • dim_1 - 1:2\n • dim_2 - 1:2\n        1     2\n  1   1.0   1.0\n  2   1.0   1.0\n\n\n\n\n\n\n","category":"method"},{"location":"arrays/#AxisIndices.Arrays.AxisArray-Union{Tuple{T}, Tuple{AbstractArray,Tuple}, Tuple{AbstractArray,Tuple,Bool}} where T","page":"Array Interface","title":"AxisIndices.Arrays.AxisArray","text":"AxisArray{T}(undef, keys::NTuple{N,AbstractVector})\n\nConstruct an uninitialized N-dimensional array containing elements of type T were the size of each dimension is determined by the length of the corresponding collection in `keys.\n\nExamples\n\njulia> using AxisIndices\n\njulia> size(AxisArray{Int}(undef, ([\"a\", \"b\"], [:one, :two])))\n(2, 2)\n\n\n\n\n\n","category":"method"},{"location":"arrays/#AxisIndices.Arrays.AxisVector","page":"Array Interface","title":"AxisIndices.Arrays.AxisVector","text":"AxisVector\n\nA vector whose indices have keys.\n\nExamples\n\njulia> using AxisIndices\n\njulia> AxisVector([1, 2], [:a, :b])\n2-element AxisArray{Int64,1}\n • dim_1 - [:a, :b]\n\n  a   1\n  b   2\n\n\n\n\n\n\n","category":"type"},{"location":"arrays/#AxisIndices.Arrays.MetaAxisArray","page":"Array Interface","title":"AxisIndices.Arrays.MetaAxisArray","text":"MetaAxisArray()\n\nAn AxisArray with metadata.\n\nExamples\n\njulia> using AxisIndices\n\njulia> MetaAxisArray([1 2; 3 4], ([\"a\", \"b\"], [:one, :two]), metadata = \"some metadata\")\n2×2 MetaAxisArray{Int64,2}\n • dim_1 - [\"a\", \"b\"]\n • dim_2 - [:one, :two]\nmetadata: String\n • some metadata\n      one   two\n  a     1     2\n  b     3     4\n\n\n\n\n\n\n\n","category":"type"},{"location":"arrays/#AxisIndices.Arrays.NamedAxisArray","page":"Array Interface","title":"AxisIndices.Arrays.NamedAxisArray","text":"NamedAxisArray(parent::AbstractArray; kwargs...) = NamedAxisArray(parent, kwargs)\nNamedAxisArray(parent::AbstractArray, axes::NamedTuple{L,AbstractAxes})\n\nType alias for NamedDimsArray whose parent array is a subtype of AxisArray. An abbreviated alias and constructor for NamedAxisArray. If key word arguments are provided then each key word becomes the name of a dimension and its assigned value is sent to the corresponding axis when constructing the underlying AxisArray.\n\nExamples\n\njulia> using AxisIndices\n\njulia> A = NamedAxisArray{(:x, :y, :z)}(reshape(1:24, 2, 3, 4), [\"a\", \"b\"], [\"one\", \"two\", \"three\"], 2:5)\n2×3×4 NamedAxisArray{Int64,3}\n • x - [\"a\", \"b\"]\n • y - [\"one\", \"two\", \"three\"]\n • z - 2:5\n[x, y, z[2]] =\n      one   two   three\n  a     1     3       5\n  b     2     4       6\n\n[x, y, z[3]] =\n      one   two   three\n  a     7     9      11\n  b     8    10      12\n\n[x, y, z[4]] =\n      one   two   three\n  a    13    15      17\n  b    14    16      18\n\n[x, y, z[5]] =\n      one   two   three\n  a    19    21      23\n  b    20    22      24\n\njulia> dimnames(A)\n(:x, :y, :z)\n\njulia> axes_keys(A)\n([\"a\", \"b\"], [\"one\", \"two\", \"three\"], 2:5)\n\njulia> B = A[\"a\", :, :]\n3×4 NamedAxisArray{Int64,2}\n • y - [\"one\", \"two\", \"three\"]\n • z - 2:5\n          2    3    4    5\n    one   1    7   13   19\n    two   3    9   15   21\n  three   5   11   17   23\n\njulia> C = B[\"one\",:]\n4-element NamedAxisArray{Int64,1}\n • z - 2:5\n\n  2    1\n  3    7\n  4   13\n  5   19\n\n\n\n\n\n\n","category":"type"},{"location":"arrays/#AxisIndices.Arrays.NamedMetaAxisArray","page":"Array Interface","title":"AxisIndices.Arrays.NamedMetaAxisArray","text":"NamedMetaAxisArray\n\nAn AxisArray with metadata and named dimensions.\n\n\n\n\n\n","category":"type"},{"location":"arrays/#Base.deleteat!-Union{Tuple{Ax}, Tuple{P}, Tuple{T}, Tuple{AbstractAxisArray{T,1,P,Tuple{Ax}},Any}} where Ax where P where T","page":"Array Interface","title":"Base.deleteat!","text":"deleteat!(a::AbstractAxisVector, arg)\n\nRemove the items corresponding to A[arg], and return the modified a. Subsequent items are shifted to fill the resulting gap. If the axis of a is an AbstractSimpleAxis then it is shortened to match the length of a. If the \n\nExamples\n\njulia> using AxisIndices\n\njulia> x = AxisArray([1, 2, 3, 4]);\n\njulia> axes_keys(deleteat!(x, 3))\n(OneToMRange(3),)\n\njulia> x = AxisArray([1, 2, 3, 4], [\"a\", \"b\", \"c\", \"d\"]);\n\njulia> axes_keys(deleteat!(x, \"c\"))\n([\"a\", \"b\", \"d\"],)\n\n\n\n\n\n\n","category":"method"},{"location":"arrays/#Base.inv-Tuple{AbstractAxisArray}","page":"Array Interface","title":"Base.inv","text":"inv(M::AbstractAxisMatrix)\n\nComputes the inverse of an AbstractAxisMatrixMatrix\n\njulia> using AxisIndices, LinearAlgebra\n\njulia> M = AxisArray([2 5; 1 3], [\"a\", \"b\"], [:one, :two]);\n\njulia> axes_keys(inv(M))\n([:one, :two], [\"a\", \"b\"])\n\n\n\n\n\n\n","category":"method"},{"location":"arrays/#Base.reshape-Union{Tuple{N}, Tuple{AbstractAxisArray,Tuple{Vararg{Int64,N}}}} where N","page":"Array Interface","title":"Base.reshape","text":"reshape(A::AbstractAxisArray, shape)\n\nReshape the array and axes of A.\n\nExamples\n\njulia> using AxisIndices\n\njulia> A = reshape(AxisArray(Vector(1:8), [:a, :b, :c, :d, :e, :f, :g, :h]), 4, 2);\n\njulia> axes(A)\n(Axis([:a, :b, :c, :d] => Base.OneTo(4)), SimpleAxis(Base.OneTo(2)))\n\njulia> axes(reshape(A, 2, :))\n(Axis([:a, :b] => Base.OneTo(2)), SimpleAxis(Base.OneTo(4)))\n\n\n\n\n\n","category":"method"},{"location":"arrays/#Base.rot180-Tuple{AbstractAxisArray{T,2,P,Tuple{A1,A2}} where A2 where A1 where P<:AbstractArray{T,2} where T}","page":"Array Interface","title":"Base.rot180","text":"rot180(A::AbstractAxisMatrix)\n\nRotate A 180 degrees, along with its axes keys.\n\nExamples\n\njulia> using AxisIndices\n\njulia> a = AxisArray([1 2; 3 4], [\"a\", \"b\"], [\"one\", \"two\"]);\n\njulia> b = rot180(a);\n\njulia> axes_keys(b)\n([\"b\", \"a\"], [\"two\", \"one\"])\n\njulia> c = rotr90(rotr90(a));\n\njulia> axes_keys(c)\n([\"b\", \"a\"], [\"two\", \"one\"])\n\njulia> a[\"a\", \"one\"] == b[\"a\", \"one\"] == c[\"a\", \"one\"]\ntrue\n\n\n\n\n\n","category":"method"},{"location":"arrays/#Base.rotl90-Tuple{AbstractAxisArray{T,2,P,Tuple{A1,A2}} where A2 where A1 where P<:AbstractArray{T,2} where T}","page":"Array Interface","title":"Base.rotl90","text":"rotl90(A::AbstractAxisMatrix)\n\nRotate A left 90 degrees, along with its axes keys.\n\nExamples\n\njulia> using AxisIndices\n\njulia> a = AxisArray([1 2; 3 4], [\"a\", \"b\"], [\"one\", \"two\"]);\n\njulia> b = rotl90(a);\n\njulia> axes_keys(b)\n([\"two\", \"one\"], [\"a\", \"b\"])\n\njulia> a[\"a\", \"one\"] == b[\"one\", \"a\"]\ntrue\n\n\n\n\n\n\n","category":"method"},{"location":"arrays/#Base.rotr90-Tuple{AbstractAxisArray{T,2,P,Tuple{A1,A2}} where A2 where A1 where P<:AbstractArray{T,2} where T}","page":"Array Interface","title":"Base.rotr90","text":"rotr90(A::AbstractAxisMatrix)\n\nRotate A right 90 degrees, along with its axes keys.\n\nExamples\n\njulia> using AxisIndices\n\njulia> a = AxisArray([1 2; 3 4], [\"a\", \"b\"], [\"one\", \"two\"]);\n\njulia> b = rotr90(a);\n\njulia> axes_keys(b)\n([\"one\", \"two\"], [\"b\", \"a\"])\n\njulia> a[\"a\", \"one\"] == b[\"one\", \"a\"]\ntrue\n\n\n\n\n\n","category":"method"},{"location":"arrays/#LinearAlgebra.diag-Union{Tuple{AbstractAxisArray}, Tuple{D}, Tuple{AbstractAxisArray,Integer}} where D","page":"Array Interface","title":"LinearAlgebra.diag","text":"diag(M::AbstractAxisMatrix, k::Integer=0; dim::Val=Val(1))\n\nThe kth diagonal of an AbstractAxisMatrixMatrix, M. The keyword argument dim specifies which which dimension's axis to preserve, with the default being the first dimension. This can be change by specifying dim=Val(2) instead.\n\njulia> using AxisIndices, LinearAlgebra\n\njulia> A = AxisArray([1 2 3; 4 5 6; 7 8 9], [\"a\", \"b\", \"c\"], [:one, :two, :three]);\n\njulia> axes_keys(diag(A))\n([\"a\", \"b\", \"c\"],)\n\njulia> axes_keys(diag(A, 1; dim=Val(2)))\n([:one, :two],)\n\n\n\n\n\n\n","category":"method"},{"location":"arrays/#LinearAlgebra.lq-Tuple{AbstractAxisArray,Vararg{Any,N} where N}","page":"Array Interface","title":"LinearAlgebra.lq","text":"lq(A::AbstractAxisArray, args...; kwargs...)\n\nCompute the LQ factorization of an AbstractAxisArray A.\n\nExamples\n\njulia> using AxisIndices, LinearAlgebra\n\njulia> m = AxisArray([1.0 2; 3 4], (Axis(2:3 => Base.OneTo(2)), Axis(3:4 => Base.OneTo(2))));\n\njulia> F = lq(m);\n\njulia> keys.(axes(F.L))\n(2:3, Base.OneTo(2))\n\njulia> keys.(axes(F.Q))\n(Base.OneTo(2), 3:4)\n\njulia> keys.(axes(F.L * F.Q))\n(2:3, 3:4)\n\n\n\n\n\n","category":"method"},{"location":"arrays/#LinearAlgebra.lu","page":"Array Interface","title":"LinearAlgebra.lu","text":"lu(A::AbstractAxisArray, args...; kwargs...)\n\nCompute the LU factorization of an AbstractAxisArray A.\n\nExamples\n\njulia> using AxisIndices, LinearAlgebra\n\njulia> m = AxisArray([1.0 2; 3 4], (Axis(2:3 => Base.OneTo(2)), Axis(3:4 => Base.OneTo(2))));\n\njulia> F = lu(m);\n\njulia> keys.(axes(F.L))\n(2:3, Base.OneTo(2))\n\njulia> keys.(axes(F.U))\n(Base.OneTo(2), 3:4)\n\njulia> keys.(axes(F.p))\n(2:3,)\n\njulia> keys.(axes(F.P))\n(2:3, 2:3)\n\njulia> keys.(axes(F.P * m))\n(2:3, 3:4)\n\njulia> keys.(axes(F.L * F.U))\n(2:3, 3:4)\n\n\n\n\n\n","category":"function"},{"location":"arrays/#LinearAlgebra.qr-Union{Tuple{T}, Tuple{AbstractAxisArray{T,2,P,AI} where AI where P,Vararg{Any,N} where N}} where T","page":"Array Interface","title":"LinearAlgebra.qr","text":"qr(F::AbstractAxisArray, args...; kwargs...)\n\nCompute the QR factorization of an AbstractAxisArray A.\n\nExamples\n\njulia> using AxisIndices, LinearAlgebra\n\njulia> m = AxisArray([1.0 2; 3 4], (Axis(2:3 => Base.OneTo(2)), Axis(3:4 => Base.OneTo(2))));\n\njulia> F = qr(m, Val(true));\n\njulia> keys.(axes(F.Q))\n(2:3, Base.OneTo(2))\n\njulia> keys.(axes(F.R))\n(Base.OneTo(2), 3:4)\n\njulia> keys.(axes(F.Q * F.R))\n(2:3, 3:4)\n\njulia> keys.(axes(F.p))\n(2:3,)\n\njulia> keys.(axes(F.P))\n(2:3, 2:3)\n\njulia> keys.(axes(F.P * AxisArray([1.0 2; 3 4], (2:3, 3:4))))\n(2:3, 3:4)\n\n\n\n\n\n","category":"method"},{"location":"arrays/#LinearAlgebra.svd-Tuple{AbstractAxisArray,Vararg{Any,N} where N}","page":"Array Interface","title":"LinearAlgebra.svd","text":"svd(F::AbstractAxisArray, args...; kwargs...)\n\nCompute the singular value decomposition (SVD) of an AbstractAxisArray A.\n\nExamples\n\njulia> using AxisIndices, LinearAlgebra\n\njulia> m = AxisArray([1.0 2; 3 4], (Axis(2:3 => Base.OneTo(2)), Axis(3:4 => Base.OneTo(2))));\n\njulia> F = svd(m);\n\njulia> axes(F.U)\n(Axis(2:3 => Base.OneTo(2)), SimpleAxis(Base.OneTo(2)))\n\njulia> axes(F.V)\n(Axis(3:4 => Base.OneTo(2)), SimpleAxis(Base.OneTo(2)))\n\njulia> axes(F.Vt)\n(SimpleAxis(Base.OneTo(2)), Axis(3:4 => Base.OneTo(2)))\n\njulia> axes(F.U * Diagonal(F.S) * F.Vt)\n(Axis(2:3 => Base.OneTo(2)), Axis(3:4 => Base.OneTo(2)))\n\n\n\n\n\n\n","category":"method"},{"location":"arrays/#Statistics.cor-Union{Tuple{AbstractAxisArray{T,2,P,AI} where AI where P}, Tuple{T}} where T","page":"Array Interface","title":"Statistics.cor","text":"cor(x::AbstractAxisMatrix; dims=1, kwargs...)\n\nPerforms cor on the parent matrix of x and reconstructs a similar type with the appropriate axes.\n\nExamples\n\njulia> using AxisIndices, Statistics\n\njulia> A = AxisArray([1 2 3; 4 5 6; 7 8 9], [\"a\", \"b\", \"c\"], [:one, :two, :three]);\n\njulia> axes_keys(cor(A, dims = 2))\n([\"a\", \"b\", \"c\"], [\"a\", \"b\", \"c\"])\n\njulia> axes_keys(cor(A, dims = 1))\n([:one, :two, :three], [:one, :two, :three])\n\n\n\n\n\n\n","category":"method"},{"location":"arrays/#Statistics.cov-Union{Tuple{AbstractAxisArray{T,2,P,AI} where AI where P}, Tuple{T}} where T","page":"Array Interface","title":"Statistics.cov","text":"cov(x::AbstractAxisMatrix; dims=1, kwargs...)\n\nPerforms cov on the parent matrix of x and reconstructs a similar type with the appropriate axes.\n\nExamples\n\njulia> using AxisIndices, Statistics\n\njulia> A = AxisArray([1 2 3; 4 5 6; 7 8 9], [\"a\", \"b\", \"c\"], [:one, :two, :three]);\n\njulia> axes_keys(cov(A, dims = 2))\n([\"a\", \"b\", \"c\"], [\"a\", \"b\", \"c\"])\n\njulia> axes_keys(cov(A, dims = 1))\n([:one, :two, :three], [:one, :two, :three])\n\n\n\n\n\n\n","category":"method"},{"location":"time/#TimeAxis-Guide-1","page":"TimeAxis Guide","title":"TimeAxis Guide","text":"","category":"section"},{"location":"time/#","page":"TimeAxis Guide","title":"TimeAxis Guide","text":"Here we define an axis that specifically supports time. First, we compose the type and necessary methods for accessing it's properties and constructing it. Second, we define a new trait that changes indexing.","category":"page"},{"location":"time/#.-The-TimeAxis-Type-1","page":"TimeAxis Guide","title":"1. The TimeAxis Type","text":"","category":"section"},{"location":"time/#","page":"TimeAxis Guide","title":"TimeAxis Guide","text":"This first section defines the minimum keys, values, similar_type and constructors for the TimeAxis type.","category":"page"},{"location":"time/#","page":"TimeAxis Guide","title":"TimeAxis Guide","text":"julia> using AxisIndices, Dates, Unitful, ChainedFixes\n\njulia> struct TimeAxis{K,V,Ks,Vs} <: AbstractAxis{K,V,Ks,Vs}\n           axis::Axis{K,V,Ks,Vs}\n           times::Dict{Symbol,Any}\n           function TimeAxis{K,V,Ks,Vs}(axis::Axis{K,V,Ks,Vs}, times::Dict{Symbol,Pair{K,K}}) where {K,V,Ks,Vs}\n               return new{K,V,Ks,Vs}(axis, times)\n           end\n           function TimeAxis{K,V,Ks,Vs}(args...; kwargs...) where {K,V,Ks,Vs}\n               d = Dict{Symbol,Pair{K,K}}()\n               for (k,v) in kwargs\n                   d[k] = v\n               end\n               return new{K,V,Ks,Vs}(Axis{K,V,Ks,Vs}(args...), d)\n           end\n           function TimeAxis(args...; kwargs...)\n               ax = Axis(args...)\n               d = Dict{Symbol,Pair{keytype(ax),keytype(ax)}}()\n               for (k,v) in kwargs\n                   d[k] = v\n               end\n               return new{keytype(ax),valtype(ax),keys_type(ax),indices_type(ax)}(ax, d)\n           end\n       end\n\njulia> Base.keys(t::TimeAxis) = keys(getfield(t, :axis))\n\njulia> Base.values(t::TimeAxis) = values(getfield(t, :axis))\n\njulia> function AxisIndices.similar_type(\n           t::TimeAxis{K,V,Ks,Vs},\n           new_keys_type::Type=Ks,\n           new_indices_type::Type=Vs\n       ) where {K,V,Ks,Vs}\n           return TimeAxis{eltype(new_keys_type),eltype(new_indices_type),new_keys_type,new_indices_type}\n       end","category":"page"},{"location":"time/#.-The-TimeStampCollection-Trait-1","page":"TimeAxis Guide","title":"2. The TimeStampCollection Trait","text":"","category":"section"},{"location":"time/#","page":"TimeAxis Guide","title":"TimeAxis Guide","text":"Not only do we want to store discrete intervals of time with labels in the axis, but we want to reference them in a very simple way for indexing. In other words, if we have previously assigned :time1 the interval of 1 to 3 seconds, then we should be able to do axis[:time1] to index the axis instead of doing axis[axis.times[:time1]]. However, the default indexing behavior is to look for a Symbol in the keys of an axis. We want to tell the indexing pipeline that when we provide a Symbol with a TimeAxis we want to lookup the argument in axis.times and then pass the result to the typical indexing protocol. So we make a new trait that for this.","category":"page"},{"location":"time/#","page":"TimeAxis Guide","title":"TimeAxis Guide","text":"julia> Base.setindex!(t::TimeAxis, val, i::Symbol) = t.times[i] = val\n\njulia> struct TimeStampCollection <: AxisIndices.AxisIndicesStyle end\n\njulia> AxisIndices.is_element(::Type{TimeStampCollection}) = false\n\njulia> function AxisIndices.AxisIndicesStyle(::Type{<:TimeAxis}, ::Type{Symbol})\n           return TimeStampCollection()\n       end\n\njulia> function AxisIndices.to_index(::TimeStampCollection, axis, arg)\n           return AxisIndices.to_index(t.axis, t.times[arg])\n       end\n\njulia> function AxisIndices.to_keys(::TimeStampCollection, axis, arg, index)\n           return AxisIndices.to_keys(t.axis, t.times[arg], index)\n       end","category":"page"},{"location":"time/#TimeAxis-in-Action-1","page":"TimeAxis Guide","title":"TimeAxis in Action","text":"","category":"section"},{"location":"time/#","page":"TimeAxis Guide","title":"TimeAxis Guide","text":"Now we can access the time points of this access by the Symbols that correspond to intervals of time.","category":"page"},{"location":"time/#","page":"TimeAxis Guide","title":"TimeAxis Guide","text":"julia> t = TimeAxis(Second(1):Second(1):Second(10));\n\njulia> t[:time_1] = Second(1):Second(1):Second(3);\n\njulia> t[:time_1] == 1:3\ntrue\n","category":"page"},{"location":"time/#","page":"TimeAxis Guide","title":"TimeAxis Guide","text":"This can also be done with Unitful elements.","category":"page"},{"location":"time/#","page":"TimeAxis Guide","title":"TimeAxis Guide","text":"julia> using Unitful: s\n\njulia> t2 = TimeAxis((1:10)s);\n\njulia> t2[:time_1] = 1s..3s;\n\njulia> t[:time_1] == 1:3\ntrue\n","category":"page"},{"location":"time/#","page":"TimeAxis Guide","title":"TimeAxis Guide","text":"This can naturally turn any array that is an AbstractAxisIndices subtype into a collection of time series data.","category":"page"},{"location":"time/#","page":"TimeAxis Guide","title":"TimeAxis Guide","text":"julia> x = AxisArray(collect(1:2:20), t);\n\njulia> x[:time_1]\n3-element AxisArray{Int64,1}\n • dim_1 - 1 second:1 second:3 seconds\n\n   1 second   1\n  2 seconds   3\n  3 seconds   5\n\n","category":"page"},{"location":"table/#Tabular-Interface-1","page":"Tabular Interface","title":"Tabular Interface","text":"","category":"section"},{"location":"table/#","page":"Tabular Interface","title":"Tabular Interface","text":"warning: Warning\nCurrently the Table interface isn't complete. Details of REPL printing and construction may change.","category":"page"},{"location":"table/#","page":"Tabular Interface","title":"Tabular Interface","text":"AxisIndices.jl integrates with the Tables.jl interface via AxisTable.","category":"page"},{"location":"table/#Construction-1","page":"Tabular Interface","title":"Construction","text":"","category":"section"},{"location":"table/#Key-Word-Construction-1","page":"Tabular Interface","title":"Key Word Construction","text":"","category":"section"},{"location":"table/#","page":"Tabular Interface","title":"Tabular Interface","text":"julia> using AxisIndices\n\njulia> t = Table(A = 1:4, B = [\"M\", \"F\", \"F\", \"M\"])\nTable\n┌───┬───┐\n│ A │ B │\n├───┼───┤\n│ 1 │ M │\n│ 2 │ F │\n│ 3 │ F │\n│ 4 │ M │\n└───┴───┘\n","category":"page"},{"location":"table/#Property-Name-Assignment-1","page":"Tabular Interface","title":"Property Name Assignment","text":"","category":"section"},{"location":"table/#","page":"Tabular Interface","title":"Tabular Interface","text":"julia> t = Table();\n\njulia> t.A = 1:8;\n\njulia> t.B = [\"M\", \"F\", \"F\", \"M\", \"F\", \"M\", \"M\", \"F\"];\n\njulia> t\nTable\n┌───┬───┐\n│ A │ B │\n├───┼───┤\n│ 1 │ M │\n│ 2 │ F │\n│ 3 │ F │\n│ 4 │ M │\n│ 5 │ F │\n│ 6 │ M │\n│ 7 │ M │\n│ 8 │ F │\n└───┴───┘\n","category":"page"},{"location":"table/#Adding-Rows-1","page":"Tabular Interface","title":"Adding Rows","text":"","category":"section"},{"location":"table/#","page":"Tabular Interface","title":"Tabular Interface","text":"TODO","category":"page"},{"location":"table/#Reference-1","page":"Tabular Interface","title":"Reference","text":"","category":"section"},{"location":"table/#","page":"Tabular Interface","title":"Tabular Interface","text":"Pages   = [\"table.md\"]\nModules = [AxisIndices.Tabular]\nOrder   = [:function, :type]","category":"page"},{"location":"table/#","page":"Tabular Interface","title":"Tabular Interface","text":"Modules = [AxisIndices.Tabular]","category":"page"},{"location":"table/#AxisIndices.Tabular.Table","page":"Tabular Interface","title":"AxisIndices.Tabular.Table","text":"Table\n\nStores a vector of columns that may be acccessed via the Tables.jl interface.\n\n\n\n\n\n","category":"type"},{"location":"table/#AxisIndices.Tabular.TableRow","page":"Tabular Interface","title":"AxisIndices.Tabular.TableRow","text":"TableRow\n\nA view of one row of an AbstractTable.\n\n\n\n\n\n","category":"type"},{"location":"table/#AxisIndices.Tabular.AbstractTable","page":"Tabular Interface","title":"AxisIndices.Tabular.AbstractTable","text":"AbstractTable\n\nSupertype for which tables that utilize an AbstractAxis interface for tabular data.\n\n\n\n\n\n","category":"type"},{"location":"#AxisIndices-1","page":"Introduction","title":"AxisIndices","text":"","category":"section"},{"location":"#Introduction-1","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"The goals of this package are:","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Facilitate multidimensional indexing (e.g., instance_of_an_array[indices]) that supports semantic user facing indices (e.g., indices = Second(1)).\nAccomplishing the first goal should not interfere in the ability to perform the vast majority of array related methods (e.g, vcat, append!, etc.).\nIt should be easy to implement new subtypes of AbstractAxis that accommodate novel behavior and needs.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"These goals are accomplished predominantly through the AbstractAxis type. It is a subtype of AbstractUnitRange{<:Integer} with an additional interface for creating keys and interacting with them. This additional interface is intended to be easily extended to new types that may be needed for a variety of different situations. An additional AxisArray type is provided that uses any subtype of AbstractAxis for each axis. However, many methods are provided and documented internally so that it's easy for users to alter the behavior of an AxisArray with a new AbstractAxis subtype or create an entirely unique multidimensional structure.","category":"page"},{"location":"#Where-to-go-from-here-1","page":"Introduction","title":"Where to go from here","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"I just want to get something done.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Then start with the Quick Start section.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"I want to make my own axis type.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Look at the TimeAxis Guide, which implements a custom axis type.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"I want to understand why/how something works","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"If you've read the appropriate docstrings (under \"References\" or available in the REPL) and still have questions then various sections under \"Manual\" are a good place to look. If that doesn't help then create an issue in the AxisIndices repo.","category":"page"},{"location":"internals_of_indexing/#Internals-of-Indexing-1","page":"Internals of Indexing","title":"Internals of Indexing","text":"","category":"section"},{"location":"internals_of_indexing/#","page":"Internals of Indexing","title":"Internals of Indexing","text":"This section is those who want to understand how indexing is implemented in AxisIndices and some of the logic behind it. It goes over:","category":"page"},{"location":"internals_of_indexing/#","page":"Internals of Indexing","title":"Internals of Indexing","text":"The three steps of indexing.\nMapping to indices\nRetrieving elements\nReconstructing axes\nIntroduction to AxisIndicesStyle traits","category":"page"},{"location":"internals_of_indexing/#Mapping-to-Indices-1","page":"Internals of Indexing","title":"Mapping to Indices","text":"","category":"section"},{"location":"internals_of_indexing/#","page":"Internals of Indexing","title":"Internals of Indexing","text":"AxisIndices attempts to redirect the traditional to_indices method from the following...","category":"page"},{"location":"internals_of_indexing/#","page":"Internals of Indexing","title":"Internals of Indexing","text":"function to_indices(A, axes::Tuple, args::Tuple)\n    return (to_index(A, first(args)), to_indices(A, tail(axes), tail(args))...)\nend","category":"page"},{"location":"internals_of_indexing/#","page":"Internals of Indexing","title":"Internals of Indexing","text":"to...","category":"page"},{"location":"internals_of_indexing/#","page":"Internals of Indexing","title":"Internals of Indexing","text":"function to_indices(A, axes::Tuple, args::Tuple)\n    return (to_index(first(axes), first(args)), to_indices(A, tail(axes), tail(args))...)\nend","category":"page"},{"location":"internals_of_indexing/#","page":"Internals of Indexing","title":"Internals of Indexing","text":"This allows each axis to influence how an argument maps to indices. The combination of a given axis and argument produce a trait that directs this mapping.","category":"page"},{"location":"internals_of_indexing/#","page":"Internals of Indexing","title":"Internals of Indexing","text":"AxisIndices.to_index(axis, arg) = to_index(AxisIndicesStyle(axis, arg), axis, arg)","category":"page"},{"location":"internals_of_indexing/#","page":"Internals of Indexing","title":"Internals of Indexing","text":"Note that this to_index method is completely unique from the one implemented in Base [1].","category":"page"},{"location":"internals_of_indexing/#","page":"Internals of Indexing","title":"Internals of Indexing","text":"Functionally, this translates to retrieving the elements of an AbstractIndicesArray like so:","category":"page"},{"location":"internals_of_indexing/#","page":"Internals of Indexing","title":"Internals of Indexing","text":"A[arg1, arg2] ->\nparent(A)[to_indices(A, (arg1, arg2))...] ->\nparent(A)[to_indices(A, axes(A), (arg1, arg2))...] ->\nparent(A)[indices...] -> sub_A","category":"page"},{"location":"internals_of_indexing/#Reconstructing-Axes-1","page":"Internals of Indexing","title":"Reconstructing Axes","text":"","category":"section"},{"location":"internals_of_indexing/#","page":"Internals of Indexing","title":"Internals of Indexing","text":"Once the new array is composed axes need to be reconstructed through to_axes, which essentially is the reverse of to_indices. Instead of passing each argument to to_index they're passed to to_key [2].","category":"page"},{"location":"internals_of_indexing/#","page":"Internals of Indexing","title":"Internals of Indexing","text":"AxisIndices.to_key(axis, arg, index) = to_key(AxisIndicesStyle(axis, arg), axis, arg, index)","category":"page"},{"location":"internals_of_indexing/#","page":"Internals of Indexing","title":"Internals of Indexing","text":"The resulting keys produced are combined with the relevant indices of the new array to reconstruct the axis[3].","category":"page"},{"location":"internals_of_indexing/#AxisIndicesStyle-1","page":"Internals of Indexing","title":"AxisIndicesStyle","text":"","category":"section"},{"location":"internals_of_indexing/#","page":"Internals of Indexing","title":"Internals of Indexing","text":"You may have noticed that AxisIndicesStyle is in the last part of to_index and to_key described. AxisIndicesStyle is the supertype for a set of traits that determine what each argument means in the context of an axis. For example, AxisIndicesStyle(::AbstractAxis, ::Integer) returns IndexElement, telling to_index and to_key that the provided argument directly corresponds to an index with an axis. Contrast this with KeyElement which tells to_index to find the position of the provided argument within the keys and return the corresponding index. These traits are fully responsible for dispatch to to_index and to_keys. Therefore, new subtypes of AxisIndicesStyle must define a to_index and to_keys method.","category":"page"},{"location":"internals_of_indexing/#","page":"Internals of Indexing","title":"Internals of Indexing","text":"[1]: There's absolutely no functionality provided from Base.to_index that isn't already available with AxisIndices.to_index. Providing a seperate implementation is meant to avoid causing any unecessary ambiguities in this or any other packages that may be simultaneously loaded.","category":"page"},{"location":"internals_of_indexing/#","page":"Internals of Indexing","title":"Internals of Indexing","text":"[2]: Why do we need the index produced in the previous to_index method to reconstruct keys? Technically we don't, but it avoids looking up indices a second time and ensuring they are inbounds.","category":"page"},{"location":"internals_of_indexing/#","page":"Internals of Indexing","title":"Internals of Indexing","text":"[3]: It is at this point that unsafe_reconstruct is called. This is only important to know if you want to create a new axis type that has keys that require some unique procedure to reconstruct.","category":"page"}]
}
