var documenterSearchIndex = {"docs":
[{"location":"public_api/#Public-API-1","page":"Public API","title":"Public API","text":"","category":"section"},{"location":"public_api/#","page":"Public API","title":"Public API","text":"AbstractAxisIndices\nAxisIndicesArray\nAbstractAxis\nAbstractSimpleAxis\nAxis\nSimpleAxis\nCartesianAxes\nLinearAxes\nNamedIndicesArray\nNIArray\nindices\naxes_keys\npretty_array\nkeys_type\nfirst_key\nlast_key\nIndices\nKeys","category":"page"},{"location":"public_api/#AxisIndices.AxisCore.AbstractAxisIndices","page":"Public API","title":"AxisIndices.AxisCore.AbstractAxisIndices","text":"AbstractAxisIndices\n\nAbstractAxisIndices is a subtype of AbstractArray that offers integration with the AbstractAxis interface. The only methods that absolutely needs to be defined for a subtype of AbstractAxisIndices are axes, parent, similar_type, and similar. Most users should find the provided AxisIndicesArray subtype is sufficient for the majority of use cases. Although custom behavior may be accomplished through a new subtype of AbstractAxisIndices, customizing the behavior of many methods described herein can be accomplished through a unique subtype of AbstractAxis.\n\nThis implementation is meant to be basic, well documented, and have sane defaults that can be overridden as necessary. In other words, default methods for manipulating arrays that return an AxisIndicesArray should not cause unexpected downstream behavior for users; and developers should be able to freely customize the behavior of AbstractAxisIndices subtypes with minimal effort. \n\n\n\n\n\n","category":"type"},{"location":"public_api/#AxisIndices.AxisCore.AxisIndicesArray","page":"Public API","title":"AxisIndices.AxisCore.AxisIndicesArray","text":"AxisIndicesArray{T,N,P,AI}\n\nAn array struct that wraps any parent array and assigns it an AbstractAxis for each dimension. The first argument is the parent array and the second argument is a tuple of subtypes to AbstractAxis or keys that will be converted to subtypes of AbstractAxis with the provided keys.\n\n\n\n\n\n","category":"type"},{"location":"public_api/#AxisIndices.AxisCore.AbstractAxis","page":"Public API","title":"AxisIndices.AxisCore.AbstractAxis","text":"AbstractAxis\n\nAn AbstractVector subtype optimized for indexing.\n\n\n\n\n\n","category":"type"},{"location":"public_api/#AxisIndices.AxisCore.AbstractSimpleAxis","page":"Public API","title":"AxisIndices.AxisCore.AbstractSimpleAxis","text":"AbstractSimpleAxis{V,Vs}\n\nA subtype of AbstractAxis where the keys and values are represented by a single collection.\n\n\n\n\n\n","category":"type"},{"location":"public_api/#AxisIndices.AxisCore.Axis","page":"Public API","title":"AxisIndices.AxisCore.Axis","text":"Axis(k[, v=OneTo(length(k))])\n\nSubtypes of AbstractAxis that maps keys to values. The first argument specifies the keys and the second specifies the values. If only one argument is specified then the values span from 1 to the length of k.\n\nExamples\n\nThe value for all of these is the same.\n\njulia> using AxisIndices\n\njulia> x = Axis(2.0:11.0, 1:10)\nAxis(2.0:1.0:11.0 => 1:10)\n\njulia> y = Axis(2.0:11.0)  # when only one argument is specified assume it's the keys\nAxis(2.0:1.0:11.0 => Base.OneTo(10))\n\njulia> z = Axis(1:10)\nAxis(1:10 => Base.OneTo(10))\n\nStandard indexing returns the same values\n\njulia> x[2]\n2\n\njulia> x[2] == y[2] == z[2]\ntrue\n\njulia> x[1:2]\nAxis(2.0:1.0:3.0 => 1:2)\n\njulia> y[1:2]\nAxis(2.0:1.0:3.0 => 1:2)\n\njulia> z[1:2]\nAxis(1:2 => 1:2)\n\njulia> x[1:2] == y[1:2] == z[1:2]\ntrue\n\nFunctions that return true or false may be used to search the keys for their corresponding index. The following is equivalent to the previous example.\n\njulia> x[==(3.0)]\n2\n\njulia> x[==(3.0)] ==       # 3.0 is the 2nd key of x\n       y[isequal(3.0)] ==  # 3.0 is the 2nd key of y\n       z[==(2)]            # 2 is the 2nd key of z\ntrue\n\njulia> x[<(4.0)]  # all keys less than 4.0 are 2.0:3.0 which correspond to values 1:2\nAxis(2.0:1.0:3.0 => 1:2)\n\njulia> y[<=(3.0)]  # all keys less than or equal to 3.0 are 2.0:3.0 which correspond to values 1:2\nAxis(2.0:1.0:3.0 => 1:2)\n\njulia> z[<(3)]  # all keys less than or equal to 3 are 1:2 which correspond to values 1:2\nAxis(1:2 => 1:2)\n\njulia> x[<(4.0)] == y[<=(3.0)] == z[<(3)]\ntrue\n\nNotice that == returns a single value instead of a collection of all elements where the key was found to be true. This is because all keys must be unique so there can only ever be one element returned.\n\n\n\n\n\n","category":"type"},{"location":"public_api/#AxisIndices.AxisCore.SimpleAxis","page":"Public API","title":"AxisIndices.AxisCore.SimpleAxis","text":"SimpleAxis(v)\n\nPovides an AbstractAxis interface for any AbstractUnitRange, v. v will be considered both the values and keys of the return instance. \n\nExamples\n\nA SimpleAxis is useful for giving a standard set of indices the ability to use the filtering syntax for indexing.\n\njulia> using AxisIndices\n\njulia> x = SimpleAxis(2:10)\nSimpleAxis(2:10)\n\njulia> x[2]\n2\n\njulia> x[==(2)]\n2\n\njulia> x[2] == x[==(2)]  # keys and values are same\ntrue\n\njulia> x[>(2)]\nSimpleAxis(3:10)\n\njulia> x[>(2)]\nSimpleAxis(3:10)\n\njulia> x[1]\nERROR: BoundsError: attempt to access 9-element SimpleAxis(2:10)) at index [1]\n[...]\n\n\n\n\n\n","category":"type"},{"location":"public_api/#AxisIndices.AxisCore.CartesianAxes","page":"Public API","title":"AxisIndices.AxisCore.CartesianAxes","text":"CartesianAxes\n\nAlias for LinearIndices where indices are subtypes of AbstractAxis.\n\nExamples\n\njulia> using AxisIndices\n\njulia> cartaxes = CartesianAxes((Axis(2.0:5.0), Axis(1:4)));\n\njulia> cartinds = CartesianIndices((1:4, 1:4));\n\njulia> cartaxes[2, 2]\nCartesianIndex(2, 2)\n\njulia> cartinds[2, 2]\nCartesianIndex(2, 2)\n\n\n\n\n\n","category":"type"},{"location":"public_api/#AxisIndices.AxisCore.LinearAxes","page":"Public API","title":"AxisIndices.AxisCore.LinearAxes","text":"LinearAxes\n\nAlias for LinearIndices where indices are subtypes of AbstractAxis.\n\nExamples\n\njulia> using AxisIndices\n\njulia> linaxes = LinearAxes((Axis(2.0:5.0), Axis(1:4)));\n\njulia> lininds = LinearIndices((1:4, 1:4));\n\njulia> linaxes[2, 2]\n6\n\njulia> lininds[2, 2]\n6\n\n\n\n\n\n","category":"type"},{"location":"public_api/#AxisIndices.Names.NamedIndicesArray","page":"Public API","title":"AxisIndices.Names.NamedIndicesArray","text":"NamedIndicesArray\n\nType alias for NamedDimsArray whose parent array is a subtype of AxisIndicesArray.\n\n\n\n\n\n","category":"type"},{"location":"public_api/#AxisIndices.Names.NIArray","page":"Public API","title":"AxisIndices.Names.NIArray","text":"NIArray((parent::AbstractArray; kwargs...) = NIArray(parent, kwargs)\nNIArray((parent::AbstractArray, axes::NamedTuple{L,AbstractAxes}))\n\nAn abbreviated alias and constructor for NamedIndicesArray. If key word arguments are provided then each key word becomes the name of a dimension and its assigned value is sent to the corresponding axis when constructing the underlying AxisIndicesArray.\n\nExamples\n\njulia> using AxisIndices\n\njulia> A = NIArray(reshape(1:24, 2, 3, 4), x=[\"a\", \"b\"], y =[\"one\", \"two\", \"three\"], z=2:5)\nNamedDimsArray{Int64,3,Base.ReshapedArray{Int64,3,UnitRange{Int64},Tuple{}}...}\n • x - Axis([\"a\", \"b\"] => Base.OneTo(2))\n • y - Axis([\"one\", \"two\", \"three\"] => Base.OneTo(3))\n • z - Axis(2:5 => Base.OneTo(4))\n[x, y, z[2]] =\n      one   two   three\n  a     1     3       5\n  b     2     4       6\n\n[x, y, z[3]] =\n      one   two   three\n  a     7     9      11\n  b     8    10      12\n\n[x, y, z[4]] =\n      one   two   three\n  a    13    15      17\n  b    14    16      18\n\n[x, y, z[5]] =\n      one   two   three\n  a    19    21      23\n  b    20    22      24\n\njulia> dimnames(A)\n(:x, :y, :z)\n\njulia> axes_keys(A)\n([\"a\", \"b\"], [\"one\", \"two\", \"three\"], 2:5)\n\njulia> B = A[\"a\", :, :]\nNamedDimsArray{Int64,2,Array{Int64,2}...}\n • y - Axis([\"one\", \"two\", \"three\"] => OneToMRange(3))\n • z - Axis(2:5 => Base.OneTo(4))\n          2    3    4    5\n    one   1    7   13   19\n    two   3    9   15   21\n  three   5   11   17   23\n\njulia> C = B[\"one\",:]\nNamedDimsArray{Int64,1,Array{Int64,1}...}\n • z - Axis(2:5 => Base.OneTo(4))\n\n  2    1\n  3    7\n  4   13\n  5   19\n\n\n\n\n\n\n","category":"type"},{"location":"public_api/#AxisIndices.AxisCore.indices","page":"Public API","title":"AxisIndices.AxisCore.indices","text":"indices(x::AbstractAxis)\n\nReturns the indices x.\n\nExamples\n\njulia> using AxisIndices\n\njulia> indices(Axis([\"a\"], 1:1))\n1:1\n\njulia> indices(CartesianIndex(1,1))\n(1, 1)\n\n\n\n\n\n\nindices(x, i)\n\nReturns the indices corresponding to the i axis\n\nExamples\n\njulia> using AxisIndices\n\njulia> indices(AxisIndicesArray(ones(2,2), (2:3, 3:4)), 1)\nBase.OneTo(2)\n\n\n\n\n\nindices(x)\n\nReturns the indices corresponding to all axes of x.\n\nExamples\n\njulia> using AxisIndices\n\njulia> indices(AxisIndicesArray(ones(2,2), (2:3, 3:4)))\n(Base.OneTo(2), Base.OneTo(2))\n\njulia> indices(Axis([\"a\"], 1:1))\n1:1\n\njulia> indices(CartesianIndex(1,1))\n(1, 1)\n\n\n\n\n\n\n","category":"function"},{"location":"public_api/#AxisIndices.AxisCore.axes_keys","page":"Public API","title":"AxisIndices.AxisCore.axes_keys","text":"axes_keys(x::AbstractArray)\n\nReturns the keys corresponding to all axes of x.\n\nExamples\n\njulia> using AxisIndices\n\njulia> axes_keys(AxisIndicesArray(ones(2,2), (2:3, 3:4)))\n(2:3, 3:4)\n\njulia> axes_keys(Axis(1:2))\n(1:2,)\n\n\n\n\n\naxes_keys(x, i)\n\nReturns the axis keys corresponding of ith dimension of x.\n\nExamples\n\njulia> using AxisIndices\n\njulia> axes_keys(AxisIndicesArray(ones(2,2), (2:3, 3:4)), 1)\n2:3\n\n\n\n\n\n","category":"function"},{"location":"public_api/#AxisIndices.PrettyArrays.pretty_array","page":"Public API","title":"AxisIndices.PrettyArrays.pretty_array","text":"pretty_array([io::IO,] A::AbstractArray[, axs=axes(A)], dimnames=ntuple(i -> Symbol(:dim_, i), N), backend=:text; kwargs...)\n\nPrints to io the array A with the keys key_names along each dimension of A. Printing of multidimensional arrays is accomplished in a similar manner to Array, where the final two dimensions are sliced producing a series of matrices. kwargs... are passed to pretty_table for 1/2D slice produced.\n\nExamples\n\njulia> using AxisIndices\n\njulia> pretty_array(ones(Int, 2,2,2), (Axis(2:3), Axis([:one, :two]), Axis([\"a\", \"b\"])), (:x, :y, :z))\n[x, y, z[a]] =\n      one   two\n  2     1     1\n  3     1     1\n\n[x, y, z[b]] =\n      one   two\n  2     1     1\n  3     1     1\n\n\n\n\n\n\n","category":"function"},{"location":"public_api/#AxisIndices.AxisCore.keys_type","page":"Public API","title":"AxisIndices.AxisCore.keys_type","text":"keys_type(x)\n\nRetrieves the type of the keys of x.\n\nExamples\n\njulia> using AxisIndices\n\njulia> keys_type(Axis(1:2))\nUnitRange{Int64}\n\njulia> keys_type(typeof(Axis(1:2)))\nUnitRange{Int64}\n\njulia> keys_type(UnitRange{Int})\nBase.OneTo{Int64}\n\n\n\n\n\nkeys_type(x, i)\n\nRetrieves axis keys of the ith dimension of x.\n\nExamples\n\njulia> using AxisIndices\n\njulia> keys_type(AxisIndicesArray([1], [\"a\"]), 1)\nArray{String,1}\n\n\n\n\n\n","category":"function"},{"location":"public_api/#AxisIndices.AxisCore.first_key","page":"Public API","title":"AxisIndices.AxisCore.first_key","text":"first_key(x)\n\nReturns the first key of x.\n\nExamples\n\njulia> using AxisIndices\n\njulia> first_key(Axis(2:10))\n2\n\n\n\n\n\n","category":"function"},{"location":"public_api/#AxisIndices.AxisCore.last_key","page":"Public API","title":"AxisIndices.AxisCore.last_key","text":"last_key(x)\n\nReturns the last key of x.\n\nExamples\n\njulia> using AxisIndices\n\njulia> last_key(Axis(2:10))\n10\n\n\n\n\n\n","category":"function"},{"location":"public_api/#AxisIndices.AxisCore.Indices","page":"Public API","title":"AxisIndices.AxisCore.Indices","text":"Indices(arg)\n\nForces arg to refer to indices when indexing.\n\n\n\n\n\n","category":"type"},{"location":"public_api/#AxisIndices.AxisCore.Keys","page":"Public API","title":"AxisIndices.AxisCore.Keys","text":"Keys(arg)\n\nForces arg to refer to keys when indexing.\n\n\n\n\n\n","category":"type"},{"location":"comparison/#Comparison-to-Other-Packages-1","page":"Comparison to Other Packages","title":"Comparison to Other Packages","text":"","category":"section"},{"location":"comparison/#","page":"Comparison to Other Packages","title":"Comparison to Other Packages","text":"This is very brief overview of how AxisIndices compares to other packages. Rather than a comprehensive comparison of available alternatives and integrations, this is intended to provide a general idea of how AxisIndices fits in the Julia ecosystem.","category":"page"},{"location":"comparison/#","page":"Comparison to Other Packages","title":"Comparison to Other Packages","text":"AxisArrays.jl similarly supports mapping some sort of keys to each set of indices. AxisIndices is intended to be a more comprehensive, well documented, and flexible implementation of this concept. AxisArays natively offers the ability to name each dimension. In contrast AxisIndices was developed with the intention of using packages like NamedDims.jl to more fully implement such features in a complementary way.","category":"page"},{"location":"comparison/#","page":"Comparison to Other Packages","title":"Comparison to Other Packages","text":"DimensionalData.jl is a notable package that covers many similar funcitonalities as AxisArrays did. There are numerous differences in design decisions between this package and DimensionalData. It's likely that the majority of these differences represent personal preferences rather than strictly objective advantages over one another. In terms of approach, DimensionalData offers a more comprehensive alternative to the functionality of AxisArrays, where AxisIndices is intended only to be a highly customizable component of some of the features AxisArrays offers. Therefore, this package expects users seeking a complete replacement for AxisArrays to ultimately use another package that composes a modular solution to replacing AxisArrays.","category":"page"},{"location":"comparison/#","page":"Comparison to Other Packages","title":"Comparison to Other Packages","text":"There are many packages that offer overlapping features. For example, Dictionaries.jl implements a focused improvement on dictionaries where mapping keys to indices highly overlaps. However, as Dictionaries.jl continues to evolve many of the types provided therein may prove extremely useful in constructing the keys of an Axis type thereby giving these dictionaries multidimensional functionality. Similarly, many packages provide overlapping features that could actually be extended with the addition (not replacement) of AxisIndices.","category":"page"},{"location":"pretty_printing/#Pretty-Printing-1","page":"Pretty Printing","title":"Pretty Printing","text":"","category":"section"},{"location":"pretty_printing/#","page":"Pretty Printing","title":"Pretty Printing","text":"It's important that we can view the custom indices that we assign to arrays. Yet a surprising challenge of implementing and using arrays in interactive programming is how complicated printing them can be. Rather than burdening users with cryptic text readouts this package seeks to provide \"pretty\" printing (quotes because beauty is in the eye of the beholder). This package leans heavily on the PrettyTables.jl package to accomplish this by handing off everything that goes through the show method to pretty_array. pretty_array in turn repeatedly calls PrettyTables.pretty_print along slices of arrays.","category":"page"},{"location":"pretty_printing/#","page":"Pretty Printing","title":"Pretty Printing","text":"warning: Warning\nLike much of this package, pretty printing is continually being developed at this time. Unlike most of this package, improvements in visualizing arrays is subjective and more likely to result changes that are noticeable to users. Therefore, users are encouraged to utilize related functionality and provide feedback but should not yet rely on these methods for tests in other packages.","category":"page"},{"location":"axis/#The-Axis-Interface-1","page":"The Axis","title":"The Axis Interface","text":"","category":"section"},{"location":"axis/#","page":"The Axis","title":"The Axis","text":"The following describes the components necessary to construct and manipulate existing and new subtypes of AbstractAxis.","category":"page"},{"location":"axis/#Introduction-1","page":"The Axis","title":"Introduction","text":"","category":"section"},{"location":"axis/#","page":"The Axis","title":"The Axis","text":"The supertype to all axis types herein is the AbstractAxis, which is a subtype of AbstractUnitRange{<:Integer}.","category":"page"},{"location":"axis/#","page":"The Axis","title":"The Axis","text":"If we have a set of keys a b c and a set of indices 1 2 3 then the key a maps to the index 1. Given these definitions, the AbstractAxis differs from the classic dictionary in the following two ways:","category":"page"},{"location":"axis/#","page":"The Axis","title":"The Axis","text":"The valtype of AbstractAxis is always an integer.\nThe values are always unique and continuous.","category":"page"},{"location":"axis/#","page":"The Axis","title":"The Axis","text":"The two main axis types defined here are Axis and SimpleAxis. The standard syntax for indexing doesn't change at all for these types.","category":"page"},{"location":"axis/#","page":"The Axis","title":"The Axis","text":"julia> using AxisIndices, Dates\n\njulia> sa = SimpleAxis(1:10)\nSimpleAxis(1:10)\n\njulia> sa[2]\n2\n\njulia> sa[>(2)]\nSimpleAxis(3:10)\n\njulia> a = Axis(1:10)\nAxis(1:10 => Base.OneTo(10))\n\njulia> a[2]\n2\n\njulia> a[2:3]\nAxis(2:3 => 2:3)","category":"page"},{"location":"axis/#","page":"The Axis","title":"The Axis","text":"But now we can also use functions to index by the keys of an AbstractAxis.","category":"page"},{"location":"axis/#","page":"The Axis","title":"The Axis","text":"julia> a = Axis(2.0:11.0, 1:10)\nAxis(2.0:1.0:11.0 => 1:10)\n\njulia> a[1]\n1\n\njulia> a[isequal(2.0)]\n1\n\njulia> a[>(2)]\nAxis(3.0:1.0:11.0 => 2:10)\n\njulia> a[>(2.0)]\nAxis(3.0:1.0:11.0 => 2:10)\n\njulia> a[and(>(2.0), <(8.0))]\nAxis(3.0:1.0:7.0 => 2:6)\n\njulia> sa[in(3:5)]\nSimpleAxis(3:5)","category":"page"},{"location":"axis/#","page":"The Axis","title":"The Axis","text":"This also allows certain syntax special treatment because they are obviously not referring to traditional integer based indexing.","category":"page"},{"location":"axis/#","page":"The Axis","title":"The Axis","text":"julia> x, y, z = Axis([:one, :two, :three]), Axis([\"one\", \"two\", \"three\"]), Axis(Second(1):Second(1):Second(3));\n\njulia> x[:one]\n1\n\njulia> x[:one] == y[\"one\"] == z[Second(1)]\ntrue\n\njulia> x[[:one, :two]]\n2-element Array{Int64,1}:\n 1\n 2","category":"page"},{"location":"axis/#","page":"The Axis","title":"The Axis","text":"Note in the last example that a vector was returned instead of an AbstractAxis. An AbstractAxis is a subtype of AbstractUnitRange and therefore cannot be reformed after any operation that does not guarantee the return of another unit range. This is similar to the behavior of UnitRange in base.","category":"page"},{"location":"axis/#Performance-1","page":"The Axis","title":"Performance","text":"","category":"section"},{"location":"axis/#","page":"The Axis","title":"The Axis","text":"Indexing CartesianAxes is comparable to that of CartesianIndices.","category":"page"},{"location":"axis/#","page":"The Axis","title":"The Axis","text":"julia> using AxisIndices, BenchmarkTools\n\njulia> cartaxes = CartesianAxes((Axis(2.0:5.0), Axis(1:4)));\n\njulia> cartinds = CartesianIndices((1:4, 1:4));\n\njulia> @btime getindex(cartaxes, 2, 2)\n  20.848 ns (1 allocation: 32 bytes)\nCartesianIndex(2, 2)\n\njulia> @btime getindex(cartinds, 2, 2)\n  22.317 ns (1 allocation: 32 bytes)\nCartesianIndex(2, 2)\n\njulia> @btime getindex(cartaxes, ==(3.0), 2)\n  444.374 ns (7 allocations: 416 bytes)\nCartesianIndex(2, 2)","category":"page"},{"location":"axis/#","page":"The Axis","title":"The Axis","text":"Indexing LinearAxes is comparable to that of LinearIndices","category":"page"},{"location":"axis/#","page":"The Axis","title":"The Axis","text":"julia> using AxisIndices, BenchmarkTools\n\njulia> linaxes = LinearAxes((Axis(1.0:4.0), Axis(1:4)));\n\njulia> lininds = LinearIndices((1:4, 1:4));\n\njulia> @btime getindex(linaxes, 2, 2)\n  18.275 ns (0 allocations: 0 bytes)\n6\n\njulia> @btime getindex(lininds, 2, 2)\n  18.849 ns (0 allocations: 0 bytes)\n6\n\njulia> @btime getindex(linaxes, ==(3.0), 2)\n  381.098 ns (6 allocations: 384 bytes)\n7","category":"page"},{"location":"axis/#","page":"The Axis","title":"The Axis","text":"You may notice there's significant overhead for using the filtering syntax. However, the filtering syntax takes advantage of a special type in base, Fix2. This means that we can take advantage of filtering methods that have been optimized for specific types of keys.  Here we do the same thing as above but we create a function that knows it's going to perform filtering.","category":"page"},{"location":"axis/#","page":"The Axis","title":"The Axis","text":"julia> getindex_filter(a, i1, i2) = a[==(i1), ==(i2)]\ngetindex_filter (generic function with 1 method)\n\njulia> @btime getindex_filter(linaxes, 3.0, 2)\n  57.216 ns (0 allocations: 0 bytes)\n7\n\njulia> linaxes2 = LinearAxes((Axis(Base.OneTo(4)), Axis(Base.OneTo(4))));\n\njulia> @btime getindex_filter(linaxes2, 3, 2)\n  22.070 ns (0 allocations: 0 bytes)\n7","category":"page"},{"location":"axis/#","page":"The Axis","title":"The Axis","text":"Indexing linaxes is much faster now that it can be optimized inside of a function call. However, it's still a little over twice as slow as normal indexing. That's largely because of the cost of searching 1.0:4.0 (which is a StepRangeLen type in this case). The second benchmark demonstrates how close we really are to standard indexing given similar range types.","category":"page"},{"location":"axis/#Resizing-Axes-1","page":"The Axis","title":"Resizing Axes","text":"","category":"section"},{"location":"axis/#","page":"The Axis","title":"The Axis","text":"These methods help with operations that need to resize axes, either dynamically or by creating a new instance of an axis. In addition to helping with operations related to array resizing, these may be useful for managing the axis of a vector throughout a push!, pushfirst!, pop, and popfirst! operation.","category":"page"},{"location":"compatibility/#Compatibility-1","page":"Compatibility","title":"Compatibility","text":"","category":"section"},{"location":"compatibility/#","page":"Compatibility","title":"Compatibility","text":"The following packages outside of the Base module have some form of support. In addition to creating awareness of existing functionality, the following provides users with a better idea of how exactly these packages are supported. This means features existing outside of those described here are not within the domain of intended coverage and users should seek support linked resources.","category":"page"},{"location":"compatibility/#MappedArrays-1","page":"Compatibility","title":"MappedArrays","text":"","category":"section"},{"location":"compatibility/#","page":"Compatibility","title":"Compatibility","text":"MappedArrays.jl allows \"lazy\" in-place elementwise transformations of arrays. Support is provided by overloading the mappedarray method, which AxisIndices does not export (i.e. users must using mappedArrays to get access to it). In order to avoid method ambiguities multi-mapping of mixed AbstractArray and AbstractAxisIndices cannot be provided. In other words, the current version can only support multi-mapping multiple AbstractAxisIndices.","category":"page"},{"location":"compatibility/#NamedDims-1","page":"Compatibility","title":"NamedDims","text":"","category":"section"},{"location":"compatibility/#","page":"Compatibility","title":"Compatibility","text":"NamedDims.jl","category":"page"},{"location":"compatibility/#OffsetArrays-1","page":"Compatibility","title":"OffsetArrays","text":"","category":"section"},{"location":"compatibility/#","page":"Compatibility","title":"Compatibility","text":"Many of the tests used for OffsetArrays package have been incorporated into the tests of AxisIndices to ensure compatibility.","category":"page"},{"location":"acknowledgments/#Acknowledgments-1","page":"Acknowledgments","title":"Acknowledgments","text":"","category":"section"},{"location":"acknowledgments/#","page":"Acknowledgments","title":"Acknowledgments","text":"This package is the result of many people providing input to make it successful. Hopefully, it will continue to be a product of such collaborations. The following is an incomplete list of individuals who have helped me in some way get this package started. It's mainly a list of people who have tolerated my incessant queries into many minor details that led to this package.","category":"page"},{"location":"acknowledgments/#","page":"Acknowledgments","title":"Acknowledgments","text":"Eric Davies\nLyndon White\nMichael Abbott\nRafael Schouten\nTim Holy","category":"page"},{"location":"acknowledgments/#","page":"Acknowledgments","title":"Acknowledgments","text":"Also, anyone that has contributed to StaticArrays.jl and NamedDims.jl has probably helped.","category":"page"},{"location":"quick_start/#Quick-Start-1","page":"Quick Start","title":"Quick Start","text":"","category":"section"},{"location":"quick_start/#","page":"Quick Start","title":"Quick Start","text":"Custom indexing only requires specifying a tuple of keys[1] for the indices of each dimension.","category":"page"},{"location":"quick_start/#","page":"Quick Start","title":"Quick Start","text":"julia> using AxisIndices\n\njulia> A = AxisIndicesArray(reshape(1:9, 3,3),\n               (2:4,        # first dimension has keys 2:4\n                3.0:5.0));  # second dimension has keys 3.0:5.0","category":"page"},{"location":"quick_start/#","page":"Quick Start","title":"Quick Start","text":"Most code should work just the same for an AxisIndicesArray...","category":"page"},{"location":"quick_start/#","page":"Quick Start","title":"Quick Start","text":"julia> A[1, 1]\n1\n\njulia> A[1:2, 1:2] == parent(A)[1:2, 1:2]\ntrue\n\njulia> sum(A) == sum(parent(A))\ntrue","category":"page"},{"location":"quick_start/#","page":"Quick Start","title":"Quick Start","text":"But now the indices of each dimension have keys that we can filter through.","category":"page"},{"location":"quick_start/#","page":"Quick Start","title":"Quick Start","text":"julia> A[==(2), ==(3.0)] == parent(A)[findfirst(==(2), 2:4), findfirst(==(3.0), 3.0:5.0)] == 1\ntrue\n\njulia> A[<(4), <(5.0)] == parent(A)[findall(<(4), 2:4), findall(<(5.0), 3.0:5.0)] == [1 4; 2 5]\ntrue","category":"page"},{"location":"quick_start/#","page":"Quick Start","title":"Quick Start","text":"Any value that is not a CartesianIndex or subtype of Real is considered a dedicated key type. In other words, it could never be used for default indexing and will be treated the same as the == filtering syntax above.","category":"page"},{"location":"quick_start/#","page":"Quick Start","title":"Quick Start","text":"julia> AxisIndicesArray([1, 2, 3], ([\"one\", \"two\", \"three\"],))[\"one\"]\n1","category":"page"},{"location":"quick_start/#","page":"Quick Start","title":"Quick Start","text":"Note that the first call only returns a single element, where the last call returns an array. This is because all keys must be unique so there can only be one value that returns true if filtering by ==, which is the same as indexing by 1 (e.g., only one index can equal 1). The last call uses operators that can produce any number of true values and the resulting output is an array. This is the same as indexing an array by any vector (i.e., returns another array).","category":"page"},{"location":"quick_start/#","page":"Quick Start","title":"Quick Start","text":"[1]: Terminology here is important here. Keys, indices, and axes each have a specific meaning. Throughout the documentation the following functional definitions apply:axis: maps a set of keys to a set of indices.\nindices: a set of integers (e.g., <:Integer) that locate the in memory locations of elements.\nkeys: maps a set of any type to a set of indices\nindexing: anytime one calls getindex or uses square brackets to navigate the elements of a collectionAlso note the use of argument (abbreviated arg in code) and arguments (abbreviated args in code). These terms specifically refer to what users pass to an indexing method. Therefore, an argument may be a key (:a), index (1), or something else that maps to one of the two (==(1)).","category":"page"},{"location":"indexing/#Indexing-Tutorial-1","page":"Indexing Tutorial","title":"Indexing Tutorial","text":"","category":"section"},{"location":"indexing/#Indexing-an-Axis-1","page":"Indexing Tutorial","title":"Indexing an Axis","text":"","category":"section"},{"location":"indexing/#","page":"Indexing Tutorial","title":"Indexing Tutorial","text":"Setup for running axis examples.","category":"page"},{"location":"indexing/#","page":"Indexing Tutorial","title":"Indexing Tutorial","text":"julia> using AxisIndices, Unitful, IntervalSets\n\njulia> using Unitful: s\n\njulia> time1 = Axis((1.5:.5:10)s)\nAxis((1.5:0.5:10.0) s => Base.OneTo(18))\n\njulia> time2 = Axis((1.5:.5:10)s, 2:19)\nAxis((1.5:0.5:10.0) s => 2:19)","category":"page"},{"location":"indexing/#Indexing-With-Integers-1","page":"Indexing Tutorial","title":"Indexing With Integers","text":"","category":"section"},{"location":"indexing/#","page":"Indexing Tutorial","title":"Indexing Tutorial","text":"Integers will map directly to the indices of an axis.","category":"page"},{"location":"indexing/#","page":"Indexing Tutorial","title":"Indexing Tutorial","text":"julia> time1[1]\n1\n\njulia> time1[2]\n2\n\njulia> time2[2]\n2\n\njulia> time2[1]\nERROR: BoundsError: attempt to access 18-element Axis((1.5:0.5:10.0) s => 2:19) at index [1]\n[...]","category":"page"},{"location":"indexing/#","page":"Indexing Tutorial","title":"Indexing Tutorial","text":"Notice that time2[1] throws an error. This is because the indices of the time2 axis don't contain a 1 and begins at 2. This allows an axis to map to any single dimensional memory mapping, even if it doesn't start at 1.","category":"page"},{"location":"indexing/#","page":"Indexing Tutorial","title":"Indexing Tutorial","text":"Indexing an axis with a collection of integers works similarly to indexing any other AbstractUnitRange. That is, using other subtypes of AbstractUnitRange preserves the structure...","category":"page"},{"location":"indexing/#","page":"Indexing Tutorial","title":"Indexing Tutorial","text":"julia> time1[1:2]\nAxis((1.5:0.5:2.0) s => 1:2)\n\njulia> time2[2:3]\nAxis((1.5:0.5:2.0) s => 2:3)","category":"page"},{"location":"indexing/#","page":"Indexing Tutorial","title":"Indexing Tutorial","text":"However, we can't ensure that the resulting range will have a step of one in other cases so only the indices are returned.","category":"page"},{"location":"indexing/#","page":"Indexing Tutorial","title":"Indexing Tutorial","text":"julia> time1[1:2:4]\n1:2:3\n\njulia> time1[[1, 2, 3]]\n3-element Array{Int64,1}:\n 1\n 2\n 3\n\njulia> time1[firstindex(time1):end]\nAxis((1.5:0.5:10.0) s => 1:18)\n","category":"page"},{"location":"indexing/#Indexing-With-Keys-1","page":"Indexing Tutorial","title":"Indexing With Keys","text":"","category":"section"},{"location":"indexing/#","page":"Indexing Tutorial","title":"Indexing Tutorial","text":"julia> time1[1.5s]\n1\n\njulia> time2[1.5s]\n2","category":"page"},{"location":"indexing/#","page":"Indexing Tutorial","title":"Indexing Tutorial","text":"julia> time1[1.5s..3s]\nAxis((1.5:0.5:3.0) s => 1:4)\n\njulia> time1[3s..4.5s]\nAxis((3.0:0.5:4.5) s => 4:7)","category":"page"},{"location":"indexing/#Keys-and-Indices-1","page":"Indexing Tutorial","title":"Keys and Indices","text":"","category":"section"},{"location":"indexing/#","page":"Indexing Tutorial","title":"Indexing Tutorial","text":"If our keys are integers and we want to ensure that we always refer keys we can use Keys","category":"page"},{"location":"indexing/#","page":"Indexing Tutorial","title":"Indexing Tutorial","text":"julia> Axis((2:11), 1:10)[Keys(<(5))]\nAxis(2:4 => 1:3)\n\njulia> Axis((2:11), 1:10)[Indices(<(5))]\nAxis(2:5 => 1:4)\n\njulia> Axis((2:11), 1:10)[Keys(3)]\n2\n\njulia> Axis((2:11), 1:10)[Indices(3)]\n3\n","category":"page"},{"location":"indexing/#Approximate-Indexing-1","page":"Indexing Tutorial","title":"Approximate Indexing","text":"","category":"section"},{"location":"indexing/#","page":"Indexing Tutorial","title":"Indexing Tutorial","text":"julia> axis = Axis([pi + 0, pi + 1]);\n\njulia> axis[3.141592653589793]\n1\n\njulia> axis[3.14159265358979]\nERROR: BoundsError: attempt to access 2-element Axis([3.141592653589793, 4.141592653589793] => OneToMRange(2)) at index [3.14159265358979]\n[...]\n\njulia> axis[isapprox(3.14159265358979)]\n1\n\njulia> axis[isapprox(3.14, atol=1e-2)]\n1","category":"page"},{"location":"indexing/#Indexing-With-Functions-1","page":"Indexing Tutorial","title":"Indexing With Functions","text":"","category":"section"},{"location":"indexing/#","page":"Indexing Tutorial","title":"Indexing Tutorial","text":"Operators that typically return true or false can often ","category":"page"},{"location":"indexing/#","page":"Indexing Tutorial","title":"Indexing Tutorial","text":"julia> time1[<(3.0s)]\nAxis((1.5:0.5:2.5) s => 1:3)\n\njulia> time1[>(3.0s)]\nAxis((3.5:0.5:10.0) s => 5:18)\n\njulia> time1[==(6.0s)]\n10\n\njulia> time1[!=(6.0s)] == vcat(1:9, 11:18)\ntrue","category":"page"},{"location":"indexing/#","page":"Indexing Tutorial","title":"Indexing Tutorial","text":"These operators can also be combined to get more specific regions of an axis.","category":"page"},{"location":"indexing/#","page":"Indexing Tutorial","title":"Indexing Tutorial","text":"julia> time1[and(>(2.5s), <(10.0s))]\nAxis((3.0:0.5:9.5) s => 4:17)\n\njulia> time1[>(2.5s) ⩓ <(10.0s)]  # equivalent to `and` you can use \\And<TAB>\nAxis((3.0:0.5:9.5) s => 4:17)\n\njulia> time1[or(<(2.5s),  >(9.0s))] == vcat(1:2, 17:18)\ntrue\n\njulia> time1[<(2.5s) ⩔ >(9.0s)] == vcat(1:2, 17:18) # equivalent to `or` you can use \\Or<TAB>\ntrue\n","category":"page"},{"location":"indexing/#Indexing-an-Array-1","page":"Indexing Tutorial","title":"Indexing an Array","text":"","category":"section"},{"location":"indexing/#","page":"Indexing Tutorial","title":"Indexing Tutorial","text":"Setup for running array examples.","category":"page"},{"location":"indexing/#","page":"Indexing Tutorial","title":"Indexing Tutorial","text":"julia> A = AxisIndicesArray(reshape(1:9, 3,3),\n               ((.1:.1:.3)s,        # first dimension has keys (0.1:0.1:0.3) s\n                 [\"a\", \"b\", \"c\"]));         # second dimension has keys [\"a\", \"b\", \"c\"]","category":"page"},{"location":"indexing/#Indexing-With-Integers-2","page":"Indexing Tutorial","title":"Indexing With Integers","text":"","category":"section"},{"location":"indexing/#","page":"Indexing Tutorial","title":"Indexing Tutorial","text":"julia> A[1,1]\n1\n\njulia> A[1]\n1","category":"page"},{"location":"indexing/#","page":"Indexing Tutorial","title":"Indexing Tutorial","text":"julia> A[1,:]\nAxisIndicesArray{Int64,1,Array{Int64,1}...}\n • dim_1 - Axis([\"a\", \"b\", \"c\"] => OneToMRange(3))\n\n  a   1\n  b   4\n  c   7\n\n\njulia> A[1:2,1:2]\nAxisIndicesArray{Int64,2,Array{Int64,2}...}\n • dim_1 - Axis((0.1:0.1:0.2) s => Base.OneTo(2))\n • dim_2 - Axis([\"a\", \"b\"] => OneToMRange(2))\n          a   b\n  0.1 s   1   4\n  0.2 s   2   5\n\n\njulia> A[1:3]\n3-element Array{Int64,1}:\n 1\n 2\n 3\n","category":"page"},{"location":"indexing/#Indexing-With-Keys-2","page":"Indexing Tutorial","title":"Indexing With Keys","text":"","category":"section"},{"location":"indexing/#","page":"Indexing Tutorial","title":"Indexing Tutorial","text":"julia> A[.1s, \"a\"]\n1\n\njulia> A[0.1s..0.3s, [\"a\", \"b\"]]\nAxisIndicesArray{Int64,2,Array{Int64,2}...}\n • dim_1 - Axis((0.1:0.1:0.3) s => Base.OneTo(3))\n • dim_2 - Axis([\"a\", \"b\"] => OneToMRange(2))\n          a   b\n  0.1 s   1   4\n  0.2 s   2   5\n  0.3 s   3   6\n\n","category":"page"},{"location":"indexing/#Indexing-With-Functions-2","page":"Indexing Tutorial","title":"Indexing With Functions","text":"","category":"section"},{"location":"indexing/#","page":"Indexing Tutorial","title":"Indexing Tutorial","text":"julia> A[!=(.2s), in([\"a\", \"c\"])]\nAxisIndicesArray{Int64,2,Array{Int64,2}...}\n • dim_1 - Axis(Unitful.Quantity{Float64,𝐓,Unitful.FreeUnits{(s,),𝐓,nothing}}[0.1 s, 0.3 s] => Base.OneTo(2))\n • dim_2 - Axis([\"a\", \"c\"] => OneToMRange(2))\n          a   c\n  0.1 s   1   7\n  0.3 s   3   9\n\n","category":"page"},{"location":"coeftable/#Making-a-CoefTable-1","page":"CoefTable","title":"Making a CoefTable","text":"","category":"section"},{"location":"coeftable/#","page":"CoefTable","title":"CoefTable","text":"This example will guide you through manipulating the pretty printing framework. We'll motivate this by trying to recreate the coefficient table from StatsBase.jl.","category":"page"},{"location":"coeftable/#Creating-the-Table-1","page":"CoefTable","title":"Creating the Table","text":"","category":"section"},{"location":"coeftable/#","page":"CoefTable","title":"CoefTable","text":"julia> using AxisIndices, DataFrames, GLM, Distributions\n\njulia> function coefarray(mm::StatsModels.TableRegressionModel; level::Real=0.95)\n           cc = coef(mm)\n           se = stderror(mm)\n           tt = cc ./ se\n           p = ccdf.(Ref(FDist(1, dof_residual(mm))), abs2.(tt))\n           ci = se*quantile(TDist(dof_residual(mm)), (1-level)/2)\n           levstr = isinteger(level*100) ? string(Integer(level*100)) : string(level*100)\n           ct = AxisIndicesArray(\n               hcat(cc,se,tt,p,cc+ci,cc-ci),\n               (coefnames(mm),\n               [\"Estimate\",\"Std. Error\",\"t value\",\"Pr(>|t|)\",\"Lower $levstr%\",\"Upper $levstr%\"])\n           )\n       end\ncoefarray (generic function with 1 method)\n\njulia> ols = lm(@formula(Y ~ X), DataFrame(X=[1,2,3], Y=[2,4,7]));\n\njulia> cfa = coefarray(ols)\n2-dimensional AxisIndicesArray{Float64,2,Array{Float64,2}...}\n                   Estimate   Std. Error       t value     Pr(>|t|)     Lower 95%    Upper 95%\n  (Intercept)   -0.66666667   0.62360956   -1.06904497   0.47876359   -8.59037747   7.25704413\n            X           2.5   0.28867513    8.66025404    0.0731864   -1.16796536   6.16796536\n","category":"page"},{"location":"coeftable/#","page":"CoefTable","title":"CoefTable","text":"But we can do better. Let's use the underlying pretty_array method to get this into shape.","category":"page"},{"location":"coeftable/#","page":"CoefTable","title":"CoefTable","text":"julia> using PrettyTables\n\nctf = array_text_format = TextFormat(\n    up_right_corner = ' ',\n    up_left_corner = ' ',\n    bottom_left_corner=' ',\n    bottom_right_corner= ' ',\n    up_intersection= '─',\n    left_intersection= ' ',\n    right_intersection= ' ',\n    middle_intersection= '─',\n    bottom_intersection= '─',\n    column= ' ',\n    hlines=[ :begin, :header, :end]\n    #    row= ' ',\n)\n\njulia> pretty_array(cfa; tf=ctf)\n ──────────────────────────────────────────────────────────────────────────────────────────────\n                   Estimate   Std. Error       t value     Pr(>|t|)     Lower 95%    Upper 95%\n ──────────────────────────────────────────────────────────────────────────────────────────────\n  (Intercept)   -0.66666667   0.62360956   -1.06904497   0.47876359   -8.59037747   7.25704413\n            X           2.5   0.28867513    8.66025404    0.0731864   -1.16796536   6.16796536\n ──────────────────────────────────────────────────────────────────────────────────────────────","category":"page"},{"location":"coeftable/#","page":"CoefTable","title":"CoefTable","text":"This looks pretty good but the nicest part is that we can now treat this as a typical matrix.","category":"page"},{"location":"coeftable/#","page":"CoefTable","title":"CoefTable","text":"julia> cfa[1,\"Estimate\"]\n-0.6666666666666738\n\njulia> cfa[1:2,1:2]\n2-dimensional AxisIndicesArray{Float64,2,Array{Float64,2}...}\n                Estimate   Std. Error\n  (Intercept)     -0.667        0.624\n            X        2.5        0.289","category":"page"},{"location":"coeftable/#","page":"CoefTable","title":"CoefTable","text":"Because keys and indices are bound together we don't lose track of what each element is when we index.","category":"page"},{"location":"coeftable/#","page":"CoefTable","title":"CoefTable","text":"julia> cfa[1,:]\n1-dimensional AxisIndicesArray{Float64,1,Array{Float64,1}...}\n\n    Estimate   -0.667\n  Std. Error    0.624\n     t value   -1.069\n    Pr(>|t|)    0.479\n   Lower 95%    -8.59\n   Upper 95%    7.257\n","category":"page"},{"location":"coeftable/#Automating-the-table-1","page":"CoefTable","title":"Automating the table","text":"","category":"section"},{"location":"coeftable/#","page":"CoefTable","title":"CoefTable","text":"We can actually do even better if this format should always be the default by making a new axis type and redefining the coefarray method. The following will result in any array with a CoefHeader printing exactly how we'd like it to by default. Note that this is a quick and dirty way of getting a new axis. See TimeAxis Guide for a better guide on making an axis.","category":"page"},{"location":"coeftable/#","page":"CoefTable","title":"CoefTable","text":"julia> struct CoefHeader <: AbstractAxis{String,Int,Vector{String},Base.OneTo{Int}} end\n\njulia> Base.keys(::CoefHeader) = [\"Estimate\",\"Std. Error\",\"t value\",\"Pr(>|t|)\",\"Lower 95%\",\"Upper 95%\"]\n\njulia> Base.values(::CoefHeader) = Base.OneTo(5)\n\njulia> AxisIndices.text_format(axis, ::CoefHeader) = ctf\n\njulia> AxisIndices.unsafe_reconstruct(::CoefHeader, args...) = CoefHeader()\n\njulia> function coefarray(mm::StatsModels.TableRegressionModel; level::Real=0.95)\n           cc = coef(mm)\n           se = stderror(mm)\n           tt = cc ./ se\n           p = ccdf.(Ref(FDist(1, dof_residual(mm))), abs2.(tt))\n           ci = se*quantile(TDist(dof_residual(mm)), (1-level)/2)\n           levstr = isinteger(level*100) ? string(Integer(level*100)) : string(level*100)\n           ct = AxisIndicesArray(\n               hcat(cc,se,tt,p,cc+ci,cc-ci),\n               (coefnames(mm),\n               CoefHeader())\n           )\n       end;\n\njulia> cfa = coefarray(ols)\n2-dimensional AxisIndicesArray{Float64,2,Array{Float64,2}...}\n ──────────────────────────────────────────────────────────────────────────────────────────────\n                   Estimate   Std. Error       t value     Pr(>|t|)     Lower 95%    Upper 95%\n ──────────────────────────────────────────────────────────────────────────────────────────────\n  (Intercept)   -0.66666667   0.62360956   -1.06904497   0.47876359   -8.59037747   7.25704413\n            X           2.5   0.28867513    8.66025404    0.0731864   -1.16796536   6.16796536\n ──────────────────────────────────────────────────────────────────────────────────────────────\n","category":"page"},{"location":"combining_axes/#Combining-Axes-1","page":"Combining Axes","title":"Combining Axes","text":"","category":"section"},{"location":"combining_axes/#","page":"Combining Axes","title":"Combining Axes","text":"One natural consequence of having axes as independent entities from the actual array data is that it complicates operations such as cat and append!.","category":"page"},{"location":"combining_axes/#","page":"Combining Axes","title":"Combining Axes","text":"How should we propagate characteristics from the values of each axis so that the resulting array is still appropriately memory mapped.\nHow should we combine keys of different types and that are not necessarily unique?","category":"page"},{"location":"combining_axes/#Appending-Axes-1","page":"Combining Axes","title":"Appending Axes","text":"","category":"section"},{"location":"combining_axes/#","page":"Combining Axes","title":"Combining Axes","text":"Appending axes works similar to concatenating axes except that the first argument is mutated.","category":"page"},{"location":"combining_axes/#","page":"Combining Axes","title":"Combining Axes","text":"Customizing appending axes should be accomplished through either AxisIndices.CombineStyle or AxisIndices.append_axis!.","category":"page"},{"location":"combining_axes/#Concatenating-Axes-1","page":"Combining Axes","title":"Concatenating Axes","text":"","category":"section"},{"location":"combining_axes/#","page":"Combining Axes","title":"Combining Axes","text":"Concatenating axes can happen by one of the following:","category":"page"},{"location":"combining_axes/#","page":"Combining Axes","title":"Combining Axes","text":"Stacking two collections of completely unique elements\nResizing a range of values","category":"page"},{"location":"combining_axes/#","page":"Combining Axes","title":"Combining Axes","text":"The second only happens when the two collections provided are subtypes of AbstractRange.","category":"page"},{"location":"combining_axes/#","page":"Combining Axes","title":"Combining Axes","text":"Customizing concatenating axes should be accomplished through either AxisIndices.CombineStyle or AxisIndices.cat_axis.","category":"page"},{"location":"combining_axes/#Broadcasting-Axes-1","page":"Combining Axes","title":"Broadcasting Axes","text":"","category":"section"},{"location":"combining_axes/#","page":"Combining Axes","title":"Combining Axes","text":"There are three things that determine the output of a broadcasting axes.","category":"page"},{"location":"combining_axes/#","page":"Combining Axes","title":"Combining Axes","text":"Standard promotion\nKey specific promotion (or promotion over Real)\nOrder of arguments promotion","category":"page"},{"location":"combining_axes/#","page":"Combining Axes","title":"Combining Axes","text":"Take the following vectors.","category":"page"},{"location":"combining_axes/#","page":"Combining Axes","title":"Combining Axes","text":"julia> using AxisIndices\n\njulia> a = ones(3);\n\njulia> b = AxisIndicesArray(a, 2:4);\n\njulia> c = AxisIndicesArray(a, [\"1\", \"2\", \"3\"]);","category":"page"},{"location":"combining_axes/#","page":"Combining Axes","title":"Combining Axes","text":"We assume the lack of a formal axis defined in a indicates that it's keys are unimportant. Therefore, we freely choose any keys that are formally defined elsewhere to belong to the new result of a broadcast statement. This is the kind of behavior one gets from standard type promotion.","category":"page"},{"location":"combining_axes/#","page":"Combining Axes","title":"Combining Axes","text":"julia> axes_keys(a .+ b)\n(UnitMRange(2:4),)\n\njulia> axes_keys(b .+ a)\n(UnitMRange(2:4),)\n\njulia> axes_keys(a .+ c)\n([\"1\", \"2\", \"3\"],)\n\njulia> axes_keys(c .+ a)\n([\"1\", \"2\", \"3\"],)","category":"page"},{"location":"combining_axes/#","page":"Combining Axes","title":"Combining Axes","text":"However, when we do the same with b and c they both have formally defined keys.","category":"page"},{"location":"combining_axes/#","page":"Combining Axes","title":"Combining Axes","text":"julia> axes_keys(b .+ c)\n([\"2\", \"3\", \"4\"],)\n\njulia> axes_keys(c .+ b)\n([\"1\", \"2\", \"3\"],)","category":"page"},{"location":"combining_axes/#","page":"Combining Axes","title":"Combining Axes","text":"Notice that all outputs become elements of String and a collection that are Vector. We can't depend upon the default promotion in base (e.g., promote(x, y)) because some keys won't have promote_rule defined for two key types. It may not be appropriate to define a promotion rule between something like Int and String in the base Julia library because there is not universally meaningful way to promote it without context. In this instance we clearly want to apply some sort of label along an axis and that label may or may not be intended to parse as an Int, so we always default to broadcasting the key type that is not a subtype of Real.","category":"page"},{"location":"combining_axes/#","page":"Combining Axes","title":"Combining Axes","text":"julia> d = AxisIndicesArray(a, [:a, :b, :c]);\n\njulia> axes_keys(a .+ d, 1) == [:a, :b, :c]\ntrue","category":"page"},{"location":"combining_axes/#","page":"Combining Axes","title":"Combining Axes","text":"The term key specific promotion is used because it is only sensible in the context of keys.","category":"page"},{"location":"combining_axes/#","page":"Combining Axes","title":"Combining Axes","text":"Finally, if both key types are non Real then order of arguments determines promotion.","category":"page"},{"location":"combining_axes/#","page":"Combining Axes","title":"Combining Axes","text":"julia> axes_keys(c .+ d)\n([\"1\", \"2\", \"3\"],)\n\njulia> axes_keys(d .+ c, 1) == [:a, :b, :c]\ntrue","category":"page"},{"location":"combining_axes/#","page":"Combining Axes","title":"Combining Axes","text":"Customizing broadcasting behavior should be accomplished through either AxisIndices.CombineStyle or AxisIndices.broadcast_axis.","category":"page"},{"location":"internal_api/#Internal-API-1","page":"Internal API","title":"Internal API","text":"","category":"section"},{"location":"internal_api/#","page":"Internal API","title":"Internal API","text":"AxisIndices.unsafe_reconstruct\nAxisIndices.step_key\nAxisIndices.values_type\nAxisIndices.permute_axes\nAxisIndices.append_axis!\nAxisIndices.broadcast_axis\nAxisIndices.matmul_axes\nAxisIndices.drop_axes\nAxisIndices.cat_axis\nAxisIndices.cat_axes\nAxisIndices.get_formatters\nAxisIndices.CombineStyle\nAxisIndices.CombineAxis\nAxisIndices.CombineSimpleAxis\nAxisIndices.CombineResize\nAxisIndices.CombineStack\n\nAxisIndices.AxisIndicesStyle\nAxisIndices.KeyElement\nAxisIndices.IndexElement\nAxisIndices.BoolElement\nAxisIndices.CartesianElement\nAxisIndices.KeysCollection\nAxisIndices.IndicesCollection\nAxisIndices.IntervalCollection\nAxisIndices.BoolsCollection\nAxisIndices.KeysIn\nAxisIndices.IndicesIn\nAxisIndices.KeyEquals\nAxisIndices.IndexEquals\nAxisIndices.KeysFix2\nAxisIndices.IndicesFix2\nAxisIndices.SliceCollection\nAxisIndices.is_element\nAxisIndices.is_index\nAxisIndices.is_collection\nAxisIndices.is_key\nAxisIndices.to_index\nAxisIndices.to_keys\nAxisIndices.get_factorization","category":"page"},{"location":"internal_api/#AxisIndices.AxisCore.unsafe_reconstruct","page":"Internal API","title":"AxisIndices.AxisCore.unsafe_reconstruct","text":"unsafe_reconstruct(axis::AbstractAxis, keys::Ks, values::Vs)\n\nReconstructs an AbstractAxis of the same type as axis but with keys of type Ks and values of type Vs. This method is considered unsafe because it bypasses checks  to ensure that keys and values have the same length and the all keys are unique.\n\n\n\n\n\nunsafe_reconstruct(axis::AbstractSimpleAxis, values::Vs)\n\nReconstructs an AbstractSimpleAxis of the same type as axis but values of type Vs.\n\n\n\n\n\nunsafe_reconstruct(A::AbstractAxisIndices, parent, axes)\n\nReconstructs an AbstractAxisIndices of the same type as A but with the parent array parent and axes axes. This method depends on an underlying call to similar_types. It is considered unsafe because it bypasses safety checks to ensure the keys of each axis are unique and match the length of each dimension of parent. Therefore, this is not intended for interactive use and should only be used when it is clear all arguments are composed correctly.\n\n\n\n\n\n","category":"function"},{"location":"internal_api/#AxisIndices.AxisCore.step_key","page":"Internal API","title":"AxisIndices.AxisCore.step_key","text":"step_key(x)\n\nReturns the step size of the keys of x.\n\nExamples\n\njulia> using AxisIndices\n\njulia> AxisIndices.step_key(Axis(1:2:10))\n2\n\njulia> AxisIndices.step_key(rand(2))\n1\n\njulia> AxisIndices.step_key([1])  # LinearIndices are treate like unit ranges\n1\n\n\n\n\n\n","category":"function"},{"location":"internal_api/#AxisIndices.AxisCore.values_type","page":"Internal API","title":"AxisIndices.AxisCore.values_type","text":"values_type(x)\n\nRetrieves the type of the values of x. This should be functionally equivalent to typeof(values(x)).\n\nExamples\n\njulia> using AxisIndices\n\njulia>  values_type(Axis(1:2))\nBase.OneTo{Int64}\n\njulia> values_type(typeof(Axis(1:2)))\nBase.OneTo{Int64}\n\njulia> values_type(typeof(1:2))\nUnitRange{Int64}\n\n\n\n\n\nvalues_type(x, i)\n\nRetrieves axis values of the ith dimension of x.\n\nExamples\n\njulia> using AxisIndices\n\njulia> values_type([1], 1)\nBase.OneTo{Int64}\n\njulia> values_type(typeof([1]), 1)\nBase.OneTo{Int64}\n\n\n\n\n\n","category":"function"},{"location":"internal_api/#AxisIndices.AxisCore.permute_axes","page":"Internal API","title":"AxisIndices.AxisCore.permute_axes","text":"permute_axes(x::AbstractArray, perms::Tuple) = permute_axes(axes(x), p)\npermute_axes(x::NTuple{N}, perms::NTuple{N}) -> NTuple{N}\n\nReturns axes of x in the order of p.\n\nExamples\n\njulia> using AxisIndices\n\njulia> AxisIndices.permute_axes(rand(2, 4, 6), (1, 3, 2))\n(Base.OneTo(2), Base.OneTo(6), Base.OneTo(4))\n\njulia> AxisIndices.permute_axes((Axis(1:2), Axis(1:4), Axis(1:6)), (1, 3, 2))\n(Axis(1:2 => Base.OneTo(2)), Axis(1:6 => Base.OneTo(6)), Axis(1:4 => Base.OneTo(4)))\n\n\n\n\n\n\npermute_axes(x::AbstractVector)\n\nReturns the permuted axes of x as axes of size 1 × length(x)\n\nExamples\n\njulia> using AxisIndices\n\njulia> length.(AxisIndices.permute_axes(rand(4))) == (1, 4)\ntrue\n\njulia> AxisIndices.permute_axes((Axis(1:4),))\n(SimpleAxis(Base.OneTo(1)), Axis(1:4 => Base.OneTo(4)))\n\njulia> AxisIndices.permute_axes((Axis(mrange(1, 4)),))\n(SimpleAxis(OneToMRange(1)), Axis(UnitMRange(1:4) => OneToMRange(4)))\n\njulia> AxisIndices.permute_axes((Axis(srange(1, 4)),))\n(SimpleAxis(OneToSRange(1)), Axis(UnitSRange(1:4) => OneToSRange(4)))\n\n\n\n\n\n\npermute_axes(m::AbstractMatrix) -> NTuple{2}\n\nPermute the axes of the matrix m, by flipping the elements across the diagonal of the matrix. Differs from LinearAlgebra's transpose in that the operation is not recursive.\n\nExamples\n\njulia> using AxisIndices\n\njulia> AxisIndices.permute_axes(rand(4, 2))\n(Base.OneTo(2), Base.OneTo(4))\n\njulia> AxisIndices.permute_axes((Axis(1:4), Axis(1:2)))\n(Axis(1:2 => Base.OneTo(2)), Axis(1:4 => Base.OneTo(4)))\n\n\n\n\n\n\n","category":"function"},{"location":"internal_api/#AxisIndices.AxisCore.append_axis!","page":"Internal API","title":"AxisIndices.AxisCore.append_axis!","text":"append_axis!(x, y)\nappend_axis!(::CombineStyle, x, y)\n\nReturns the appended axes x and y.\n\nExamples\n\njulia> using AxisIndices\n\njulia> x, y = Axis(UnitMRange(1, 10)), SimpleAxis(UnitMRange(1, 10));\n\njulia> AxisIndices.append_axis!(x, y);\n\njulia> length(x)\n20\n\njulia> AxisIndices.append_axis!(y, x);\n\njulia> length(y)\n30\n\n\n\n\n\n","category":"function"},{"location":"internal_api/#AxisIndices.AxisCore.broadcast_axis","page":"Internal API","title":"AxisIndices.AxisCore.broadcast_axis","text":"broadcast_axis(x, y) -> collection\nbroadcast_axis(::PromoteStyle, ::CombineStyle, x, y)\n\nReturns an axis given the axes x and y that are appropriate for a broadcasting operation.\n\nExamples\n\njulia> using AxisIndices\n\njulia> a, b = 1:10, Base.OneTo(10);\n\njulia> AxisIndices.broadcast_axis(a, SimpleAxis(b))\nSimpleAxis(1:10)\n\njulia> AxisIndices.broadcast_axis(a, b)\n1:10\n\njulia> AxisIndices.broadcast_axis(b, a)\n1:10\n\njulia> c = AxisIndices.broadcast_axis(a, SimpleAxis(b))\nSimpleAxis(1:10)\n\njulia> d = AxisIndices.broadcast_axis(SimpleAxis(b), a)\nSimpleAxis(1:10)\n\njulia> e = AxisIndices.broadcast_axis(c, d)\nSimpleAxis(1:10)\n\njulia> f = AxisIndices.broadcast_axis(Axis(a), a)\nAxis(1:10 => 1:10)\n\njulia> g = AxisIndices.broadcast_axis(a, Axis(b))\nAxis(Base.OneTo(10) => 1:10)\n\njulia> AxisIndices.broadcast_axis(f, g)\nAxis(1:10 => 1:10)\n\njulia> AxisIndices.broadcast_axis(Base.OneTo(10), Base.OneTo(10))\nBase.OneTo(10)\n\njulia> AxisIndices.broadcast_axis(1:10, Base.OneTo(10))\n1:10\n\nUsing combine allows combining axes that aren't appropriate for conventional promotion.\n\njulia> AxisIndices.broadcast_axis(1:2, string.(1:2))\n2-element Array{String,1}:\n \"1\"\n \"2\"\n\njulia> AxisIndices.broadcast_axis(1:2, Symbol.(1:2))\n2-element Array{Symbol,1}:\n Symbol(\"1\")\n Symbol(\"2\")\n\n\n\n\n\n","category":"function"},{"location":"internal_api/#AxisIndices.Math.matmul_axes","page":"Internal API","title":"AxisIndices.Math.matmul_axes","text":"matmul_axes(a, b) -> Tuple\n\nReturns the appropriate axes for the return of a * b where a and b are a vector or matrix.\n\nExamples\n\njulia> using AxisIndices\n\njulia> axs2, axs1 = (Axis(1:2), Axis(1:4)), (Axis(1:6),);\n\njulia> AxisIndices.matmul_axes(axs2, axs2)\n(Axis(1:2 => Base.OneTo(2)), Axis(1:4 => Base.OneTo(4)))\n\njulia> AxisIndices.matmul_axes(axs1, axs2)\n(Axis(1:6 => Base.OneTo(6)), Axis(1:4 => Base.OneTo(4)))\n\njulia> AxisIndices.matmul_axes(axs2, axs1)\n(Axis(1:2 => Base.OneTo(2)),)\n\njulia> AxisIndices.matmul_axes(axs1, axs1)\n()\n\njulia> AxisIndices.matmul_axes(rand(2, 4), rand(4, 2))\n(SimpleAxis(Base.OneTo(2)), SimpleAxis(Base.OneTo(2)))\n\njulia> AxisIndices.matmul_axes(CartesianAxes((2,4)), CartesianAxes((4, 2))) == AxisIndices.matmul_axes(rand(2, 4), rand(4, 2))\ntrue\n\n\n\n\n\n","category":"function"},{"location":"internal_api/#AxisIndices.AxisCore.drop_axes","page":"Internal API","title":"AxisIndices.AxisCore.drop_axes","text":"drop_axes(x, dims)\n\nReturns all axes of x except for those identified by dims. Elements of dims must be unique integers or symbols corresponding to the dimensions or names of dimensions of x.\n\nExamples\n\njulia> using AxisIndices\n\njulia> axs = (Axis(1:5), Axis(1:10));\n\njulia> AxisIndices.drop_axes(axs, 1)\n(Axis(1:10 => Base.OneTo(10)),)\n\njulia> AxisIndices.drop_axes(axs, 2)\n(Axis(1:5 => Base.OneTo(5)),)\n\njulia> AxisIndices.drop_axes(rand(2, 4), 2)\n(Base.OneTo(2),)\n\n\n\n\n\n","category":"function"},{"location":"internal_api/#AxisIndices.AxisCore.cat_axis","page":"Internal API","title":"AxisIndices.AxisCore.cat_axis","text":"cat_axis(x, y) -> cat_axis(CombineStyle(x, y), x, y)\ncat_axis(::CombineStyle, x, y) -> collection\n\nReturns the concatenated axes x and y.\n\nExamples\n\njulia> using AxisIndices\n\njulia> AxisIndices.cat_axis(Axis(UnitMRange(1, 10)), SimpleAxis(UnitMRange(1, 10)))\nAxis(UnitMRange(1:20) => UnitMRange(1:20))\n\njulia> AxisIndices.cat_axis(SimpleAxis(UnitMRange(1, 10)), SimpleAxis(UnitMRange(1, 10)))\nSimpleAxis(UnitMRange(1:20))\n\n\n\n\n\n","category":"function"},{"location":"internal_api/#AxisIndices.AxisCore.cat_axes","page":"Internal API","title":"AxisIndices.AxisCore.cat_axes","text":"cat_axes(x::AbstractArray, y::AbstractArray, xy::AbstractArray, dims)\n\nProduces the appropriate set of axes where x and y are the arrays that were concatenated over dims to produce xy. The appropriate indices of each axis are derived from from xy.\n\n\n\n\n\n","category":"function"},{"location":"internal_api/#AxisIndices.PrettyArrays.get_formatters","page":"Internal API","title":"AxisIndices.PrettyArrays.get_formatters","text":"get_formatters(x)\n\nReturns an argument for the formatters argument of a pretty_table method.\n\n\n\n\n\n","category":"function"},{"location":"internal_api/#AxisIndices.AxisCore.CombineStyle","page":"Internal API","title":"AxisIndices.AxisCore.CombineStyle","text":"CombineStyle\n\nAbstract type that determines the behavior of broadcast_axis, cat_axis, append_axis!.\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#AxisIndices.AxisCore.CombineAxis","page":"Internal API","title":"AxisIndices.AxisCore.CombineAxis","text":"CombineAxis\n\nSubtype of CombineStyle that informs relevant methods to produce a subtype of AbstractAxis.\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#AxisIndices.AxisCore.CombineSimpleAxis","page":"Internal API","title":"AxisIndices.AxisCore.CombineSimpleAxis","text":"CombineSimpleAxis\n\nSubtype of CombineStyle that informs relevant methods to produce a subtype of AbstractSimpleAxis.\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#AxisIndices.AxisCore.CombineResize","page":"Internal API","title":"AxisIndices.AxisCore.CombineResize","text":"CombineResize\n\nSubtype of CombineStyle that informs relevant methods that axes should be combined by resizing a collection (as opposed to by concatenation or appending).\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#AxisIndices.AxisCore.CombineStack","page":"Internal API","title":"AxisIndices.AxisCore.CombineStack","text":"CombineStack\n\nSubtype of CombineStyle that informs relevant methods that axes should be combined by stacking elements in some whay (as opposed to resizing a collection).\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#AxisIndices.AxisCore.AxisIndicesStyle","page":"Internal API","title":"AxisIndices.AxisCore.AxisIndicesStyle","text":"AxisIndicesStyle\n\nSupertype for traits that control the behavior of AxisIndices.to_index and AxisIndices.to_key.\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#AxisIndices.AxisCore.KeyElement","page":"Internal API","title":"AxisIndices.AxisCore.KeyElement","text":"KeyElement\n\nA subtype of AxisIndicesStyle for mapping an argument that refers to a single key to a single index.\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#AxisIndices.AxisCore.IndexElement","page":"Internal API","title":"AxisIndices.AxisCore.IndexElement","text":"IndexElement\n\nA subtype of AxisIndicesStyle for propagating an argument to a single index.\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#AxisIndices.AxisCore.BoolElement","page":"Internal API","title":"AxisIndices.AxisCore.BoolElement","text":"BoolElement\n\nA subtype of AxisIndicesStyle for mapping an argument that refers to a single Bool to a single index.\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#AxisIndices.AxisCore.CartesianElement","page":"Internal API","title":"AxisIndices.AxisCore.CartesianElement","text":"CartesianElement\n\nA subtype of AxisIndicesStyle for mapping an argument that refers to a CartesianIndex to a single index.\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#AxisIndices.AxisCore.KeysCollection","page":"Internal API","title":"AxisIndices.AxisCore.KeysCollection","text":"KeysCollection\n\nA subtype of AxisIndicesStyle for mapping a collection of keys a collection of indices.\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#AxisIndices.AxisCore.IndicesCollection","page":"Internal API","title":"AxisIndices.AxisCore.IndicesCollection","text":"IndicesCollection\n\nA subtype of AxisIndicesStyle for propagating an argument to a collection of indices.\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#AxisIndices.AxisCore.IntervalCollection","page":"Internal API","title":"AxisIndices.AxisCore.IntervalCollection","text":"IntervalCollection\n\nA subtype of AxisIndicesStyle for mapping an interval argument (start..stop) from keys within said interval to a collection of indices.\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#AxisIndices.AxisCore.BoolsCollection","page":"Internal API","title":"AxisIndices.AxisCore.BoolsCollection","text":"BoolsCollection\n\nA subtype of AxisIndicesStyle for mapping a collection of Bools to a collection of indices.\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#AxisIndices.AxisCore.KeysIn","page":"Internal API","title":"AxisIndices.AxisCore.KeysIn","text":"KeysIn\n\nA subtype of AxisIndicesStyle for mapping all keys given in(keys) to a collection of indices.\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#AxisIndices.AxisCore.IndicesIn","page":"Internal API","title":"AxisIndices.AxisCore.IndicesIn","text":"IndicesIn\n\nA subtype of AxisIndicesStyle for mapping all keys given in(keys) to a collection of indices.\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#AxisIndices.AxisCore.KeyEquals","page":"Internal API","title":"AxisIndices.AxisCore.KeyEquals","text":"KeyEquals\n\nA subtype of AxisIndicesStyle for mapping a single key in a isequal(key) argument to a single index.\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#AxisIndices.AxisCore.IndexEquals","page":"Internal API","title":"AxisIndices.AxisCore.IndexEquals","text":"IndexEquals\n\nA subtype of AxisIndicesStyle for mapping a single index in a isequal(index) argument to a single index.\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#AxisIndices.AxisCore.KeysFix2","page":"Internal API","title":"AxisIndices.AxisCore.KeysFix2","text":"KeysFix2\n\nA subtype of AxisIndicesStyle for mapping all keys from fixed argument (e.g., >(key)) to the corresponding collection of indices.\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#AxisIndices.AxisCore.IndicesFix2","page":"Internal API","title":"AxisIndices.AxisCore.IndicesFix2","text":"IndicesFix2\n\nA subtype of AxisIndicesStyle for mapping all indices from fixed argument (e.g., >(indices)) to the corresponding collection of indices.\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#AxisIndices.AxisCore.SliceCollection","page":"Internal API","title":"AxisIndices.AxisCore.SliceCollection","text":"SliceCollection\n\nA subtype of AxisIndicesStyle indicating that the entire axis should be propagated.\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#AxisIndices.AxisCore.is_element","page":"Internal API","title":"AxisIndices.AxisCore.is_element","text":"is_element(x) -> Bool\n\nWhether x is an AxisIndicesStyle, returns true if it's used to index a single element.\n\n\n\n\n\n","category":"function"},{"location":"internal_api/#AxisIndices.AxisCore.is_index","page":"Internal API","title":"AxisIndices.AxisCore.is_index","text":"is_index(x) -> Bool\n\nWhether x is an AxisIndicesStyle, returns true if it's used to search the indices space.\n\n\n\n\n\n","category":"function"},{"location":"internal_api/#AxisIndices.AxisCore.is_collection","page":"Internal API","title":"AxisIndices.AxisCore.is_collection","text":"is_collection(x) -> Bool\n\nWhether x is an AxisIndicesStyle, returns true if it's used to index a collection of indices.\n\n\n\n\n\n","category":"function"},{"location":"internal_api/#AxisIndices.AxisCore.is_key","page":"Internal API","title":"AxisIndices.AxisCore.is_key","text":"is_key(x) -> Bool\n\nWhether x is an AxisIndicesStyle, returns true if it's used to search the keys space.\n\n\n\n\n\n","category":"function"},{"location":"internal_api/#AxisIndices.AxisCore.to_index","page":"Internal API","title":"AxisIndices.AxisCore.to_index","text":"to_index(axis, arg) -> to_index(AxisIndicesStyle(axis, arg), axis, arg)\n\nUnique implementation of to_index for the AxisIndices package that specializes based on each axis and indexing argument (as opposed to the array and indexing argument).\n\n\n\n\n\n","category":"function"},{"location":"internal_api/#AxisIndices.AxisCore.to_keys","page":"Internal API","title":"AxisIndices.AxisCore.to_keys","text":"to_keys([::AxisIndicesStyle,] axis, arg, index)\n\nThis method is the reverse of AxisIndices.to_index. arg refers to an argument originally passed to AxisIndices.to_index and index refers to the index produced by that same call to AxisIndices.to_index.\n\nThis method assumes to all arguments have passed through AxisIndices.to_index and have been checked to be in bounds. Therefore, this is unsafe and intended only for internal use.\n\n\n\n\n\n","category":"function"},{"location":"internal_api/#AxisIndices.Math.get_factorization","page":"Internal API","title":"AxisIndices.Math.get_factorization","text":"get_factorization(F::Factorization, A::AbstractArray, d::Symbol)\n\nUsed internally to compose an AxisIndicesArray for each component of a factor decomposition. F is the result of decomposition, A is an arry (likely a subtype of AbstractAxisIndices), and d is a symbol referring to a component of the factorization.\n\n\n\n\n\n","category":"function"},{"location":"time/#TimeAxis-Guide-1","page":"TimeAxis Guide","title":"TimeAxis Guide","text":"","category":"section"},{"location":"time/#","page":"TimeAxis Guide","title":"TimeAxis Guide","text":"Here we define an axis that specifically supports time. First, we compose the type and necessary methods for accessing it's properties and constructing it. Second, we define a new trait that changes indexing.","category":"page"},{"location":"time/#.-The-TimeAxis-Type-1","page":"TimeAxis Guide","title":"1. The TimeAxis Type","text":"","category":"section"},{"location":"time/#","page":"TimeAxis Guide","title":"TimeAxis Guide","text":"This first section defines the minimum keys, values, similar_type and constructors for the TimeAxis type.","category":"page"},{"location":"time/#","page":"TimeAxis Guide","title":"TimeAxis Guide","text":"julia> using AxisIndices, Dates, Unitful\n\njulia> struct TimeAxis{K,V,Ks,Vs} <: AbstractAxis{K,V,Ks,Vs}\n           axis::Axis{K,V,Ks,Vs}\n           times::Dict{Symbol,Any}\n           function TimeAxis{K,V,Ks,Vs}(axis::Axis{K,V,Ks,Vs}, times::Dict{Symbol,Pair{K,K}}) where {K,V,Ks,Vs}\n               return new{K,V,Ks,Vs}(axis, times)\n           end\n           function TimeAxis{K,V,Ks,Vs}(args...; kwargs...) where {K,V,Ks,Vs}\n               d = Dict{Symbol,Pair{K,K}}()\n               for (k,v) in kwargs\n                   d[k] = v\n               end\n               return new{K,V,Ks,Vs}(Axis{K,V,Ks,Vs}(args...), d)\n           end\n           function TimeAxis(args...; kwargs...)\n               ax = Axis(args...)\n               d = Dict{Symbol,Pair{keytype(ax),keytype(ax)}}()\n               for (k,v) in kwargs\n                   d[k] = v\n               end\n               return new{keytype(ax),valtype(ax),keys_type(ax),values_type(ax)}(ax, d)\n           end\n       end\n\njulia> Base.keys(t::TimeAxis) = keys(getfield(t, :axis))\n\njulia> Base.values(t::TimeAxis) = values(getfield(t, :axis))\n\njulia> function AxisIndices.similar_type(\n           t::TimeAxis{K,V,Ks,Vs},\n           new_keys_type::Type=Ks,\n           new_values_type::Type=Vs\n       ) where {K,V,Ks,Vs}\n           return TimeAxis{eltype(new_keys_type),eltype(new_values_type),new_keys_type,new_values_type}\n       end","category":"page"},{"location":"time/#.-The-TimeStampCollection-Trait-1","page":"TimeAxis Guide","title":"2. The TimeStampCollection Trait","text":"","category":"section"},{"location":"time/#","page":"TimeAxis Guide","title":"TimeAxis Guide","text":"Not only do we want to store discrete intervals of time with labels in the axis, but we want to reference them in a very simple way for indexing. In other words, if we have previously assigned :time1 the interval of 1 to 3 seconds, then we should be able to do axis[:time1] to index the axis instead of doing axis[axis.times[:time1]]. However, the default indexing behavior is to look for a Symbol in the keys of an axis. We want to tell the indexing pipeline that when we provide a Symbol with a TimeAxis we want to lookup the argument in axis.times and then pass the result to the typical indexing protocol. So we make a new trait that for this.","category":"page"},{"location":"time/#","page":"TimeAxis Guide","title":"TimeAxis Guide","text":"julia> Base.setindex!(t::TimeAxis, val, i::Symbol) = t.times[i] = val\n\njulia> struct TimeStampCollection <: AxisIndices.AxisIndicesStyle end\n\njulia> AxisIndices.is_element(::Type{TimeStampCollection}) = false\n\njulia> function AxisIndices.AxisIndicesStyle(::Type{<:TimeAxis}, ::Type{Symbol})\n           return TimeStampCollection()\n       end\n\njulia> function AxisIndices.to_index(::TimeStampCollection, axis, arg)\n           return AxisIndices.to_index(t.axis, t.times[arg])\n       end\n\njulia> function AxisIndices.to_keys(::TimeStampCollection, axis, arg, index)\n           return AxisIndices.to_keys(t.axis, t.times[arg], index)\n       end","category":"page"},{"location":"time/#TimeAxis-in-Action-1","page":"TimeAxis Guide","title":"TimeAxis in Action","text":"","category":"section"},{"location":"time/#","page":"TimeAxis Guide","title":"TimeAxis Guide","text":"Now we can access the time points of this access by the Symbols that correspond to intervals of time.","category":"page"},{"location":"time/#","page":"TimeAxis Guide","title":"TimeAxis Guide","text":"julia> t = TimeAxis(Second(1):Second(1):Second(10));\n\njulia> t[:time_1] = Second(1):Second(1):Second(3);\n\njulia> t[:time_1] == 1:3\ntrue\n","category":"page"},{"location":"time/#","page":"TimeAxis Guide","title":"TimeAxis Guide","text":"This can also be done with Unitful elements.","category":"page"},{"location":"time/#","page":"TimeAxis Guide","title":"TimeAxis Guide","text":"julia> using Unitful: s\n\njulia> t2 = TimeAxis((1:10)s);\n\njulia> t2[:time_1] = 1s..3s;\n\njulia> t[:time_1] == 1:3\ntrue\n","category":"page"},{"location":"time/#","page":"TimeAxis Guide","title":"TimeAxis Guide","text":"This can naturally turn any array that is an AbstractAxisIndices subtype into a collection of time series data.","category":"page"},{"location":"time/#","page":"TimeAxis Guide","title":"TimeAxis Guide","text":"julia> x = AxisIndicesArray(collect(1:2:20), t);\n\njulia> x[:time_1]\nAxisIndicesArray{Int64,1,Array{Int64,1}...}\n • dim_1 - TimeAxis(1 second:1 second:3 seconds => Base.OneTo(3))\n\n   1 second   1\n  2 seconds   3\n  3 seconds   5\n\n","category":"page"},{"location":"experimental/#Experimental-1","page":"Experimental API","title":"Experimental","text":"","category":"section"},{"location":"experimental/#","page":"Experimental API","title":"Experimental API","text":"Currently there are several experimental modules included. Methods from these modules are not exported by default but may be accessed by using AxisIndices.<NameOfExperimentalModule> These are considered experimental because the are either undergoing rapid change, are likely to end up in a different package entirely, or both.","category":"page"},{"location":"experimental/#ObservationDims-1","page":"Experimental API","title":"ObservationDims","text":"","category":"section"},{"location":"experimental/#","page":"Experimental API","title":"Experimental API","text":"Modules = [AxisIndices.ObservationDims]","category":"page"},{"location":"experimental/#AxisIndices.ObservationDims.has_obsdim-Tuple{Any}","page":"Experimental API","title":"AxisIndices.ObservationDims.has_obsdim","text":"has_obsdim(x) -> Bool\n\nReturns true if x has a dimension corresponding to obs.\n\n\n\n\n\n","category":"method"},{"location":"experimental/#AxisIndices.ObservationDims.nobs-Tuple{Any}","page":"Experimental API","title":"AxisIndices.ObservationDims.nobs","text":"nobs(x) -> Int\n\nReturns the size along the dimension corresponding to the obs.\n\n\n\n\n\n","category":"method"},{"location":"experimental/#AxisIndices.ObservationDims.obs_axis-Tuple{Any}","page":"Experimental API","title":"AxisIndices.ObservationDims.obs_axis","text":"obs_axis(x)\n\nReturns the axis corresponding to the obs dimension.\n\n\n\n\n\n","category":"method"},{"location":"experimental/#AxisIndices.ObservationDims.obs_axis_type-Tuple{Any}","page":"Experimental API","title":"AxisIndices.ObservationDims.obs_axis_type","text":"obs_axis_type(x)\n\nReturns the key type corresponding to the obs axis.\n\n\n\n\n\n","category":"method"},{"location":"experimental/#AxisIndices.ObservationDims.obs_indices-Tuple{Any}","page":"Experimental API","title":"AxisIndices.ObservationDims.obs_indices","text":"obs_indices(x)\n\nReturns the indices corresponding to the obs axis\n\n\n\n\n\n","category":"method"},{"location":"experimental/#AxisIndices.ObservationDims.obs_keys-Tuple{Any}","page":"Experimental API","title":"AxisIndices.ObservationDims.obs_keys","text":"obs_keys(x)\n\nReturns the keys corresponding to the obs axis\n\n\n\n\n\n","category":"method"},{"location":"experimental/#AxisIndices.ObservationDims.obsdim-Tuple{Any}","page":"Experimental API","title":"AxisIndices.ObservationDims.obsdim","text":"obsdim(x) -> Int\n\nReturns the dimension corresponding to the obs.\n\n\n\n\n\n","category":"method"},{"location":"experimental/#AxisIndices.ObservationDims.select_obsdim-Tuple{Any,Any}","page":"Experimental API","title":"AxisIndices.ObservationDims.select_obsdim","text":"select_obsdim(x, i)\n\nReturn x view of all the data of x where the index for the obs dimension equals i.\n\n\n\n\n\n","category":"method"},{"location":"experimental/#TimeDims-1","page":"Experimental API","title":"TimeDims","text":"","category":"section"},{"location":"experimental/#","page":"Experimental API","title":"Experimental API","text":"Modules = [AxisIndices.TimeDims]","category":"page"},{"location":"experimental/#AxisIndices.TimeDims.duration-Tuple{Any}","page":"Experimental API","title":"AxisIndices.TimeDims.duration","text":"duration(x)\n\nDuration of the event along the time axis.\n\n\n\n\n\n","category":"method"},{"location":"experimental/#AxisIndices.TimeDims.has_timedim-Tuple{Any}","page":"Experimental API","title":"AxisIndices.TimeDims.has_timedim","text":"has_timedim(x) -> Bool\n\nReturns true if x has a dimension corresponding to time.\n\n\n\n\n\n","category":"method"},{"location":"experimental/#AxisIndices.TimeDims.ntime-Tuple{Any}","page":"Experimental API","title":"AxisIndices.TimeDims.ntime","text":"ntime(x) -> Int\n\nReturns the size along the dimension corresponding to the time.\n\n\n\n\n\n","category":"method"},{"location":"experimental/#AxisIndices.TimeDims.onset-Tuple{Any}","page":"Experimental API","title":"AxisIndices.TimeDims.onset","text":"onset(x)\n\nFirst time point along the time axis.\n\n\n\n\n\n","category":"method"},{"location":"experimental/#AxisIndices.TimeDims.sampling_rate-Tuple{Any}","page":"Experimental API","title":"AxisIndices.TimeDims.sampling_rate","text":"sampling_rate(x)\n\nNumber of samples per second.\n\n\n\n\n\n","category":"method"},{"location":"experimental/#AxisIndices.TimeDims.select_timedim-Tuple{Any,Any}","page":"Experimental API","title":"AxisIndices.TimeDims.select_timedim","text":"select_timedim(x, i)\n\nReturn x view of all the data of x where the index for the time dimension equals i.\n\n\n\n\n\n","category":"method"},{"location":"experimental/#AxisIndices.TimeDims.time_axis-Tuple{Any}","page":"Experimental API","title":"AxisIndices.TimeDims.time_axis","text":"time_axis(x)\n\nReturns the axis corresponding to the time dimension.\n\n\n\n\n\n","category":"method"},{"location":"experimental/#AxisIndices.TimeDims.time_axis_type-Tuple{Any}","page":"Experimental API","title":"AxisIndices.TimeDims.time_axis_type","text":"time_axis_type(x)\n\nReturns the key type corresponding to the time axis.\n\n\n\n\n\n","category":"method"},{"location":"experimental/#AxisIndices.TimeDims.time_end-Tuple{Any}","page":"Experimental API","title":"AxisIndices.TimeDims.time_end","text":"time_end(x)\n\nLast time point along the time axis.\n\n\n\n\n\n","category":"method"},{"location":"experimental/#AxisIndices.TimeDims.time_indices-Tuple{Any}","page":"Experimental API","title":"AxisIndices.TimeDims.time_indices","text":"time_indices(x)\n\nReturns the indices corresponding to the time axis\n\n\n\n\n\n","category":"method"},{"location":"experimental/#AxisIndices.TimeDims.time_keys-Tuple{Any}","page":"Experimental API","title":"AxisIndices.TimeDims.time_keys","text":"time_keys(x)\n\nReturns the keys corresponding to the time axis\n\n\n\n\n\n","category":"method"},{"location":"experimental/#AxisIndices.TimeDims.timedim-Tuple{Any}","page":"Experimental API","title":"AxisIndices.TimeDims.timedim","text":"timedim(x) -> Int\n\nReturns the dimension corresponding to the time.\n\n\n\n\n\n","category":"method"},{"location":"experimental/#ColorDims-1","page":"Experimental API","title":"ColorDims","text":"","category":"section"},{"location":"experimental/#","page":"Experimental API","title":"Experimental API","text":"Modules = [AxisIndices.ColorDims]","category":"page"},{"location":"experimental/#AxisIndices.ColorDims.color_axis-Tuple{Any}","page":"Experimental API","title":"AxisIndices.ColorDims.color_axis","text":"color_axis(x)\n\nReturns the axis corresponding to the color dimension.\n\n\n\n\n\n","category":"method"},{"location":"experimental/#AxisIndices.ColorDims.color_axis_type-Tuple{Any}","page":"Experimental API","title":"AxisIndices.ColorDims.color_axis_type","text":"color_axis_type(x)\n\nReturns the key type corresponding to the color axis.\n\n\n\n\n\n","category":"method"},{"location":"experimental/#AxisIndices.ColorDims.color_indices-Tuple{Any}","page":"Experimental API","title":"AxisIndices.ColorDims.color_indices","text":"color_indices(x)\n\nReturns the indices corresponding to the color axis\n\n\n\n\n\n","category":"method"},{"location":"experimental/#AxisIndices.ColorDims.color_keys-Tuple{Any}","page":"Experimental API","title":"AxisIndices.ColorDims.color_keys","text":"color_keys(x)\n\nReturns the keys corresponding to the color axis\n\n\n\n\n\n","category":"method"},{"location":"experimental/#AxisIndices.ColorDims.colordim-Tuple{Any}","page":"Experimental API","title":"AxisIndices.ColorDims.colordim","text":"colordim(x) -> Int\n\nReturns the dimension corresponding to the color.\n\n\n\n\n\n","category":"method"},{"location":"experimental/#AxisIndices.ColorDims.has_colordim-Tuple{Any}","page":"Experimental API","title":"AxisIndices.ColorDims.has_colordim","text":"has_colordim(x) -> Bool\n\nReturns true if x has a dimension corresponding to color.\n\n\n\n\n\n","category":"method"},{"location":"experimental/#AxisIndices.ColorDims.ncolor-Tuple{Any}","page":"Experimental API","title":"AxisIndices.ColorDims.ncolor","text":"ncolor(x) -> Int\n\nReturns the size along the dimension corresponding to the color.\n\n\n\n\n\n","category":"method"},{"location":"experimental/#AxisIndices.ColorDims.select_colordim-Tuple{Any,Any}","page":"Experimental API","title":"AxisIndices.ColorDims.select_colordim","text":"select_colordim(x, i)\n\nReturn x view of all the data of x where the index for the color dimension equals i.\n\n\n\n\n\n","category":"method"},{"location":"experimental/#SpatialDims-1","page":"Experimental API","title":"SpatialDims","text":"","category":"section"},{"location":"experimental/#","page":"Experimental API","title":"Experimental API","text":"Modules = [AxisIndices.SpatialDims]","category":"page"},{"location":"experimental/#AxisIndices.SpatialDims.pixel_spacing-Tuple{Any}","page":"Experimental API","title":"AxisIndices.SpatialDims.pixel_spacing","text":"pixel_spacing(x)\n\nReturn a tuple representing the separation between adjacent pixels along each axis of the image. Derived from the step size of each element of spatial_keys.\n\n\n\n\n\n","category":"method"},{"location":"experimental/#AxisIndices.SpatialDims.spatial_axes-Tuple{Any}","page":"Experimental API","title":"AxisIndices.SpatialDims.spatial_axes","text":"spatial_axes(x) -> Tuple\n\nReturns a tuple of each axis corresponding to a spatial dimensions.\n\n\n\n\n\n","category":"method"},{"location":"experimental/#AxisIndices.SpatialDims.spatial_indices-Tuple{Any}","page":"Experimental API","title":"AxisIndices.SpatialDims.spatial_indices","text":"spatial_indices(x)\n\nReturn a tuple with the indices of the spatial dimensions of the image. Defaults to the same as indices, but using NamedDimsArrah you can mark some axes as being non-spatial.\n\n\n\n\n\n","category":"method"},{"location":"experimental/#AxisIndices.SpatialDims.spatial_keys-Tuple{Any}","page":"Experimental API","title":"AxisIndices.SpatialDims.spatial_keys","text":"spatial_keys(x)\n\n\n\n\n\n","category":"method"},{"location":"experimental/#AxisIndices.SpatialDims.spatial_offset-Tuple{Any}","page":"Experimental API","title":"AxisIndices.SpatialDims.spatial_offset","text":"spatial_offset(x)\n\nThe offset of each dimension (i.e., where each spatial axis starts).\n\n\n\n\n\n","category":"method"},{"location":"experimental/#AxisIndices.SpatialDims.spatial_order-Union{Tuple{X}, Tuple{X}} where X","page":"Experimental API","title":"AxisIndices.SpatialDims.spatial_order","text":"spatial_order(x) -> Tuple{Vararg{Symbol}}\n\nReturns the dimnames of x that correspond to spatial dimensions.\n\n\n\n\n\n","category":"method"},{"location":"experimental/#AxisIndices.SpatialDims.spatial_size-Tuple{Any}","page":"Experimental API","title":"AxisIndices.SpatialDims.spatial_size","text":"spatial_size(x) -> Tuple{Vararg{Int}}\n\nReturn a tuple listing the sizes of the spatial dimensions of the image.\n\n\n\n\n\n","category":"method"},{"location":"experimental/#AxisIndices.SpatialDims.spatialdims-Tuple{Any}","page":"Experimental API","title":"AxisIndices.SpatialDims.spatialdims","text":"spatialdims(x) -> Tuple{Vararg{Int}}\n\nReturn a tuple listing the spatial dimensions of img. Note that a better strategy may be to use ImagesAxes and take slices along the time axis.\n\n\n\n\n\n","category":"method"},{"location":"standard_library_api/#Standard-Library-API-1","page":"Standard Library API","title":"Standard Library API","text":"","category":"section"},{"location":"standard_library_api/#","page":"Standard Library API","title":"Standard Library API","text":"similar\nrot180\nrotr90\nrotl90\ndeleteat!\nsvd\nqr\nlu\nlq\ninv\ncov\ncor\ndiag","category":"page"},{"location":"standard_library_api/#Base.similar","page":"Standard Library API","title":"Base.similar","text":"similar(axis::AbstractAxis, new_keys::AbstractVector) -> AbstractAxis\n\nCreate a new instance of an axis of the same type as axis but with the keys new_keys\n\nExamples\n\njulia> using AxisIndices\n\njulia> similar(Axis(1.0:10.0, 1:10), [:one, :two])\nAxis([:one, :two] => 1:2)\n\n\n\n\n\nsimilar(axis::AbstractAxis, new_keys::AbstractVector, new_indices::AbstractUnitRange{Integer} [, check_length::Bool=true] ) -> AbstractAxis\n\nCreate a new instance of an axis of the same type as axis but with the keys new_keys and indices new_indices. If check_length is true then the lengths of new_keys and new_indices are checked to ensure they have the same length before construction.\n\nExamples\n\njulia> using AxisIndices\n\njulia> similar(Axis(1.0:10.0, 1:10), [:one, :two], UInt(1):UInt(2))\nAxis([:one, :two] => 0x0000000000000001:0x0000000000000002)\n\njulia> similar(Axis(1.0:10.0, 1:10), [:one, :two], UInt(1):UInt(3))\nERROR: keys and indices must have same length, got length(keys) = 2 and length(indices) = 3.\n[...]\n\n\n\n\n\nsimilar(axis::AbstractSimpleAxis, new_indices::AbstractUnitRange{Integer}) -> AbstractSimpleAxis\n\nCreate a new instance of an axis of the same type as axis but with the keys new_keys\n\nExamples\n\njulia> using AxisIndices\n\njulia> similar(SimpleAxis(1:10), 1:3)\nSimpleAxis(1:3)\n\n\n\n\n\n","category":"function"},{"location":"standard_library_api/#Base.rot180","page":"Standard Library API","title":"Base.rot180","text":"rot180(A::AbstractAxisIndices)\n\nRotate A 180 degrees, along with its axes keys.\n\nExamples\n\njulia> using AxisIndices\n\njulia> a = AxisIndicesArray([1 2; 3 4], [\"a\", \"b\"], [\"one\", \"two\"]);\n\njulia> b = rot180(a);\n\njulia> axes_keys(b)\n([\"b\", \"a\"], [\"two\", \"one\"])\n\njulia> c = rotr90(rotr90(a));\n\njulia> axes_keys(c)\n([\"b\", \"a\"], [\"two\", \"one\"])\n\njulia> a[\"a\", \"one\"] == b[\"a\", \"one\"] == c[\"a\", \"one\"]\ntrue\n\n\n\n\n\n","category":"function"},{"location":"standard_library_api/#Base.rotr90","page":"Standard Library API","title":"Base.rotr90","text":"rotr90(A::AbstractAxisIndices)\n\nRotate A right 90 degrees, along with its axes keys.\n\nExamples\n\njulia> using AxisIndices\n\njulia> a = AxisIndicesArray([1 2; 3 4], [\"a\", \"b\"], [\"one\", \"two\"]);\n\njulia> b = rotr90(a);\n\njulia> axes_keys(b)\n([\"one\", \"two\"], [\"b\", \"a\"])\n\njulia> a[\"a\", \"one\"] == b[\"one\", \"a\"]\ntrue\n\n\n\n\n\n","category":"function"},{"location":"standard_library_api/#Base.rotl90","page":"Standard Library API","title":"Base.rotl90","text":"rotl90(A::AbstractAxisIndices)\n\nRotate A left 90 degrees, along with its axes keys.\n\nExamples\n\njulia> using AxisIndices\n\njulia> a = AxisIndicesArray([1 2; 3 4], [\"a\", \"b\"], [\"one\", \"two\"]);\n\njulia> b = rotl90(a);\n\njulia> axes_keys(b)\n([\"two\", \"one\"], [\"a\", \"b\"])\n\njulia> a[\"a\", \"one\"] == b[\"one\", \"a\"]\ntrue\n\n\n\n\n\n\n","category":"function"},{"location":"standard_library_api/#Base.deleteat!","page":"Standard Library API","title":"Base.deleteat!","text":"deleteat!(a::AbstractAxisIndicesVector, arg)\n\nRemove the items corresponding to A[arg], and return the modified a. Subsequent items are shifted to fill the resulting gap. If the axis of a is an AbstractSimpleAxis then it is shortened to match the length of a. If the \n\nExamples\n\njulia> using AxisIndices\n\njulia> x = AxisIndicesArray([1, 2, 3, 4]);\n\njulia> axes_keys(deleteat!(x, 3))\n(OneToMRange(3),)\n\njulia> x = AxisIndicesArray([1, 2, 3, 4], [\"a\", \"b\", \"c\", \"d\"]);\n\njulia> axes_keys(deleteat!(x, \"c\"))\n([\"a\", \"b\", \"d\"],)\n\n\n\n\n\n\n","category":"function"},{"location":"standard_library_api/#LinearAlgebra.svd","page":"Standard Library API","title":"LinearAlgebra.svd","text":"svd(F::AbstractAxisArray, args...; kwargs...)\n\nCompute the singular value decomposition (SVD) of an AbstractAxisIndices A.\n\nExamples\n\njulia> using AxisIndices, LinearAlgebra\n\njulia> m = AxisIndicesArray([1.0 2; 3 4], (Axis(2:3 => Base.OneTo(2)), Axis(3:4 => Base.OneTo(2))));\n\njulia> F = svd(m);\n\njulia> axes(F.U)\n(Axis(2:3 => Base.OneTo(2)), SimpleAxis(Base.OneTo(2)))\n\njulia> axes(F.V)\n(Axis(3:4 => Base.OneTo(2)), SimpleAxis(Base.OneTo(2)))\n\njulia> axes(F.Vt)\n(SimpleAxis(Base.OneTo(2)), Axis(3:4 => Base.OneTo(2)))\n\njulia> axes(F.U * Diagonal(F.S) * F.Vt)\n(Axis(2:3 => Base.OneTo(2)), Axis(3:4 => Base.OneTo(2)))\n\n\n\n\n\n","category":"function"},{"location":"standard_library_api/#LinearAlgebra.qr","page":"Standard Library API","title":"LinearAlgebra.qr","text":"qr(F::AbstractAxisArray, args...; kwargs...)\n\nCompute the QR factorization of an AbstractAxisIndices A.\n\nExamples\n\njulia> using AxisIndices, LinearAlgebra\n\njulia> m = AxisIndicesArray([1.0 2; 3 4], (Axis(2:3 => Base.OneTo(2)), Axis(3:4 => Base.OneTo(2))));\n\njulia> F = qr(m, Val(true));\n\njulia> keys.(axes(F.Q))\n(2:3, Base.OneTo(2))\n\njulia> keys.(axes(F.R))\n(Base.OneTo(2), 3:4)\n\njulia> keys.(axes(F.Q * F.R))\n(2:3, 3:4)\n\njulia> keys.(axes(F.p))\n(2:3,)\n\njulia> keys.(axes(F.P))\n(2:3, 2:3)\n\njulia> keys.(axes(F.P * AxisIndicesArray([1.0 2; 3 4], (2:3, 3:4))))\n(2:3, 3:4)\n\n\n\n\n\n","category":"function"},{"location":"standard_library_api/#LinearAlgebra.lu","page":"Standard Library API","title":"LinearAlgebra.lu","text":"lu(A::AbstractAxisArray, args...; kwargs...)\n\nCompute the LU factorization of an AbstractAxisIndices A.\n\nExamples\n\njulia> using AxisIndices, LinearAlgebra\n\njulia> m = AxisIndicesArray([1.0 2; 3 4], (Axis(2:3 => Base.OneTo(2)), Axis(3:4 => Base.OneTo(2))));\n\njulia> F = lu(m);\n\njulia> keys.(axes(F.L))\n(2:3, Base.OneTo(2))\n\njulia> keys.(axes(F.U))\n(Base.OneTo(2), 3:4)\n\njulia> keys.(axes(F.p))\n(2:3,)\n\njulia> keys.(axes(F.P))\n(2:3, 2:3)\n\njulia> keys.(axes(F.P * m))\n(2:3, 3:4)\n\njulia> keys.(axes(F.L * F.U))\n(2:3, 3:4)\n\n\n\n\n\n","category":"function"},{"location":"standard_library_api/#LinearAlgebra.lq","page":"Standard Library API","title":"LinearAlgebra.lq","text":"lq(A::AbstractAxisArray, args...; kwargs...)\n\nCompute the LQ factorization of an AbstractAxisIndices A.\n\nExamples\n\njulia> using AxisIndices, LinearAlgebra\n\njulia> m = AxisIndicesArray([1.0 2; 3 4], (Axis(2:3 => Base.OneTo(2)), Axis(3:4 => Base.OneTo(2))));\n\njulia> F = lq(m);\n\njulia> keys.(axes(F.L))\n(2:3, Base.OneTo(2))\n\njulia> keys.(axes(F.Q))\n(Base.OneTo(2), 3:4)\n\njulia> keys.(axes(F.L * F.Q))\n(2:3, 3:4)\n\n\n\n\n\n","category":"function"},{"location":"standard_library_api/#Base.inv","page":"Standard Library API","title":"Base.inv","text":"inv(M::AbstractAxisIndicesMatrix)\n\nComputes the inverse of an AbstractAxisIndicesMatrix\n\njulia> using AxisIndices, LinearAlgebra\n\njulia> M = AxisIndicesArray([2 5; 1 3], [\"a\", \"b\"], [:one, :two]);\n\njulia> axes_keys(inv(M))\n([:one, :two], [\"a\", \"b\"])\n\n\n\n\n\n\n","category":"function"},{"location":"standard_library_api/#Statistics.cov","page":"Standard Library API","title":"Statistics.cov","text":"cov(x::AbstractAxisIndicesMatrix; dims=1, kwargs...)\n\nPerforms cov on the parent matrix of x and reconstructs a similar type with the appropriate axes.\n\nExamples\n\njulia> using AxisIndices, Statistics\n\njulia> A = AxisIndicesArray([1 2 3; 4 5 6; 7 8 9], [\"a\", \"b\", \"c\"], [:one, :two, :three]);\n\njulia> axes_keys(cov(A, dims = 2))\n([\"a\", \"b\", \"c\"], [\"a\", \"b\", \"c\"])\n\njulia> axes_keys(cov(A, dims = 1))\n([:one, :two, :three], [:one, :two, :three])\n\n\n\n\n\n\n","category":"function"},{"location":"standard_library_api/#Statistics.cor","page":"Standard Library API","title":"Statistics.cor","text":"cor(x::AbstractAxisIndicesMatrix; dims=1, kwargs...)\n\nPerforms cor on the parent matrix of x and reconstructs a similar type with the appropriate axes.\n\nExamples\n\njulia> using AxisIndices, Statistics\n\njulia> A = AxisIndicesArray([1 2 3; 4 5 6; 7 8 9], [\"a\", \"b\", \"c\"], [:one, :two, :three]);\n\njulia> axes_keys(cor(A, dims = 2))\n([\"a\", \"b\", \"c\"], [\"a\", \"b\", \"c\"])\n\njulia> axes_keys(cor(A, dims = 1))\n([:one, :two, :three], [:one, :two, :three])\n\n\n\n\n\n\n","category":"function"},{"location":"standard_library_api/#LinearAlgebra.diag","page":"Standard Library API","title":"LinearAlgebra.diag","text":"diag(M::AbstractAxisIndicesMatrix, k::Integer=0; dim::Val=Val(1))\n\nThe kth diagonal of an AbstractAxisIndicesMatrix, M. The keyword argument dim specifies which which dimension's axis to preserve, with the default being the first dimension. This can be change by specifying dim=Val(2) instead.\n\njulia> using AxisIndices, LinearAlgebra\n\njulia> A = AxisIndicesArray([1 2 3; 4 5 6; 7 8 9], [\"a\", \"b\", \"c\"], [:one, :two, :three]);\n\njulia> axes_keys(diag(A))\n([\"a\", \"b\", \"c\"],)\n\njulia> axes_keys(diag(A, 1; dim=Val(2)))\n([:one, :two],)\n\n\n\n\n\n\n","category":"function"},{"location":"#AxisIndices-1","page":"Introduction","title":"AxisIndices","text":"","category":"section"},{"location":"#Introduction-1","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"The goals of this package are:","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Facilitate multidimensional indexing (e.g., instance_of_an_array[indices]) that supports semantic user facing indices (e.g., indices = Second(1)).\nAccomplishing the first goal should not interfere in the ability to perform the vast majority of array related methods (e.g, vcat, append!, etc.).\nIt should be easy to implement new subtypes of AbstractAxis that accommodate novel behavior and needs.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"These goals are accomplished predominantly through the AbstractAxis type. It is a subtype of AbstractUnitRange{<:Integer} with an additional interface for creating keys and interacting with them. This additional interface is intended to be easily extended to new types that may be needed for a variety of different situations. An additional AxisIndicesArray type is provided that uses any subtype of AbstractAxis for each axis. However, many methods are provided and documented internally so that it's easy for users to alter the behavior of an AxisIndicesArray with a new AbstractAxis subtype or create an entirely unique multidimensional structure.","category":"page"},{"location":"#Where-to-go-from-here-1","page":"Introduction","title":"Where to go from here","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"I just want to get something done.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Then start with the Quick Start section. A slightly more in depth tutorial is provided with Indexing Tutorial.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"I want to make my own axis type.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Look at the TimeAxis Guide, which implements a custom axis type.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"I want to understand why/how something works","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"If you've read the appropriate docstrings (under \"References\" or available in the REPL) and still have questions then various sections under \"Manual\" are a good place to look. If that doesn't help then create an issue in the AxisIndices repo.","category":"page"},{"location":"internals_of_indexing/#Internals-of-Indexing-1","page":"Internals of Indexing","title":"Internals of Indexing","text":"","category":"section"},{"location":"internals_of_indexing/#","page":"Internals of Indexing","title":"Internals of Indexing","text":"This section is those who want to understand how indexing is implemented in AxisIndices and some of the logic behind it. It goes over:","category":"page"},{"location":"internals_of_indexing/#","page":"Internals of Indexing","title":"Internals of Indexing","text":"The three steps of indexing.\nMapping to indices\nRetrieving elements\nReconstructing axes\nIntroduction to AxisIndicesStyle traits","category":"page"},{"location":"internals_of_indexing/#Mapping-to-Indices-1","page":"Internals of Indexing","title":"Mapping to Indices","text":"","category":"section"},{"location":"internals_of_indexing/#","page":"Internals of Indexing","title":"Internals of Indexing","text":"AxisIndices attempts to redirect the traditional to_indices method from the following...","category":"page"},{"location":"internals_of_indexing/#","page":"Internals of Indexing","title":"Internals of Indexing","text":"function to_indices(A, axes::Tuple, args::Tuple)\n    return (to_index(A, first(args)), to_indices(A, tail(axes), tail(args))...)\nend","category":"page"},{"location":"internals_of_indexing/#","page":"Internals of Indexing","title":"Internals of Indexing","text":"to...","category":"page"},{"location":"internals_of_indexing/#","page":"Internals of Indexing","title":"Internals of Indexing","text":"function to_indices(A, axes::Tuple, args::Tuple)\n    return (to_index(first(axes), first(args)), to_indices(A, tail(axes), tail(args))...)\nend","category":"page"},{"location":"internals_of_indexing/#","page":"Internals of Indexing","title":"Internals of Indexing","text":"This allows each axis to influence how an argument maps to indices. The combination of a given axis and argument produce a trait that directs this mapping.","category":"page"},{"location":"internals_of_indexing/#","page":"Internals of Indexing","title":"Internals of Indexing","text":"AxisIndices.to_index(axis, arg) = to_index(AxisIndicesStyle(axis, arg), axis, arg)","category":"page"},{"location":"internals_of_indexing/#","page":"Internals of Indexing","title":"Internals of Indexing","text":"Note that this to_index method is completely unique from the one implemented in Base [1].","category":"page"},{"location":"internals_of_indexing/#","page":"Internals of Indexing","title":"Internals of Indexing","text":"Functionally, this translates to retrieving the elements of an AbstractIndicesArray like so:","category":"page"},{"location":"internals_of_indexing/#","page":"Internals of Indexing","title":"Internals of Indexing","text":"A[arg1, arg2] ->\nparent(A)[to_indices(A, (arg1, arg2))...] ->\nparent(A)[to_indices(A, axes(A), (arg1, arg2))...] ->\nparent(A)[indices...] -> sub_A","category":"page"},{"location":"internals_of_indexing/#Reconstructing-Axes-1","page":"Internals of Indexing","title":"Reconstructing Axes","text":"","category":"section"},{"location":"internals_of_indexing/#","page":"Internals of Indexing","title":"Internals of Indexing","text":"Once the new array is composed axes need to be reconstructed through to_axes, which essentially is the reverse of to_indices. Instead of passing each argument to to_index they're passed to to_key [2].","category":"page"},{"location":"internals_of_indexing/#","page":"Internals of Indexing","title":"Internals of Indexing","text":"AxisIndices.to_key(axis, arg, index) = to_key(AxisIndicesStyle(axis, arg), axis, arg, index)","category":"page"},{"location":"internals_of_indexing/#","page":"Internals of Indexing","title":"Internals of Indexing","text":"The resulting keys produced are combined with the relevant indices of the new array to reconstruct the axis[3].","category":"page"},{"location":"internals_of_indexing/#AxisIndicesStyle-1","page":"Internals of Indexing","title":"AxisIndicesStyle","text":"","category":"section"},{"location":"internals_of_indexing/#","page":"Internals of Indexing","title":"Internals of Indexing","text":"You may have noticed that AxisIndicesStyle is in the last part of to_index and to_key described. AxisIndicesStyle is the supertype for a set of traits that determine what each argument means in the context of an axis. For example, AxisIndicesStyle(::AbstractAxis, ::Integer) returns IndexElement, telling to_index and to_key that the provided argument directly corresponds to an index with an axis. Contrast this with KeyElement which tells to_index to find the position of the provided argument within the keys and return the corresponding index. These traits are fully responsible for dispatch to to_index and to_keys. Therefore, new subtypes of AxisIndicesStyle must define a to_index and to_keys method.","category":"page"},{"location":"internals_of_indexing/#","page":"Internals of Indexing","title":"Internals of Indexing","text":"[1]: There's absolutely no functionality provided from Base.to_index that isn't already available with AxisIndices.to_index. Providing a seperate implementation is meant to avoid causing any unecessary ambiguities in this or any other packages that may be simultaneously loaded.","category":"page"},{"location":"internals_of_indexing/#","page":"Internals of Indexing","title":"Internals of Indexing","text":"[2]: Why do we need the index produced in the previous to_index method to reconstruct keys? Technically we don't, but it allows use to avoid looking up indices a second time and ensuring they are inbounds.","category":"page"},{"location":"internals_of_indexing/#","page":"Internals of Indexing","title":"Internals of Indexing","text":"[3]: It is at this point that unsafe_reconstruct is called. This is only important to know if you want to create a new axis type that has keys that require some unique procedure to reconstruct.","category":"page"}]
}
