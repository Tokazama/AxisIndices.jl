var documenterSearchIndex = {"docs":
[{"location":"axisindicesarray/#Arrays-With-Axes-1","page":"AbstractAxisIndices","title":"Arrays With Axes","text":"","category":"section"},{"location":"axisindicesarray/#","page":"AbstractAxisIndices","title":"AbstractAxisIndices","text":"The following describes many of the available methods for accommodating multidimensional manipulation of types that have axes.","category":"page"},{"location":"axisindicesarray/#AbstractAxisIndices-Interface-1","page":"AbstractAxisIndices","title":"AbstractAxisIndices Interface","text":"","category":"section"},{"location":"axisindicesarray/#","page":"AbstractAxisIndices","title":"AbstractAxisIndices","text":"AxisIndices.AbstractAxisIndices\nAxisIndices.AxisIndicesArray","category":"page"},{"location":"axisindicesarray/#AxisIndices.AbstractAxisIndices","page":"AbstractAxisIndices","title":"AxisIndices.AbstractAxisIndices","text":"AbstractAxisIndices\n\nAbstractAxisIndices is a subtype of AbstractArray that offers integration with the AbstractAxis interface. The only methods that absolutely needs to be defined for a subtype of AbstractAxisIndices are axes, parent, similar_type, and similar. Most users should find the provided AxisIndicesArray subtype is sufficient for the majority of use cases. Although custom behavior may be accomplished through a new subtype of AbstractAxisIndices, customizing the behavior of many methods described herein can be accomplished through a unique subtype of AbstractAxis.\n\nThis implementation is meant to be basic, well documented, and have sane defaults that can be overridden as necessary. In other words, default methods for manipulating arrays that return an AxisIndicesArray should not cause unexpected downstream behavior for users; and developers should be able to freely customize the behavior of AbstractAxisIndices subtypes with minimal effort. \n\n\n\n\n\n","category":"type"},{"location":"axisindicesarray/#AxisIndices.AxisIndicesArray","page":"AbstractAxisIndices","title":"AxisIndices.AxisIndicesArray","text":"AxisIndicesArray(parent_array, tuple_of_keys) -> AxisIndicesArray(parent_array, Axis.(tuple_of_keys))\nAxisIndicesArray(parent_array, tuple_of_axis) -> AxisIndicesArray\n\nAn array struct that wraps any parent array and assigns it an AbstractAxis for each dimension. The first argument is the parent array and the second argument is a tuple of subtypes to AbstractAxis or keys that will be converted to subtypes of AbstractAxis with the provided keys.\n\nExamples\n\njulia> using AxisIndices\n\njulia> A = AxisIndicesArray(reshape(1:9, 3,3), (2:4, 3.0:5.0));\n\njulia> A[1, 1]\n1\n\njulia> A[==(2), ==(3.0)]\n1\n\njulia> A[1:2, 1:2] == [1 4; 2 5]\ntrue\n\njulia> A[<(4), <(5.0)] == [1 4; 2 5]\ntrue\n\n\n\n\n\n","category":"type"},{"location":"axisindicesarray/#Swapping-Dimensions-1","page":"AbstractAxisIndices","title":"Swapping Dimensions","text":"","category":"section"},{"location":"axisindicesarray/#Drop-Dimensions-1","page":"AbstractAxisIndices","title":"Drop Dimensions","text":"","category":"section"},{"location":"axisindicesarray/#","page":"AbstractAxisIndices","title":"AbstractAxisIndices","text":"AxisIndices.drop_axes","category":"page"},{"location":"axisindicesarray/#AxisIndices.drop_axes","page":"AbstractAxisIndices","title":"AxisIndices.drop_axes","text":"drop_axes(x, dims)\n\nReturns all axes of x except for those identified by dims. Elements of dims must be unique integers or symbols corresponding to the dimensions or names of dimensions of x.\n\nExamples\n\njulia> using AxisIndices\n\njulia> axs = (Axis(1:5), Axis(1:10));\n\njulia> AxisIndices.drop_axes(axs, 1)\n(Axis(1:10 => Base.OneTo(10)),)\n\njulia> AxisIndices.drop_axes(axs, 2)\n(Axis(1:5 => Base.OneTo(5)),)\n\njulia> AxisIndices.drop_axes(rand(2, 4), 2)\n(Base.OneTo(2),)\n\n\n\n\n\n","category":"function"},{"location":"axisindicesarray/#Permute-Dimensions-1","page":"AbstractAxisIndices","title":"Permute Dimensions","text":"","category":"section"},{"location":"axisindicesarray/#","page":"AbstractAxisIndices","title":"AbstractAxisIndices","text":"AxisIndices.permute_axes","category":"page"},{"location":"axisindicesarray/#AxisIndices.permute_axes","page":"AbstractAxisIndices","title":"AxisIndices.permute_axes","text":"permute_axes(x::AbstractArray, p::Tuple) = permute_axes(axes(x), p)\npermute_axes(x::NTuple{N}, p::NTuple{N}) -> NTuple{N}\n\nReturns axes of x in the order of p.\n\nExamples\n\njulia> using AxisIndices\n\njulia> AxisIndices.permute_axes(rand(2, 4, 6), (1, 3, 2))\n(Base.OneTo(2), Base.OneTo(6), Base.OneTo(4))\n\njulia> AxisIndices.permute_axes((Axis(1:2), Axis(1:4), Axis(1:6)), (1, 3, 2))\n(Axis(1:2 => Base.OneTo(2)), Axis(1:6 => Base.OneTo(6)), Axis(1:4 => Base.OneTo(4)))\n\n\n\n\n\npermute_axes(x::AbstractVector)\n\nReturns the permuted axes of x as axes of size 1 Ã— length(x)\n\nExamples\n\njulia> using AxisIndices\n\njulia> length.(AxisIndices.permute_axes(rand(4))) == (1, 4)\ntrue\n\njulia> AxisIndices.permute_axes((Axis(1:4),))\n(SimpleAxis(Base.OneTo(1)), Axis(1:4 => Base.OneTo(4)))\n\njulia> AxisIndices.permute_axes((Axis(mrange(1, 4)),))\n(SimpleAxis(OneToMRange(1)), Axis(UnitMRange(1:4) => OneToMRange(4)))\n\njulia> AxisIndices.permute_axes((Axis(srange(1, 4)),))\n(SimpleAxis(OneToSRange(1)), Axis(UnitSRange(1:4) => OneToSRange(4)))\n\n\n\n\n\npermute_axes(m::AbstractMatrix) -> NTuple{2}\n\nPermute the axes of the matrix m, by flipping the elements across the diagonal of the matrix. Differs from LinearAlgebra's transpose in that the operation is not recursive.\n\nExamples\n\njulia> using AxisIndices\n\njulia> AxisIndices.permute_axes(rand(4, 2))\n(Base.OneTo(2), Base.OneTo(4))\n\njulia> AxisIndices.permute_axes((Axis(1:4), Axis(1:2)))\n(Axis(1:2 => Base.OneTo(2)), Axis(1:4 => Base.OneTo(4)))\n\n\n\n\n\n","category":"function"},{"location":"axisindicesarray/#Covariance-and-Correlation-1","page":"AbstractAxisIndices","title":"Covariance and Correlation","text":"","category":"section"},{"location":"axisindicesarray/#","page":"AbstractAxisIndices","title":"AbstractAxisIndices","text":"AxisIndices.covcor_axes","category":"page"},{"location":"axisindicesarray/#AxisIndices.covcor_axes","page":"AbstractAxisIndices","title":"AxisIndices.covcor_axes","text":"covcor_axes(x, dim) -> NTuple{2}\n\nReturns appropriate axes for a cov or var method on array x.\n\nExamples\n\njulia> using AxisIndices\n\njulia> AxisIndices.covcor_axes(rand(2,4), 1)\n(Base.OneTo(4), Base.OneTo(4))\n\njulia> AxisIndices.covcor_axes((Axis(1:4), Axis(1:6)), 2)\n(Axis(1:4 => Base.OneTo(4)), Axis(1:4 => Base.OneTo(4)))\n\njulia> AxisIndices.covcor_axes((Axis(1:4), Axis(1:4)), 1)\n(Axis(1:4 => Base.OneTo(4)), Axis(1:4 => Base.OneTo(4)))\n\nEach axis is resized to equal to the smallest sized dimension if given a dimensional argument greater than 2.\n\njulia> AxisIndices.covcor_axes((Axis(2:4), Axis(3:4)), 3)\n(Axis(3:4 => Base.OneTo(2)), Axis(3:4 => Base.OneTo(2)))\n\n\n\n\n\n","category":"function"},{"location":"comparison/#Comparison-to-Other-Packages-1","page":"Comparison to Other Packages","title":"Comparison to Other Packages","text":"","category":"section"},{"location":"comparison/#","page":"Comparison to Other Packages","title":"Comparison to Other Packages","text":"This is very brief overview of how AxisIndices compares to other packages. Rather than a comprehensive comparison of available alternatives and integrations, this is intended to provide a general idea of how AxisIndices fits in the Julia ecosystem.","category":"page"},{"location":"comparison/#","page":"Comparison to Other Packages","title":"Comparison to Other Packages","text":"AxisArrays.jl similarly supports mapping some sort of keys to each set of indices. AxisIndices is intended to be a more comprehensive, well documented, and flexible implementation of this concept. AxisArays natively offers the ability to name each dimension. In contrast AxisIndices was developed with the intention of using packages like NamedDims.jl to more fully implement such features in a complementary way.","category":"page"},{"location":"comparison/#","page":"Comparison to Other Packages","title":"Comparison to Other Packages","text":"DimensionalData.jl is a notable package that covers many similar funcitonalities as AxisArrays did. There are numerous differences in design decisions between this package and DimensionalData. It's likely that the majority of these differences represent personal preferences rather than strictly objective advantages over one another. In terms of approach, DimensionalData offers a more comprehensive alternative to the functionality of AxisArrays, where AxisIndices is intended only to be a highly customizable component of some of the features AxisArrays offers. Therefore, this package expects users seeking a complete replacement for AxisArrays to ultimately use another package that composes a modular solution to replacing AxisArrays.","category":"page"},{"location":"comparison/#","page":"Comparison to Other Packages","title":"Comparison to Other Packages","text":"There are many packages that offer overlapping features. For example, Dictionaries.jl implements a focused improvement on dictionaries where mapping keys to indices highly overlaps. However, as Dictionaries.jl continues to evolve many of the types provided therein may prove extremely useful in constructing the keys of an Axis type thereby giving these dictionaries multidimensional functionality. Similarly, many packages provide overlapping features that could actually be extended with the addition (not replacement) of AxisIndices.","category":"page"},{"location":"pretty_printing/#Pretty-Printing-1","page":"Pretty Printing","title":"Pretty Printing","text":"","category":"section"},{"location":"pretty_printing/#","page":"Pretty Printing","title":"Pretty Printing","text":"warning: Warning\nCurrently pretty printing is an experimental feature that may undergo rapid changes.","category":"page"},{"location":"pretty_printing/#","page":"Pretty Printing","title":"Pretty Printing","text":"It's important that we can view the custom indices that we assign to arrays. Yet a surprising challenge of implementing and using arrays in interactive programming is how complicated printing them can be. Rather than burdening users with cryptic text readouts this package seeks to provide \"pretty\" printing (quotes because beauty is in the eye of the beholder). This package leans heavily on the PrettyTables.jl package to accomplish this by handing off everything that goes through the show method to pretty_array. pretty_array in turn repeatedly calls PrettyTables.pretty_print along slices of arrays.","category":"page"},{"location":"pretty_printing/#","page":"Pretty Printing","title":"Pretty Printing","text":"AxisIndices.pretty_array","category":"page"},{"location":"pretty_printing/#AxisIndices.pretty_array","page":"Pretty Printing","title":"AxisIndices.pretty_array","text":"pretty_array([io::IO,] A::AbstractArray[, key_names::Tuple=axes_keys(A)]; kwargs...)\n\nPrints to io the array A with the keys key_names along each dimension of A. Printing of multidimensional arrays is accomplished in a similar manner to Array, where the final two dimensions are sliced producing a series of matrices. kwargs... are passed to pretty_table for 1/2D slice produced.\n\nExamples\n\njulia> using AxisIndices\n\njulia> pretty_array(AxisIndicesArray(ones(2,2,2), (2:3, [:one, :two], [\"a\", \"b\"])))\n[dim1, dim2, dim3[a]] =\n        one     two\n  2   1.000   1.000\n  3   1.000   1.000\n\n\n[dim1, dim2, dim3[b]] =\n        one     two\n  2   1.000   1.000\n  3   1.000   1.000\n\n\n\n\n\n","category":"function"},{"location":"axis/#The-Axis-Interface-1","page":"The Axis","title":"The Axis Interface","text":"","category":"section"},{"location":"axis/#","page":"The Axis","title":"The Axis","text":"The following describes the components necessary to construct and manipulate existing and new subtypes of AbstractAxis.","category":"page"},{"location":"axis/#Introduction-1","page":"The Axis","title":"Introduction","text":"","category":"section"},{"location":"axis/#","page":"The Axis","title":"The Axis","text":"The supertype to all axis types herein is the AbstractAxis, which is a subtype of AbstractUnitRange{<:Integer}.","category":"page"},{"location":"axis/#","page":"The Axis","title":"The Axis","text":"If we have a set of keys a b c and a set of indices 1 2 3 then the key a maps to the index 1. Given these definitions, the AbstractAxis differs from the classic dictionary in the following two ways:","category":"page"},{"location":"axis/#","page":"The Axis","title":"The Axis","text":"The valtype of AbstractAxis is always an integer.\nThe values are always unique and continuous.","category":"page"},{"location":"axis/#","page":"The Axis","title":"The Axis","text":"The two main axis types defined here are Axis and SimpleAxis. The standard syntax for indexing doesn't change at all for these types.","category":"page"},{"location":"axis/#","page":"The Axis","title":"The Axis","text":"julia> using AxisIndices, Dates\n\njulia> sa = SimpleAxis(1:10)\nSimpleAxis(1:10)\n\njulia> sa[2]\n2\n\njulia> sa[>(2)]\nSimpleAxis(3:10)\n\njulia> a = Axis(1:10)\nAxis(1:10 => Base.OneTo(10))\n\njulia> a[2]\n2\n\njulia> a[2:3]\nAxis(2:3 => 2:3)","category":"page"},{"location":"axis/#","page":"The Axis","title":"The Axis","text":"But now we can also use functions to index by the keys of an AbstractAxis.","category":"page"},{"location":"axis/#","page":"The Axis","title":"The Axis","text":"julia> a = Axis(2.0:11.0, 1:10)\nAxis(2.0:1.0:11.0 => 1:10)\n\njulia> a[1]\n1\n\njulia> a[isequal(2.0)]\n1\n\njulia> a[>(2)]\nAxis(3.0:1.0:11.0 => 2:10)\n\njulia> a[>(2.0)]\nAxis(3.0:1.0:11.0 => 2:10)\n\njulia> a[and(>(2.0), <(8.0))]\nAxis(3.0:1.0:7.0 => 2:6)\n\njulia> sa[in(3:5)]\nSimpleAxis(3:5)","category":"page"},{"location":"axis/#","page":"The Axis","title":"The Axis","text":"This also allows certain syntax special treatment because they are obviously not referring to traditional integer based indexing.","category":"page"},{"location":"axis/#","page":"The Axis","title":"The Axis","text":"julia> x, y, z = Axis((:one, :two, :three)), Axis([\"one\", \"two\", \"three\"]), Axis(Second(1):Second(1):Second(3));\n\njulia> x[:one]\n1\n\njulia> x[:one] == y[\"one\"] == z[Second(1)]\ntrue\n\njulia> x[[:one, :two]]\n2-element Array{Int64,1}:\n 1\n 2","category":"page"},{"location":"axis/#","page":"The Axis","title":"The Axis","text":"Note in the last example that a vector was returned instead of an AbstractAxis. An AbstractAxis is a subtype of AbstractUnitRange and therefore cannot be reformed after any operation that does not guarantee the return of another unit range. This is similar to the behavior of UnitRange in base.","category":"page"},{"location":"axis/#How-Does-It-Work?-1","page":"The Axis","title":"How Does It Work?","text":"","category":"section"},{"location":"axis/#","page":"The Axis","title":"The Axis","text":"This package makes a small alteration in the indexing pipeline for arrays from base. Where an array typically passes indices along a similar path to:","category":"page"},{"location":"axis/#","page":"The Axis","title":"The Axis","text":"getindex(A::Array, i1, i2, i3) -> to_indices(A, axes(), (i1, i2, i3))\nto_indices(A, (ax1, ax2, ax3), (i1, i2, i3)) ->\n(to_index(A, i1), to_index(A, i2), to_index(A, i3)) -> I\n_getindex(A, I)","category":"page"},{"location":"axis/#","page":"The Axis","title":"The Axis","text":"This package does:","category":"page"},{"location":"axis/#","page":"The Axis","title":"The Axis","text":"getindex(A::Array, i1, i2, i3) -> to_indices(A, axes(), (i1, i2, i3))\nto_indices(A, (ax1, ax2, ax3), (i1, i2, i3)) ->\n(to_index(ax1, i1), to_index(ax2, i2), to_index(ax3, i3)) -> I\n_getindex(A, I)","category":"page"},{"location":"axis/#","page":"The Axis","title":"The Axis","text":"This allows customizing the initial arguments given to getindex per each axis instead of by the array type or the type of i1/2/3.","category":"page"},{"location":"axis/#Performance-1","page":"The Axis","title":"Performance","text":"","category":"section"},{"location":"axis/#","page":"The Axis","title":"The Axis","text":"Indexing CartesianAxes is comparable to that of CartesianIndices.","category":"page"},{"location":"axis/#","page":"The Axis","title":"The Axis","text":"julia> using AxisIndices, BenchmarkTools\n\njulia> cartaxes = CartesianAxes((Axis(2.0:5.0), Axis(1:4)));\n\njulia> cartinds = CartesianIndices((1:4, 1:4));\n\njulia> @btime getindex(cartaxes, 2, 2)\n  20.848 ns (1 allocation: 32 bytes)\nCartesianIndex(2, 2)\n\njulia> @btime getindex(cartinds, 2, 2)\n  22.317 ns (1 allocation: 32 bytes)\nCartesianIndex(2, 2)\n\njulia> @btime getindex(cartaxes, ==(3.0), 2)\n  444.374 ns (7 allocations: 416 bytes)\nCartesianIndex(2, 2)","category":"page"},{"location":"axis/#","page":"The Axis","title":"The Axis","text":"Indexing LinearAxes is comparable to that of LinearIndices","category":"page"},{"location":"axis/#","page":"The Axis","title":"The Axis","text":"julia> using AxisIndices, BenchmarkTools\n\njulia> linaxes = LinearAxes((Axis(1.0:4.0), Axis(1:4)));\n\njulia> lininds = LinearIndices((1:4, 1:4));\n\njulia> @btime getindex(linaxes, 2, 2)\n  18.275 ns (0 allocations: 0 bytes)\n6\n\njulia> @btime getindex(lininds, 2, 2)\n  18.849 ns (0 allocations: 0 bytes)\n6\n\njulia> @btime getindex(linaxes, ==(3.0), 2)\n  381.098 ns (6 allocations: 384 bytes)\n7","category":"page"},{"location":"axis/#","page":"The Axis","title":"The Axis","text":"You may notice there's significant overhead for using the filtering syntax. However, the filtering syntax takes advantage of a special type in base, Fix2. This means that we can take advantage of filtering methods that have been optimized for specific types of keys.  Here we do the same thing as above but we create a function that knows it's going to perform filtering.","category":"page"},{"location":"axis/#","page":"The Axis","title":"The Axis","text":"julia> getindex_filter(a, i1, i2) = a[==(i1), ==(i2)]\ngetindex_filter (generic function with 1 method)\n\njulia> @btime getindex_filter(linaxes, 3.0, 2)\n  57.216 ns (0 allocations: 0 bytes)\n7\n\njulia> linaxes2 = LinearAxes((Axis(Base.OneTo(4)), Axis(Base.OneTo(4))));\n\njulia> @btime getindex_filter(linaxes2, 3, 2)\n  22.070 ns (0 allocations: 0 bytes)\n7","category":"page"},{"location":"axis/#","page":"The Axis","title":"The Axis","text":"Indexing linaxes is much faster now that it can be optimized inside of a function call. However, it's still a little over twice as slow as normal indexing. That's largely because of the cost of searching 1.0:4.0 (which is a StepRangeLen type in this case). The second benchmark demonstrates how close we really are to standard indexing given similar range types.","category":"page"},{"location":"axis/#Reindexing-Axes-1","page":"The Axis","title":"Reindexing Axes","text":"","category":"section"},{"location":"axis/#","page":"The Axis","title":"The Axis","text":"AxisIndices.reindex\nAxisIndices.unsafe_reindex","category":"page"},{"location":"axis/#AxisIndices.reindex","page":"The Axis","title":"AxisIndices.reindex","text":"reindex(a::AbstractAxis, inds::AbstractVector{Integer}) -> AbstractAxis\n\nReturns an AbstractAxis of the same type as a where the keys of the axis are constructed by indexing into the keys of a with inds (keys(a)[inds]) and the values have the same first element as first(values(a)) but a length matching inds.\n\nExamples\n\njulia> using AxisIndices\n\njulia> x, y, z = Axis(1:10, 2:11), Axis(1:10), SimpleAxis(1:10);\n\njulia>  reindex(x, collect(1:2:10))\nAxis([1, 3, 5, 7, 9] => 2:6)\n\njulia> reindex(y, collect(1:2:10))\nAxis([1, 3, 5, 7, 9] => Base.OneTo(5))\n\njulia> reindex(z, collect(1:2:10))\nSimpleAxis(1:5)\n\n\n\n\n\n\n","category":"function"},{"location":"axis/#AxisIndices.unsafe_reindex","page":"The Axis","title":"AxisIndices.unsafe_reindex","text":"unsafe_reindex(a::AbstractAxis, inds::AbstractVector) -> AbstractAxis\n\nSimilar to reindex this function returns an index of the same type as a but doesn't check that inds is inbounds.\n\nSee also: reindex\n\nExamples\n\njulia> using AxisIndices\n\njulia> AxisIndices.unsafe_reindex(SimpleAxis(OneToMRange(10)), 1:5)\nSimpleAxis(OneToMRange(5))\n\njulia> AxisIndices.unsafe_reindex(SimpleAxis(OneToSRange(10)), 1:5)\nSimpleAxis(OneToSRange(5))\n\n\n\n\n\n","category":"function"},{"location":"axis/#Reducing-Axes-1","page":"The Axis","title":"Reducing Axes","text":"","category":"section"},{"location":"axis/#","page":"The Axis","title":"The Axis","text":"AxisIndices.reduce_axes\nAxisIndices.reduce_axis","category":"page"},{"location":"axis/#AxisIndices.reduce_axes","page":"The Axis","title":"AxisIndices.reduce_axes","text":"reduce_axes(a, dims)\n\nReturns the appropriate axes for a measure that reduces dimensions along the dimensions dims.\n\nExample\n\njulia> using AxisIndices\n\njulia> AxisIndices.reduce_axes(rand(2, 4), 2)\n(Base.OneTo(2), Base.OneTo(1))\n\njulia> AxisIndices.reduce_axes(rand(2, 4), (1,2))\n(Base.OneTo(1), Base.OneTo(1))\n\njulia> AxisIndices.reduce_axes(rand(2, 4), :)\n()\n\njulia> AxisIndices.reduce_axes((Axis(1:4), Axis(1:4)), 2)\n(Axis(1:4 => Base.OneTo(4)), Axis(1:1 => Base.OneTo(1)))\n\n\n\n\n\n","category":"function"},{"location":"axis/#AxisIndices.reduce_axis","page":"The Axis","title":"AxisIndices.reduce_axis","text":"reduce_axis(a)\n\nReduces axis a to single value. Allows custom index types to have custom behavior throughout reduction methods (e.g., sum, prod, etc.)\n\nSee also: reduce_axes\n\nExample\n\njulia> using AxisIndices\n\njulia> AxisIndices.reduce_axis(Axis(1:4))\nAxis(1:1 => Base.OneTo(1))\n\njulia> AxisIndices.reduce_axis(1:4)\n1:1\n\n\n\n\n\n","category":"function"},{"location":"axis/#Resizing-Axes-1","page":"The Axis","title":"Resizing Axes","text":"","category":"section"},{"location":"axis/#","page":"The Axis","title":"The Axis","text":"These methods help with operations that need to resize axes, either dynamically or by creating a new instance of an axis. In addition to helping with operations related to array resizing, these may be useful for managing the axis of a vector throughout a push!, pushfirst!, pop, and popfirst! operation.","category":"page"},{"location":"axis/#","page":"The Axis","title":"The Axis","text":"AxisIndices.resize_first\nAxisIndices.resize_first!\nAxisIndices.resize_last\nAxisIndices.resize_last!\n\nAxisIndices.grow_first\nAxisIndices.grow_first!\nAxisIndices.grow_last\nAxisIndices.grow_last!\n\nAxisIndices.shrink_first\nAxisIndices.shrink_first!\nAxisIndices.shrink_last\nAxisIndices.shrink_last!\n\nAxisIndices.next_type\nAxisIndices.prev_type","category":"page"},{"location":"axis/#AxisIndices.resize_first","page":"The Axis","title":"AxisIndices.resize_first","text":"resize_first(x, n::Integer)\n\nReturns a collection similar to x that grows or shrinks from the first index to be of size n.\n\nExamples\n\njulia> using AxisIndices\n\njulia> x = collect(1:5);\n\njulia> AxisIndices.resize_first(x, 2)\n2-element Array{Int64,1}:\n 4\n 5\n\njulia> AxisIndices.resize_first(x, 7)\n7-element Array{Int64,1}:\n -1\n  0\n  1\n  2\n  3\n  4\n  5\n\njulia> AxisIndices.resize_first(x, 5)\n5-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5\n\n\n\n\n\n","category":"function"},{"location":"axis/#AxisIndices.resize_first!","page":"The Axis","title":"AxisIndices.resize_first!","text":"resize_first!(x, n::Integer)\n\nReturns the collection x after growing or shrinking the first index to be of size n.\n\nExamples\n\njulia> using AxisIndices\n\njulia> x = collect(1:5);\n\njulia> AxisIndices.resize_first!(x, 2);\n\njulia> x\n2-element Array{Int64,1}:\n 4\n 5\n\njulia> AxisIndices.resize_first!(x, 6);\n\njulia> x\n6-element Array{Int64,1}:\n 0\n 1\n 2\n 3\n 4\n 5\n\n\n\n\n\n\n","category":"function"},{"location":"axis/#AxisIndices.resize_last","page":"The Axis","title":"AxisIndices.resize_last","text":"resize_last(x, n::Integer)\n\nReturns a collection similar to x that grows or shrinks from the last index to be of size n.\n\nExamples\n\njulia> using AxisIndices\n\njulia> x = collect(1:5);\n\njulia> AxisIndices.resize_last(x, 2)\n2-element Array{Int64,1}:\n 1\n 2\n\njulia> AxisIndices.resize_last(x, 7)\n7-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n\njulia>  AxisIndices.resize_last(x, 5)\n5-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5\n\n\n\n\n\n\n","category":"function"},{"location":"axis/#AxisIndices.resize_last!","page":"The Axis","title":"AxisIndices.resize_last!","text":"resize_last!(x, n::Integer)\n\nReturns the collection x after growing or shrinking the last index to be of size n.\n\nExamples\n\njulia> using AxisIndices\n\njulia> x = collect(1:5);\n\njulia> AxisIndices.resize_last!(x, 2);\n\njulia> x\n2-element Array{Int64,1}:\n 1\n 2\n\njulia> AxisIndices.resize_last!(x, 5);\n\njulia> x\n5-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5\n\n\n\n\n\n\n","category":"function"},{"location":"axis/#AxisIndices.grow_first","page":"The Axis","title":"AxisIndices.grow_first","text":"grow_first(x, n)\n\nReturns a collection similar to x that grows by n elements from the first index.\n\nExamples\n\njulia> using AxisIndices\n\njulia> mr = UnitMRange(1, 10)\nUnitMRange(1:10)\n\njulia> AxisIndices.grow_first(mr, 2)\nUnitMRange(-1:10)\n\n\n\n\n\n","category":"function"},{"location":"axis/#AxisIndices.grow_first!","page":"The Axis","title":"AxisIndices.grow_first!","text":"grow_first!(x, n)\n\nReturns the collection x after growing from the first index by n elements.\n\nExamples\n\njulia> using AxisIndices\n\njulia> mr = UnitMRange(1, 10)\nUnitMRange(1:10)\n\njulia> AxisIndices.grow_first!(mr, 2);\n\njulia> mr\nUnitMRange(-1:10)\n\n\n\n\n\n","category":"function"},{"location":"axis/#AxisIndices.grow_last","page":"The Axis","title":"AxisIndices.grow_last","text":"grow_last(x, n)\n\nReturns a collection similar to x that grows by n elements from the last index.\n\nExamples\n\njulia> using AxisIndices\n\njulia> mr = UnitMRange(1, 10)\nUnitMRange(1:10)\n\njulia> AxisIndices.grow_last(mr, 2)\nUnitMRange(1:12)\n\n\n\n\n\n","category":"function"},{"location":"axis/#AxisIndices.grow_last!","page":"The Axis","title":"AxisIndices.grow_last!","text":"grow_last!(x, n)\n\nReturns the collection x after growing from the last index by n elements.\n\nExamples\n\njulia> using AxisIndices\n\njulia> mr = UnitMRange(1, 10)\nUnitMRange(1:10)\n\njulia> AxisIndices.grow_last!(mr, 2);\n\njulia> mr\nUnitMRange(1:12)\n\n\n\n\n\n","category":"function"},{"location":"axis/#AxisIndices.shrink_first","page":"The Axis","title":"AxisIndices.shrink_first","text":"shrink_first(x, n)\n\nReturns a collection similar to x that shrinks by n elements from the first index.\n\nExamples\n\njulia> using AxisIndices\n\njulia> mr = UnitMRange(1, 10)\nUnitMRange(1:10)\n\njulia> AxisIndices.shrink_first(mr, 2)\nUnitMRange(3:10)\n\n\n\n\n\n","category":"function"},{"location":"axis/#AxisIndices.shrink_first!","page":"The Axis","title":"AxisIndices.shrink_first!","text":"shrink_first!(x, n)\n\nReturns the collection x after shrinking from the first index by n elements.\n\n\n\n\n\n","category":"function"},{"location":"axis/#AxisIndices.shrink_last","page":"The Axis","title":"AxisIndices.shrink_last","text":"shrink_last(x, n)\n\nReturns a collection similar to x that shrinks by n elements from the last index.\n\nExamples\n\njulia> using AxisIndices\n\njulia> mr = UnitMRange(1, 10)\nUnitMRange(1:10)\n\njulia> AxisIndices.shrink_last(mr, 2)\nUnitMRange(1:8)\n\n\n\n\n\n","category":"function"},{"location":"axis/#AxisIndices.shrink_last!","page":"The Axis","title":"AxisIndices.shrink_last!","text":"shrink_last!(x, n)\n\nReturns the collection x after shrinking from the last index by n elements.\n\nExamples\n\njulia> using AxisIndices\n\njulia> mr = UnitMRange(1, 10)\nUnitMRange(1:10)\n\njulia> AxisIndices.shrink_last!(mr, 2);\n\njulia> mr\nUnitMRange(1:8)\n\n\n\n\n\n","category":"function"},{"location":"axis/#AxisIndices.next_type","page":"The Axis","title":"AxisIndices.next_type","text":"next_type(x::T)\n\nReturns the immediately greater value of type T.\n\nExamples\n\njulia> using AxisIndices\n\njulia> AxisIndices.next_type(\"b\")\n\"c\"\n\njulia> AxisIndices.next_type(:b)\n:c\n\njulia> AxisIndices.next_type('a')\n'b': ASCII/Unicode U+0062 (category Ll: Letter, lowercase)\n\njulia> AxisIndices.next_type(1)\n2\n\njulia> AxisIndices.next_type(2.0)\n2.0000000000000004\n\njulia> AxisIndices.next_type(\"\")\n\"\"\n\n\n\n\n\n","category":"function"},{"location":"axis/#AxisIndices.prev_type","page":"The Axis","title":"AxisIndices.prev_type","text":"prev_type(x::T)\n\nReturns the immediately lesser value of type T.\n\nExamples\n\njulia> using AxisIndices\n\njulia> AxisIndices.prev_type(\"b\")\n\"a\"\n\njulia> AxisIndices.prev_type(:b)\n:a\n\njulia> AxisIndices.prev_type('b')\n'a': ASCII/Unicode U+0061 (category Ll: Letter, lowercase)\n\njulia> AxisIndices.prev_type(1)\n0\n\njulia> AxisIndices.prev_type(1.0)\n0.9999999999999999\n\njulia> AxisIndices.prev_type(\"\")\n\"\"\n\n\n\n\n\n","category":"function"},{"location":"axis/#Axis-Types-1","page":"The Axis","title":"Axis Types","text":"","category":"section"},{"location":"axis/#","page":"The Axis","title":"The Axis","text":"AxisIndices.AbstractAxis\nAxisIndices.AbstractSimpleAxis\nAxisIndices.Axis\nAxisIndices.SimpleAxis\nAxisIndices.CartesianAxes\nAxisIndices.LinearAxes\nAxisIndices.values_type\nAxisIndices.keys_type\nAxisIndices.indices\nAxisIndices.axes_keys\nAxisIndices.CombineStyle","category":"page"},{"location":"axis/#AxisIndices.AbstractAxis","page":"The Axis","title":"AxisIndices.AbstractAxis","text":"AbstractAxis\n\nAn AbstractVector subtype optimized for indexing.\n\n\n\n\n\n","category":"type"},{"location":"axis/#AxisIndices.AbstractSimpleAxis","page":"The Axis","title":"AxisIndices.AbstractSimpleAxis","text":"AbstractSimpleAxis{V,Vs}\n\nA subtype of AbstractAxis where the keys and values are represented by a single collection.\n\n\n\n\n\n","category":"type"},{"location":"axis/#AxisIndices.Axis","page":"The Axis","title":"AxisIndices.Axis","text":"Axis(k[, v=OneTo(length(k))])\n\nSubtypes of AbstractAxis that maps keys to values. The first argument specifies the keys and the second specifies the values. If only one argument is specified then the values span from 1 to the length of k.\n\nExamples\n\nThe value for all of these is the same.\n\njulia> using AxisIndices\n\njulia> x = Axis(2.0:11.0, 1:10)\nAxis(2.0:1.0:11.0 => 1:10)\n\njulia> y = Axis(2.0:11.0)  # when only one argument is specified assume it's the keys\nAxis(2.0:1.0:11.0 => Base.OneTo(10))\n\njulia> z = Axis(1:10)\nAxis(1:10 => Base.OneTo(10))\n\nStandard indexing returns the same values\n\njulia> x[2]\n2\n\njulia> x[2] == y[2] == z[2]\ntrue\n\njulia> x[1:2]\nAxis(2.0:1.0:3.0 => 1:2)\n\njulia> y[1:2]\nAxis(2.0:1.0:3.0 => 1:2)\n\njulia> z[1:2]\nAxis(1:2 => 1:2)\n\njulia> x[1:2] == y[1:2] == z[1:2]\ntrue\n\nFunctions that return true or false may be used to search the keys for their corresponding index. The following is equivalent to the previous example.\n\njulia> x[==(3.0)]\n2\n\njulia> x[==(3.0)] ==       # 3.0 is the 2nd key of x\n       y[isequal(3.0)] ==  # 3.0 is the 2nd key of y\n       z[==(2)]            # 2 is the 2nd key of z\ntrue\n\njulia> x[<(4.0)]  # all keys less than 4.0 are 2.0:3.0 which correspond to values 1:2\nAxis(2.0:1.0:3.0 => 1:2)\n\njulia> y[<=(3.0)]  # all keys less than or equal to 3.0 are 2.0:3.0 which correspond to values 1:2\nAxis(2.0:1.0:3.0 => 1:2)\n\njulia> z[<(3)]  # all keys less than or equal to 3 are 1:2 which correspond to values 1:2\nAxis(1:2 => 1:2)\n\njulia> x[<(4.0)] == y[<=(3.0)] == z[<(3)]\ntrue\n\nNotice that == returns a single value instead of a collection of all elements where the key was found to be true. This is because all keys must be unique so there can only ever be one element returned.\n\n\n\n\n\n","category":"type"},{"location":"axis/#AxisIndices.SimpleAxis","page":"The Axis","title":"AxisIndices.SimpleAxis","text":"SimpleAxis(v)\n\nPovides an AbstractAxis interface for any AbstractUnitRange, v. v will be considered both the values and keys of the return instance. \n\nExamples\n\nA SimpleAxis is useful for giving a standard set of indices the ability to use the filtering syntax for indexing.\n\njulia> using AxisIndices\n\njulia> x = SimpleAxis(2:10)\nSimpleAxis(2:10)\n\njulia> x[2]\n3\n\njulia> x[==(2)]\n2\n\njulia> x[2] == x[==(3)]\ntrue\n\njulia> x[>(2)]\nSimpleAxis(3:10)\n\njulia> x[>(2)]\nSimpleAxis(3:10)\n\n\n\n\n\n","category":"type"},{"location":"axis/#AxisIndices.CartesianAxes","page":"The Axis","title":"AxisIndices.CartesianAxes","text":"CartesianAxes\n\nAlias for LinearIndices where indices are subtypes of AbstractAxis.\n\njulia> using AxisIndices\n\njulia> cartaxes = CartesianAxes((Axis(2.0:5.0), Axis(1:4)));\n\njulia> cartinds = CartesianIndices((1:4, 1:4));\n\njulia> cartaxes[2, 2]\nCartesianIndex(2, 2)\n\njulia> cartinds[2, 2]\nCartesianIndex(2, 2)\n\n\n\n\n\n","category":"type"},{"location":"axis/#AxisIndices.LinearAxes","page":"The Axis","title":"AxisIndices.LinearAxes","text":"LinearAxes\n\nAlias for LinearIndices where indices are subtypes of AbstractAxis.\n\njulia> using AxisIndices\n\njulia> linaxes = LinearAxes((Axis(2.0:5.0), Axis(1:4)));\n\njulia> lininds = LinearIndices((1:4, 1:4));\n\njulia> linaxes[2, 2]\n6\n\njulia> lininds[2, 2]\n6\n\n\n\n\n\n","category":"type"},{"location":"axis/#AxisIndices.values_type","page":"The Axis","title":"AxisIndices.values_type","text":"values_type(x)\n\nRetrieves the type of the values of x. This should be functionally equivalent to typeof(values(x)).\n\nExamples\n\njulia> using AxisIndices\n\njulia>  values_type(Axis(1:2))\nBase.OneTo{Int64}\n\njulia> values_type(typeof(Axis(1:2)))\nBase.OneTo{Int64}\n\njulia> values_type(typeof(1:2))\nUnitRange{Int64}\n\n\n\n\n\n","category":"function"},{"location":"axis/#AxisIndices.keys_type","page":"The Axis","title":"AxisIndices.keys_type","text":"keys_type(x)\n\nRetrieves the type of the keys of x.\n\nExamples\n\njulia> using AxisIndices\n\njulia>  keys_type(Axis(1:2))\nUnitRange{Int64}\n\njulia> keys_type(typeof(Axis(1:2)))\nUnitRange{Int64}\n\njulia> keys_type(UnitRange{Int})\nBase.OneTo{Int64}\n\n\n\n\n\n","category":"function"},{"location":"axis/#AxisIndices.indices","page":"The Axis","title":"AxisIndices.indices","text":"indices(x)\n\nReturns the indices corresponding to all axes of x.\n\nExamples\n\njulia> using AxisIndices\n\njulia> indices(AxisIndicesArray(ones(2,2), (2:3, 3:4)))\n(OneToMRange(2), OneToMRange(2))\n\n\n\n\n\nindices(x, i)\n\nReturns the indices corresponding to the i axis\n\nExamples\n\njulia> using AxisIndices\n\njulia> indices(AxisIndicesArray(ones(2,2), (2:3, 3:4)), 1)\nOneToMRange(2)\n\n\n\n\n\n","category":"function"},{"location":"axis/#AxisIndices.axes_keys","page":"The Axis","title":"AxisIndices.axes_keys","text":"axes_keys(x)\n\nReturns the keys corresponding to all axes of x.\n\nExamples\n\njulia> using AxisIndices\n\njulia> axes_keys(AxisIndicesArray(ones(2,2), (2:3, 3:4)))\n(UnitMRange(2:3), UnitMRange(3:4))\n\njulia> axes_keys(Axis(1:2))\n(1:2,)\n\n\n\n\n\naxes_keys(x, i)\n\nReturns the keys corresponding to the i axis\n\nExamples\n\njulia> using AxisIndices\n\njulia> axes_keys(AxisIndicesArray(ones(2,2), (2:3, 3:4)), 1)\nUnitMRange(2:3)\n\n\n\n\n\n","category":"function"},{"location":"axis/#AxisIndices.CombineStyle","page":"The Axis","title":"AxisIndices.CombineStyle","text":"CombineStyle\n\nDetermines the behavior of broadcast_axis, cat_axis, append_axis!.\n\n\n\n\n\n","category":"type"},{"location":"broadcasting_axes/#Broadcasting-Axes-1","page":"Broadcasting Axes","title":"Broadcasting Axes","text":"","category":"section"},{"location":"broadcasting_axes/#","page":"Broadcasting Axes","title":"Broadcasting Axes","text":"There are three things that determine the output of a broadcasting axes.","category":"page"},{"location":"broadcasting_axes/#","page":"Broadcasting Axes","title":"Broadcasting Axes","text":"Standard promotion\nKey specific promotion (or promotion over Real)\nOrder of arguments promotion","category":"page"},{"location":"broadcasting_axes/#","page":"Broadcasting Axes","title":"Broadcasting Axes","text":"Take the following vectors.","category":"page"},{"location":"broadcasting_axes/#","page":"Broadcasting Axes","title":"Broadcasting Axes","text":"julia> using AxisIndices\n\njulia> a = ones(3);\n\njulia> b = AxisIndicesArray(a, 2:4);\n\njulia> c = AxisIndicesArray(a, [\"1\", \"2\", \"3\"]);","category":"page"},{"location":"broadcasting_axes/#","page":"Broadcasting Axes","title":"Broadcasting Axes","text":"We assume the lack of a formal axis defined in a indicates that it's keys are unimportant. Therefore, we freely choose any keys that are formally defined elsewhere to belong to the new result of a broadcast statement. This is the kind of behavior one gets from standard type promotion.","category":"page"},{"location":"broadcasting_axes/#","page":"Broadcasting Axes","title":"Broadcasting Axes","text":"julia> axes_keys(a .+ b)\n(UnitMRange(2:4),)\n\njulia> axes_keys(b .+ a)\n(UnitMRange(2:4),)\n\njulia> axes_keys(a .+ c)\n([\"1\", \"2\", \"3\"],)\n\njulia> axes_keys(c .+ a)\n([\"1\", \"2\", \"3\"],)","category":"page"},{"location":"broadcasting_axes/#","page":"Broadcasting Axes","title":"Broadcasting Axes","text":"However, when we do the same with b and c they both have formally defined keys.","category":"page"},{"location":"broadcasting_axes/#","page":"Broadcasting Axes","title":"Broadcasting Axes","text":"julia> axes_keys(b .+ c)\n([\"2\", \"3\", \"4\"],)\n\njulia> axes_keys(c .+ b)\n([\"1\", \"2\", \"3\"],)","category":"page"},{"location":"broadcasting_axes/#","page":"Broadcasting Axes","title":"Broadcasting Axes","text":"Notice that all outputs become elements of String and a collection that are Vector. We can't depend upon the default promotion in base (e.g., promote(x, y)) because some keys won't have promote_rule defined for two key types. It may not be appropriate to define a promotion rule between something like Int and String in the base Julia library because there is not universally meaningful way to promote it without context. In this instance we clearly want to apply some sort of label along an axis and that label may or may not be intended to parse as an Int, so we always default to broadcasting the key type that is not a subtype of Real.","category":"page"},{"location":"broadcasting_axes/#","page":"Broadcasting Axes","title":"Broadcasting Axes","text":"julia> d = AxisIndicesArray(a, [:a, :b, :c]);\n\njulia> axes_keys(a .+ d, 1) == [:a, :b, :c]\ntrue","category":"page"},{"location":"broadcasting_axes/#","page":"Broadcasting Axes","title":"Broadcasting Axes","text":"The term key specific promotion is used because it is only sensible in the context of keys.","category":"page"},{"location":"broadcasting_axes/#","page":"Broadcasting Axes","title":"Broadcasting Axes","text":"Finally, if both key types are non Real then order of arguments determines promotion.","category":"page"},{"location":"broadcasting_axes/#","page":"Broadcasting Axes","title":"Broadcasting Axes","text":"julia> axes_keys(c .+ d)\n([\"1\", \"2\", \"3\"],)\n\njulia> axes_keys(d .+ c, 1) == [:a, :b, :c]\ntrue","category":"page"},{"location":"broadcasting_axes/#","page":"Broadcasting Axes","title":"Broadcasting Axes","text":"Customizing broadcasting behavior should be accomplished through either AxisIndices.CombineStyle or AxisIndices.broadcast_axis.","category":"page"},{"location":"broadcasting_axes/#","page":"Broadcasting Axes","title":"Broadcasting Axes","text":"AxisIndices.broadcast_axis","category":"page"},{"location":"broadcasting_axes/#AxisIndices.broadcast_axis","page":"Broadcasting Axes","title":"AxisIndices.broadcast_axis","text":"broadcast_axis(x, y) -> collection\nbroadcast_axis(::PromoteStyle, ::CombineStyle, x, y)\n\nReturns an axis given the axes x and y that are appropriate for a broadcasting operation.\n\nExamples\n\njulia> using AxisIndices\n\njulia> a, b = 1:10, Base.OneTo(10);\n\njulia> AxisIndices.broadcast_axis(a, SimpleAxis(b))\nSimpleAxis(1:10)\n\njulia> AxisIndices.broadcast_axis(a, b)\n1:10\n\njulia> AxisIndices.broadcast_axis(b, a)\n1:10\n\njulia> c = AxisIndices.broadcast_axis(a, SimpleAxis(b))\nSimpleAxis(1:10)\n\njulia> d = AxisIndices.broadcast_axis(SimpleAxis(b), a)\nSimpleAxis(1:10)\n\njulia> e = AxisIndices.broadcast_axis(c, d)\nSimpleAxis(1:10)\n\njulia> f = AxisIndices.broadcast_axis(Axis(a), a)\nAxis(1:10 => 1:10)\n\njulia> g = AxisIndices.broadcast_axis(a, Axis(b))\nAxis(Base.OneTo(10) => 1:10)\n\njulia> AxisIndices.broadcast_axis(f, g)\nAxis(1:10 => 1:10)\n\njulia> AxisIndices.broadcast_axis(Base.OneTo(10), Base.OneTo(10))\nBase.OneTo(10)\n\njulia> AxisIndices.broadcast_axis(1:10, Base.OneTo(10))\n1:10\n\nUsing combine allows combining axes that aren't appropriate for conventional promotion.\n\njulia> AxisIndices.broadcast_axis(1:2, string.(1:2))\n2-element Array{String,1}:\n \"1\"\n \"2\"\n\njulia> AxisIndices.broadcast_axis(1:2, Symbol.(1:2))\n2-element Array{Symbol,1}:\n Symbol(\"1\")\n Symbol(\"2\")\n\n\n\n\n\n","category":"function"},{"location":"compatibility/#Compatibility-1","page":"Compatibility","title":"Compatibility","text":"","category":"section"},{"location":"compatibility/#","page":"Compatibility","title":"Compatibility","text":"The following packages outside of the standard library have some form of support. In addition to creating awareness of existing functionality, the following provides users with a better idea of how exactly these packages are supported. This means features existing outside of those described here are not within the domain of intended coverage and users should seek support linked resources.","category":"page"},{"location":"compatibility/#MappedArrays-1","page":"Compatibility","title":"MappedArrays","text":"","category":"section"},{"location":"compatibility/#","page":"Compatibility","title":"Compatibility","text":"MappedArrays.jl allows \"lazy\" in-place elementwise transformations of arrays. Support is provided by overloading the mappedarray method, which AxisIndices does not export (i.e. users must using mappedArrays to get access to it). In order to avoid method ambiguities multi-mapping of mixed AbstractArray and AbstractAxisIndices cannot be provided. In other words, the current version can only support multi-mapping multiple AbstractAxisIndices.","category":"page"},{"location":"compatibility/#LinearAlgebra-1","page":"Compatibility","title":"LinearAlgebra","text":"","category":"section"},{"location":"compatibility/#Matrix-Multiplication-1","page":"Compatibility","title":"Matrix Multiplication","text":"","category":"section"},{"location":"compatibility/#","page":"Compatibility","title":"Compatibility","text":"AxisIndices.matmul_axes","category":"page"},{"location":"compatibility/#AxisIndices.matmul_axes","page":"Compatibility","title":"AxisIndices.matmul_axes","text":"matmul_axes(a, b) -> Tuple\n\nReturns the appropriate axes for the return of a * b where a and b are a vector or matrix.\n\nExamples\n\njulia> using AxisIndices\n\njulia> axs2, axs1 = (Axis(1:2), Axis(1:4)), (Axis(1:6),);\n\njulia> AxisIndices.matmul_axes(axs2, axs2)\n(Axis(1:2 => Base.OneTo(2)), Axis(1:4 => Base.OneTo(4)))\n\njulia> AxisIndices.matmul_axes(axs1, axs2)\n(Axis(1:6 => Base.OneTo(6)), Axis(1:4 => Base.OneTo(4)))\n\njulia> AxisIndices.matmul_axes(axs2, axs1)\n(Axis(1:2 => Base.OneTo(2)),)\n\njulia> AxisIndices.matmul_axes(axs1, axs1)\n()\n\njulia> AxisIndices.matmul_axes(rand(2, 4), rand(4, 2))\n(Base.OneTo(2), Base.OneTo(2))\n\njulia> AxisIndices.matmul_axes(CartesianAxes((2,4)), CartesianAxes((4, 2))) == AxisIndices.matmul_axes(rand(2, 4), rand(4, 2))\ntrue\n\n\n\n\n\n","category":"function"},{"location":"compatibility/#Diagonal-1","page":"Compatibility","title":"Diagonal","text":"","category":"section"},{"location":"compatibility/#","page":"Compatibility","title":"Compatibility","text":"AxisIndices.diagonal_axes","category":"page"},{"location":"compatibility/#AxisIndices.diagonal_axes","page":"Compatibility","title":"AxisIndices.diagonal_axes","text":"diagonal_axes(x::Tuple{<:AbstractAxis,<:AbstractAxis}) -> collection\n\nDetermines the appropriate axis for the resulting vector from a call to diag(::AxisIndicesMatrix). The default behavior is to place the smallest axis at the beginning of a call to combine (e.g., broadcast_axis(small_axis, big_axis)).\n\nExamples\n\njulia> using AxisIndices\n\njulia> AxisIndices.diagonal_axes((Axis(string.(2:5)), SimpleAxis(1:2)))\nAxis([\"1\", \"2\"] => UnitMRange(1:2))\n\njulia> AxisIndices.diagonal_axes((SimpleAxis(1:3), Axis(string.(2:5))))\nAxis([\"1\", \"2\", \"3\"] => UnitMRange(1:3))\n\n\n\n\n\n","category":"function"},{"location":"compatibility/#Factorizations-1","page":"Compatibility","title":"Factorizations","text":"","category":"section"},{"location":"compatibility/#","page":"Compatibility","title":"Compatibility","text":"AxisIndices.get_factorization","category":"page"},{"location":"compatibility/#AxisIndices.get_factorization","page":"Compatibility","title":"AxisIndices.get_factorization","text":"get_factorization(F::Factorization, A::AbstractAxisIndices, d::Symbol)\n\nUsed internally to compose an AxisIndicesArray for each component of a factor decomposition.\n\nQR Factorization\n\njulia> using AxisIndices, LinearAlgebra\n\njulia> m = AxisIndicesArray([1.0 2; 3 4], (Axis(2:3 => Base.OneTo(2)), Axis(3:4 => Base.OneTo(2))));\n\njulia> F = qr(m, Val(true));\n\njulia> keys.(axes(F.Q))\n(2:3, Base.OneTo(2))\n\njulia> keys.(axes(F.R))\n(Base.OneTo(2), 3:4)\n\njulia> keys.(axes(F.Q * F.R))\n(2:3, 3:4)\n\njulia> keys.(axes(F.p))\n(2:3,)\n\njulia> keys.(axes(F.P))\n(2:3, 2:3)\n\njulia> keys.(axes(F.P * AxisIndicesArray([1.0 2; 3 4], (2:3, 3:4))))\n(2:3, UnitMRange(3:4))\n\nLU Factorization\n\njulia> F = lu(m);\n\njulia> keys.(axes(F.L))\n(2:3, Base.OneTo(2))\n\njulia> keys.(axes(F.U))\n(Base.OneTo(2), 3:4)\n\njulia> keys.(axes(F.p))\n(2:3,)\n\njulia> keys.(axes(F.P))\n(2:3, 2:3)\n\njulia> keys.(axes(F.P * m))\n(2:3, 3:4)\n\njulia> keys.(axes(F.L * F.U))\n(2:3, 3:4)\n\nLQ Factorization\n\njulia> F = lq(m);\n\njulia> keys.(axes(F.L))\n(2:3, Base.OneTo(2))\n\njulia> keys.(axes(F.Q))\n(Base.OneTo(2), 3:4)\n\njulia> keys.(axes(F.L * F.Q))\n(2:3, 3:4)\n\nSVD Factorization\n\njulia> F = svd(m);\n\njulia> axes(F.U)\n(Axis(2:3 => Base.OneTo(2)), SimpleAxis(Base.OneTo(2)))\n\njulia> axes(F.V)\n(Axis(3:4 => Base.OneTo(2)), SimpleAxis(Base.OneTo(2)))\n\njulia> axes(F.Vt)\n(SimpleAxis(Base.OneTo(2)), Axis(3:4 => Base.OneTo(2)))\n\njulia> axes(F.U * Diagonal(F.S) * F.Vt)\n(Axis(2:3 => Base.OneTo(2)), Axis(3:4 => Base.OneTo(2)))\n\n\n\n\n\n","category":"function"},{"location":"acknowledgments/#Acknowledgments-1","page":"Acknowledgments","title":"Acknowledgments","text":"","category":"section"},{"location":"acknowledgments/#","page":"Acknowledgments","title":"Acknowledgments","text":"This package is the result of many people providing input to make it successful. Hopefully, it will continue to be a product of such collaborations. The following is an incomplete list of individuals who have helped me in some way get this package started. It's mainly a list of people who have tolerated my incessant queries into many minor details that led to this package.","category":"page"},{"location":"acknowledgments/#","page":"Acknowledgments","title":"Acknowledgments","text":"Eric Davies\nLyndon White\nMichael Abbott\nRafael Schouten\nTim Holy","category":"page"},{"location":"acknowledgments/#","page":"Acknowledgments","title":"Acknowledgments","text":"Also, anyone that has contributed to StaticArrays.jl and NamedDims.jl has probably helped.","category":"page"},{"location":"appending_axes/#Appending-Axes-1","page":"Appending Axes","title":"Appending Axes","text":"","category":"section"},{"location":"appending_axes/#","page":"Appending Axes","title":"Appending Axes","text":"Appending axes works similar to concatenating axes except that the first argument is mutated.","category":"page"},{"location":"appending_axes/#","page":"Appending Axes","title":"Appending Axes","text":"Customizing appending axes should be accomplished through either AxisIndices.CombineStyle or AxisIndices.append_axis!.","category":"page"},{"location":"appending_axes/#","page":"Appending Axes","title":"Appending Axes","text":"AxisIndices.append_axis!","category":"page"},{"location":"appending_axes/#AxisIndices.append_axis!","page":"Appending Axes","title":"AxisIndices.append_axis!","text":"append_axis!(x, y)\nappend_axis!(::CombineStyle, x, y)\n\nReturns the appended axes x and y.\n\nExamples\n\njulia> using AxisIndices\n\njulia> x, y = Axis(UnitMRange(1, 10)), SimpleAxis(UnitMRange(1, 10));\n\njulia> AxisIndices.append_axis!(x, y);\n\njulia> length(x)\n20\n\njulia> AxisIndices.append_axis!(y, x);\n\njulia> length(y)\n30\n\n\n\n\n\n","category":"function"},{"location":"quick_start/#Quick-Start-1","page":"Quick Start","title":"Quick Start","text":"","category":"section"},{"location":"quick_start/#","page":"Quick Start","title":"Quick Start","text":"Custom indexing only requires specifying a tuple of keys[1] for the indices of each dimension.","category":"page"},{"location":"quick_start/#","page":"Quick Start","title":"Quick Start","text":"julia> using AxisIndices\n\njulia> A = AxisIndicesArray(reshape(1:9, 3,3),\n               (2:4,        # first dimension has keys 2:4\n                3.0:5.0));  # second dimension has keys 3.0:5.0","category":"page"},{"location":"quick_start/#","page":"Quick Start","title":"Quick Start","text":"Most code should work just the same for an AxisIndicesArray...","category":"page"},{"location":"quick_start/#","page":"Quick Start","title":"Quick Start","text":"julia> A[1, 1]\n1\n\njulia> A[1:2, 1:2] == parent(A)[1:2, 1:2]\ntrue\n\njulia> sum(A) == sum(parent(A))\ntrue","category":"page"},{"location":"quick_start/#","page":"Quick Start","title":"Quick Start","text":"But now the indices of each dimension have keys that we can filter through.","category":"page"},{"location":"quick_start/#","page":"Quick Start","title":"Quick Start","text":"julia> A[==(2), ==(3.0)] == parent(A)[findfirst(==(2), 2:4), findfirst(==(3.0), 3.0:5.0)] == 1\ntrue\n\njulia> A[<(4), <(5.0)] == parent(A)[findall(<(4), 2:4), findall(<(5.0), 3.0:5.0)] == [1 4; 2 5]\ntrue","category":"page"},{"location":"quick_start/#","page":"Quick Start","title":"Quick Start","text":"Any value that is not a CartesianIndex or subtype of Real is considered a dedicated key type. In other words, it could never be used for default indexing and will be treated the same as the == filtering syntax above.","category":"page"},{"location":"quick_start/#","page":"Quick Start","title":"Quick Start","text":"julia> AxisIndicesArray([1, 2, 3], ([\"one\", \"two\", \"three\"],))[\"one\"]\n1","category":"page"},{"location":"quick_start/#","page":"Quick Start","title":"Quick Start","text":"Note that the first call only returns a single element, where the last call returns an array. This is because all keys must be unique so there can only be one value that returns true if filtering by ==, which is the same as indexing by 1 (e.g., only one index can equal 1). The last call uses operators that can produce any number of true values and the resulting output is an array. This is the same as indexing an array by any vector (i.e., returns another array).","category":"page"},{"location":"quick_start/#","page":"Quick Start","title":"Quick Start","text":"[1]: Terminology here is important here. Keys, indices, and axes each have a specific meaning. Throughout the documentation the following functional definitions apply:axis: maps a set of keys to a set of indices.\nindices: a set of integers (e.g., <:Integer) that locate the in memory locations of a elements.\nkeys: maps a set of any type to a set of indices","category":"page"},{"location":"coeftable/#Making-a-CoefTable-1","page":"CoefTable","title":"Making a CoefTable","text":"","category":"section"},{"location":"coeftable/#","page":"CoefTable","title":"CoefTable","text":"Let's see if we can recreate the coefficient table from StatsBase.jl.","category":"page"},{"location":"coeftable/#","page":"CoefTable","title":"CoefTable","text":"julia> using AxisIndices, DataFrames, GLM, Distributions\n\njulia> function coefarray(mm::StatsModels.TableRegressionModel; level::Real=0.95)\n           cc = coef(mm)\n           se = stderror(mm)\n           tt = cc ./ se\n           p = ccdf.(Ref(FDist(1, dof_residual(mm))), abs2.(tt))\n           ci = se*quantile(TDist(dof_residual(mm)), (1-level)/2)\n           levstr = isinteger(level*100) ? string(Integer(level*100)) : string(level*100)\n           ct = AxisIndicesArray(\n               hcat(cc,se,tt,p,cc+ci,cc-ci),\n               (coefnames(mm),\n               [\"Estimate\",\"Std. Error\",\"t value\",\"Pr(>|t|)\",\"Lower $levstr%\",\"Upper $levstr%\"])\n           )\n       end\ncoefarray (generic function with 1 method)\n\njulia> ols = lm(@formula(Y ~ X), DataFrame(X=[1,2,3], Y=[2,4,7]));\n\njulia> cfa = coefarray(ols)\n2-dimensional AxisIndicesArray{Float64,2,Array{Float64,2}...}\n                Estimate   Std. Error   t value   Pr(>|t|)   Lower 95%   Upper 95%\n  (Intercept)     -0.667        0.624    -1.069      0.479       -8.59       7.257\n            X        2.5        0.289      8.66      0.073      -1.168       6.168\n","category":"page"},{"location":"coeftable/#","page":"CoefTable","title":"CoefTable","text":"But we can do better. Let's use the underlying pretty_array method to get this into shape.","category":"page"},{"location":"coeftable/#","page":"CoefTable","title":"CoefTable","text":"julia> using PrettyTables\n\nctf = const array_text_format = TextFormat(\n    up_right_corner = ' ',\n    up_left_corner = ' ',\n    bottom_left_corner=' ',\n    bottom_right_corner= ' ',\n    up_intersection= 'â”€',\n    left_intersection= ' ',\n    right_intersection= ' ',\n    middle_intersection= 'â”€',\n    bottom_intersection= 'â”€',\n    column= ' ',\n    left_border= ' ',\n    right_border= ' ',\n    #    row= ' ',\n    top_line=true,\n    header_line=true,\n    bottom_line=true\n)\n\njulia> pretty_array(cfa; tf=ctf, linebreaks=false)\n â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n                Estimate   Std. Error   t value   Pr(>|t|)   Lower 95%   Upper 95%\n â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n  (Intercept)     -0.667        0.624    -1.069      0.479      -8.590       7.257\n            X      2.500        0.289     8.660      0.073      -1.168       6.168\n â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€","category":"page"},{"location":"coeftable/#","page":"CoefTable","title":"CoefTable","text":"This looks pretty good but the nicest part is that we can now treat this as a typical matrix.","category":"page"},{"location":"coeftable/#","page":"CoefTable","title":"CoefTable","text":"julia> cfa[1,\"Estimate\"]\n-0.6666666666666738\n\njulia> cfa[1:2,1:2]\n2-dimensional AxisIndicesArray{Float64,2,Array{Float64,2}...}\n                Estimate   Std. Error\n  (Intercept)     -0.667        0.624\n            X        2.5        0.289","category":"page"},{"location":"coeftable/#","page":"CoefTable","title":"CoefTable","text":"Because keys and indices are bound together we don't lose track of what each element is when we index.","category":"page"},{"location":"coeftable/#","page":"CoefTable","title":"CoefTable","text":"julia> cfa[1,:]\n1-dimensional AxisIndicesArray{Float64,1,Array{Float64,1}...}\n\n    Estimate   -0.667\n  Std. Error    0.624\n     t value   -1.069\n    Pr(>|t|)    0.479\n   Lower 95%    -8.59\n   Upper 95%    7.257\n","category":"page"},{"location":"concatenating_axes/#Concatenating-Axes-1","page":"Concatenating Axes","title":"Concatenating Axes","text":"","category":"section"},{"location":"concatenating_axes/#","page":"Concatenating Axes","title":"Concatenating Axes","text":"Concatenating axes can happen by one of the following:","category":"page"},{"location":"concatenating_axes/#","page":"Concatenating Axes","title":"Concatenating Axes","text":"Stacking two collections of completely unique elements\nResizing a range of values","category":"page"},{"location":"concatenating_axes/#","page":"Concatenating Axes","title":"Concatenating Axes","text":"The second only happens when the two collections provided are subtypes of AbstractRange.","category":"page"},{"location":"concatenating_axes/#","page":"Concatenating Axes","title":"Concatenating Axes","text":"Customizing concatenating axes should be accomplished through either AxisIndices.CombineStyle or AxisIndices.cat_axis!.","category":"page"},{"location":"concatenating_axes/#","page":"Concatenating Axes","title":"Concatenating Axes","text":"AxisIndices.cat_axis\nAxisIndices.cat_axes\nAxisIndices.hcat_axes\nAxisIndices.vcat_axes","category":"page"},{"location":"concatenating_axes/#AxisIndices.cat_axis","page":"Concatenating Axes","title":"AxisIndices.cat_axis","text":"cat_axis(x, y) -> cat_axis(CombineStyle(x, y), x, y)\ncat_axis(::CombineStyle, x, y) -> collection\n\nReturns the concatenated axes x and y.\n\nExamples\n\njulia> using AxisIndices\n\njulia> AxisIndices.cat_axis(Axis(UnitMRange(1, 10)), SimpleAxis(UnitMRange(1, 10)))\nAxis(UnitMRange(1:20) => UnitMRange(1:20))\n\njulia> AxisIndices.cat_axis(SimpleAxis(UnitMRange(1, 10)), SimpleAxis(UnitMRange(1, 10)))\nSimpleAxis(UnitMRange(1:20))\n\n\n\n\n\n","category":"function"},{"location":"concatenating_axes/#AxisIndices.cat_axes","page":"Concatenating Axes","title":"AxisIndices.cat_axes","text":"cat_axes(x, y, dims) -> Tuple\n\nReturns the appropriate axes for cat(x, y; dims). If any of dims are names then they should refer to the dimensions of x.\n\nExamples\n\njulia> using AxisIndices\n\njulia> AxisIndices.cat_axes(LinearAxes((2,3)), LinearAxes((2,3)), dims=(1,2))\n(SimpleAxis(Base.OneTo(4)), SimpleAxis(Base.OneTo(6)))\n\n\n\n\n\n","category":"function"},{"location":"concatenating_axes/#AxisIndices.hcat_axes","page":"Concatenating Axes","title":"AxisIndices.hcat_axes","text":"hcat_axes(x, y) -> Tuple\n\nReturns the appropriate axes for hcat(x, y).\n\nExamples\n\njulia> using AxisIndices\n\njulia> AxisIndices.hcat_axes((Axis(1:4), Axis(1:2)), (Axis(1:4), Axis(1:2)))\n(Axis(1:4 => Base.OneTo(4)), Axis(1:4 => Base.OneTo(4)))\n\njulia> a, b = [1; 2; 3; 4; 5], [6 7; 8 9; 10 11; 12 13; 14 15];\n\njulia> AxisIndices.hcat_axes(a, b) == axes(hcat(a, b))\ntrue\n\njulia> c, d = CartesianAxes((Axis(1:5),)), CartesianAxes((Axis(1:5), Axis(1:2)));\n\njulia> length.(AxisIndices.hcat_axes(c, d)) == length.(AxisIndices.hcat_axes(a, b))\ntrue\n\n\n\n\n\n","category":"function"},{"location":"concatenating_axes/#AxisIndices.vcat_axes","page":"Concatenating Axes","title":"AxisIndices.vcat_axes","text":"vcat_axes(x, y) -> Tuple\n\nReturns the appropriate axes for vcat(x, y).\n\nExamples\n\njulia> using AxisIndices\n\njulia> AxisIndices.vcat_axes((Axis(1:2), Axis(1:4)), (Axis(1:2), Axis(1:4)))\n(Axis(1:4 => Base.OneTo(4)), Axis(1:4 => Base.OneTo(4)))\n\njulia> a, b = [1 2 3 4 5], [6 7 8 9 10; 11 12 13 14 15];\n\njulia> AxisIndices.vcat_axes(a, b) == axes(vcat(a, b))\ntrue\n\njulia> c, d = LinearAxes((1:1, 1:5,)), LinearAxes((1:2, 1:5));\n\njulia> length.(AxisIndices.vcat_axes(c, d)) == length.(AxisIndices.vcat_axes(a, b))\ntrue\n\n\n\n\n\n","category":"function"},{"location":"time/#TimeAxis-1","page":"TimeAxis","title":"TimeAxis","text":"","category":"section"},{"location":"time/#","page":"TimeAxis","title":"TimeAxis","text":"Here we define an axis that specifically supports time. This first section defines the minimum keys, values, similar_type and constructors for the TimeAxis type.","category":"page"},{"location":"time/#","page":"TimeAxis","title":"TimeAxis","text":"julia> using AxisIndices, Dates\n\njulia> struct TimeAxis{K<:Dates.AbstractTime,V,Ks,Vs} <: AbstractAxis{K,V,Ks,Vs}\n           axis::Axis{K,V,Ks,Vs}\n           times::Dict{Symbol,Pair{K,K}}\n           function TimeAxis{K,V,Ks,Vs}(axis::Axis{K,V,Ks,Vs}, times::Dict{Symbol,Pair{K,K}}) where {K,V,Ks,Vs}\n               return new{K,V,Ks,Vs}(axis, times)\n           end\n           function TimeAxis{K,V,Ks,Vs}(args...; kwargs...) where {K,V,Ks,Vs}\n               d = Dict{Symbol,Pair{K,K}}()\n               for (k,v) in kwargs\n                   d[k] = v\n               end\n               return new{K,V,Ks,Vs}(Axis{K,V,Ks,Vs}(args...), d)\n           end\n           function TimeAxis(args...; kwargs...)\n               ax = Axis(args...)\n               d = Dict{Symbol,Pair{keytype(ax),keytype(ax)}}()\n               for (k,v) in kwargs\n                   d[k] = v\n               end\n               return new{keytype(ax),valtype(ax),keys_type(ax),values_type(ax)}(ax, d)\n           end\n       end\n\njulia> Base.keys(t::TimeAxis) = keys(getfield(t, :axis))\n\njulia> Base.values(t::TimeAxis) = values(getfield(t, :axis))\n\njulia> function AxisIndices.similar_type(\n           t::TimeAxis{K,V,Ks,Vs},\n           new_keys_type::Type=Ks,\n           new_values_type::Type=Vs\n          ) where {K,V,Ks,Vs}\n           return TimeAxis{eltype(new_keys_type),eltype(new_values_type),new_keys_type,new_values_type}\n       end","category":"page"},{"location":"time/#","page":"TimeAxis","title":"TimeAxis","text":"Here are some extras to make it more useful.","category":"page"},{"location":"time/#","page":"TimeAxis","title":"TimeAxis","text":"julia> Base.setindex!(t::TimeAxis, val, i::Symbol) = t.times[i] = val\n\njulia> function Base.to_index(t::TimeAxis, i::Symbol)\n           f, l = t.times[i]\n           return Base.to_index(t, and(>=(f), <=(l)))\n       end","category":"page"},{"location":"time/#","page":"TimeAxis","title":"TimeAxis","text":"Now we can access the time points of this access by the Symbols that correspond to intervals of time.","category":"page"},{"location":"time/#","page":"TimeAxis","title":"TimeAxis","text":"julia> t = TimeAxis(Second(1):Second(1):Second(10));\n\njulia> t[:time_1] = Pair(Second(1), Second(3));\n\njulia> t[:time_1] == 1:3\ntrue","category":"page"},{"location":"time/#","page":"TimeAxis","title":"TimeAxis","text":"And now we have a time series array.","category":"page"},{"location":"time/#","page":"TimeAxis","title":"TimeAxis","text":"julia> x = AxisIndicesArray(collect(1:2:20), t);\n\njulia> x[:time_1]\n1-dimensional AxisIndicesArray{Int64,1,Array{Int64,1}...}\n\n   1 second   1.0\n  2 seconds   3.0\n  3 seconds   5.0\n\n","category":"page"},{"location":"#AxisIndices-1","page":"Introduction","title":"AxisIndices","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"The goals of this package are:","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Facilitate multidimensional indexing (e.g., instance_of_an_array[indices]) that supports semantic user facing indices (e.g., indices = Second(1)).\nAccomplishing the first goal should not interfere in the ability to perform the vast majority of array related methods (e.g, vcat, append!, etc.).\nIt should be easy to implement new subtypes of AbstractAxis that accommodate novel behavior and needs.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"These goals are accomplished predominantly through the AbstractAxis type. It is a subtype of AbstractUnitRange{<:Integer} with an additional interface for creating keys and interacting with them. This additional interface is intended to be easily extended to new types that may be needed for a variety of different situations. An additional AxisIndicesArray type is provided that uses any subtype of AbstractAxis for each axis. However, many methods are provided and documented internally so that it's easy for users to alter the behavior of an AxisIndicesArray with a new AbstractAxis subtype or create an entirely unique multidimensional structure.","category":"page"}]
}
