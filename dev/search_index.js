var documenterSearchIndex = {"docs":
[{"location":"axes_to_arrays/#Axes-to-Arrays-1","page":"Axes to Arrays","title":"Axes to Arrays","text":"","category":"section"},{"location":"axes_to_arrays/#","page":"Axes to Arrays","title":"Axes to Arrays","text":"Most of the methods up to this point are potentially useful for manipulating an axis independent of a parent structure that it may belong to. However, we want it to be easy to use an AbstractAxis in a variety of settings. The following methods are likely to only be useful when extending the use of a multidimensional arrays to use the AbstractAxis interface.","category":"page"},{"location":"axisindicesarray/#Arrays-With-Axes-1","page":"Arrays With Axes","title":"Arrays With Axes","text":"","category":"section"},{"location":"axisindicesarray/#","page":"Arrays With Axes","title":"Arrays With Axes","text":"The following describes many of the available methods for accomodating multidimensional manipulation of types that have axes.","category":"page"},{"location":"axisindicesarray/#AxisIndicesArray-1","page":"Arrays With Axes","title":"AxisIndicesArray","text":"","category":"section"},{"location":"axisindicesarray/#","page":"Arrays With Axes","title":"Arrays With Axes","text":"AxisIndicesArray is provided as a convenient subtype of AbstractArray for using instances of AbstractAxis. The implementation is meant to be basic and have sane defaults that can be overridden as necessary. In other words, default methods for manipulating arrays that return an AxisIndicesArray should not cause unexpected downstream behavior for users. However, it should also be possible to change the behavior of an AxisIndicesArray through unique subtypes of AbstractAxis.","category":"page"},{"location":"axisindicesarray/#","page":"Arrays With Axes","title":"Arrays With Axes","text":"AxisIndices.AxisIndicesArray","category":"page"},{"location":"axisindicesarray/#AxisIndices.AxisIndicesArray","page":"Arrays With Axes","title":"AxisIndices.AxisIndicesArray","text":"AxisIndicesArray(parent_array, tuple_of_keys) -> AxisIndicesArray(parent_array, Axis.(tuple_of_keys))\nAxisIndicesArray(parent_array, tuple_of_axis) -> AxisIndicesArray\n\nAn array struct that wraps any parent array and assigns it an AbstractAxis for each dimension. The first argument is the parent array and the second argument is a tuple of subtypes to AbstractAxis or keys that will be converted to subtypes of AbstractAxis with the provided keys.\n\nExamples\n\njulia> using AxisIndices\n\njulia> A = AxisIndicesArray(reshape(1:9, 3,3), (2:4, 3.0:5.0));\n\njulia> A[1, 1]\n1\n\njulia> A[==(2), ==(3.0)]\n1\n\njulia> A[1:2, 1:2] == [1 4; 2 5]\ntrue\n\njulia> A[<(4), <(5.0)] == [1 4; 2 5]\ntrue\n\n\n\n\n\n","category":"type"},{"location":"axisindicesarray/#Concatenating-Arrays-With-Axes-1","page":"Arrays With Axes","title":"Concatenating Arrays With Axes","text":"","category":"section"},{"location":"axisindicesarray/#","page":"Arrays With Axes","title":"Arrays With Axes","text":"AxisIndices.cat_axes\nAxisIndices.hcat_axes\nAxisIndices.vcat_axes\nAxisIndices.cat_axis\nAxisIndices.cat_values\nAxisIndices.cat_keys","category":"page"},{"location":"axisindicesarray/#AxisIndices.cat_axes","page":"Arrays With Axes","title":"AxisIndices.cat_axes","text":"cat_axes(x, y, dims) -> Tuple\n\nReturns the appropriate axes for cat(x, y; dims). If any of dims are names then they should refer to the dimensions of x.\n\nExamples\n\njulia> using AxisIndices\n\njulia> cat_axes(LinearAxes((2,3)), LinearAxes((2,3)), dims=(1,2))\n(SimpleAxis(Base.OneTo(4)), SimpleAxis(Base.OneTo(6)))\n\n\n\n\n\n","category":"function"},{"location":"axisindicesarray/#AxisIndices.hcat_axes","page":"Arrays With Axes","title":"AxisIndices.hcat_axes","text":"hcat_axes(x, y) -> Tuple\n\nReturns the appropriate axes for hcat(x, y).\n\nExamples\n\njulia> using AxisIndices\n\njulia> hcat_axes((Axis(1:4), Axis(1:2)), (Axis(1:4), Axis(1:2)))\n(Axis(1:4 => Base.OneTo(4)), Axis(1:4 => Base.OneTo(4)))\n\njulia> a, b = [1; 2; 3; 4; 5], [6 7; 8 9; 10 11; 12 13; 14 15];\n\njulia> hcat_axes(a, b) == axes(hcat(a, b))\ntrue\n\njulia> c, d = CartesianAxes((Axis(1:5),)), CartesianAxes((Axis(1:5), Axis(1:2)));\n\njulia> length.(hcat_axes(c, d)) == length.(hcat_axes(a, b))\ntrue\n\n\n\n\n\n","category":"function"},{"location":"axisindicesarray/#AxisIndices.vcat_axes","page":"Arrays With Axes","title":"AxisIndices.vcat_axes","text":"vcat_axes(x, y) -> Tuple\n\nReturns the appropriate axes for vcat(x, y).\n\nExamples\n\njulia> using AxisIndices\n\njulia> vcat_axes((Axis(1:2), Axis(1:4)), (Axis(1:2), Axis(1:4)))\n(Axis(1:4 => Base.OneTo(4)), Axis(1:4 => Base.OneTo(4)))\n\njulia> a, b = [1 2 3 4 5], [6 7 8 9 10; 11 12 13 14 15];\n\njulia> vcat_axes(a, b) == axes(vcat(a, b))\ntrue\n\njulia> c, d = LinearAxes((1:1, 1:5,)), LinearAxes((1:2, 1:5));\n\njulia> length.(vcat_axes(c, d)) == length.(vcat_axes(a, b))\ntrue\n\n\n\n\n\n","category":"function"},{"location":"axisindicesarray/#AxisIndices.cat_axis","page":"Arrays With Axes","title":"AxisIndices.cat_axis","text":"cat_axis(x, y)\n\nReturns the concatenation of the axes x and y. New subtypes of AbstractAxis must implement a unique cat_axis method.\n\n\n\n\n\n","category":"function"},{"location":"axisindicesarray/#AxisIndices.cat_values","page":"Arrays With Axes","title":"AxisIndices.cat_values","text":"cat_values(x, y)\n\nReturns the appropriate values of the x and y index within the operation cat_axis(x, y)\n\nSee also: cat_axis\n\n\n\n\n\n","category":"function"},{"location":"axisindicesarray/#AxisIndices.cat_keys","page":"Arrays With Axes","title":"AxisIndices.cat_keys","text":"cat_keys(x, y)\n\nReturns the appropriate keys of the x and y index within the operation cat_axis(x, y)\n\nSee also: cat_axis\n\n\n\n\n\n","category":"function"},{"location":"axisindicesarray/#Mutating-Methods-1","page":"Arrays With Axes","title":"Mutating Methods","text":"","category":"section"},{"location":"axisindicesarray/#","page":"Arrays With Axes","title":"Arrays With Axes","text":"AxisIndices.append_axis\nAxisIndices.append_axis!\nAxisIndices.append_keys\nAxisIndices.append_values","category":"page"},{"location":"axisindicesarray/#AxisIndices.append_axis","page":"Arrays With Axes","title":"AxisIndices.append_axis","text":"append_axis(x, y)\n\nReturns the appended axes x and y. New subtypes of AbstractAxis must implement a unique append_axis method.\n\nExamples\n\njulia> using AxisIndices\n\njulia> append_axis(Axis(UnitMRange(1, 10)), SimpleAxis(UnitMRange(1, 10)))\nAxis(UnitMRange(1:20) => UnitMRange(1:20))\n\njulia> append_axis(SimpleAxis(UnitMRange(1, 10)), SimpleAxis(UnitMRange(1, 10)))\nSimpleAxis(UnitMRange(1:20))\n\n\n\n\n\n","category":"function"},{"location":"axisindicesarray/#AxisIndices.append_axis!","page":"Arrays With Axes","title":"AxisIndices.append_axis!","text":"append_axis!(x, y)\n\nReturns the appended axes x and y. New subtypes of AbstractAxis must implement a unique append_axis! method.\n\nExamples\n\njulia> using AxisIndices\n\njulia> x, y = Axis(UnitMRange(1, 10)), SimpleAxis(UnitMRange(1, 10));\n\njulia> append_axis!(x, y);\n\njulia> length(x)\n20\n\njulia> append_axis!(y, x);\n\njulia> length(y)\n30\n\n\n\n\n\n","category":"function"},{"location":"axisindicesarray/#AxisIndices.append_keys","page":"Arrays With Axes","title":"AxisIndices.append_keys","text":"append_keys(x, y)\n\nReturns the appropriate keys of and index within the operation append_axis(x, y)\n\nSee also: append_axis\n\n\n\n\n\n","category":"function"},{"location":"axisindicesarray/#AxisIndices.append_values","page":"Arrays With Axes","title":"AxisIndices.append_values","text":"append_values(x, y)\n\nReturns the appropriate values of and index within the operation append_axis(x, y)\n\nSee also: append_axis\n\n\n\n\n\n","category":"function"},{"location":"axisindicesarray/#Swapping-Dimensions-1","page":"Arrays With Axes","title":"Swapping Dimensions","text":"","category":"section"},{"location":"axisindicesarray/#Drop-Dimensions-1","page":"Arrays With Axes","title":"Drop Dimensions","text":"","category":"section"},{"location":"axisindicesarray/#","page":"Arrays With Axes","title":"Arrays With Axes","text":"AxisIndices.drop_axes","category":"page"},{"location":"axisindicesarray/#AxisIndices.drop_axes","page":"Arrays With Axes","title":"AxisIndices.drop_axes","text":"drop_axes(x, dims)\n\nReturns all axes of x except for those identified by dims. Elements of dims must be unique integers or symbols corresponding to the dimensions or names of dimensions of x.\n\nExamples\n\njulia> using AxisIndices\n\njulia> axs = (Axis(1:5), Axis(1:10));\n\njulia> drop_axes(axs, 1)\n(Axis(1:10 => Base.OneTo(10)),)\n\njulia> drop_axes(axs, 2)\n(Axis(1:5 => Base.OneTo(5)),)\n\njulia> drop_axes(rand(2, 4), 2)\n(Base.OneTo(2),)\n\n\n\n\n\n","category":"function"},{"location":"axisindicesarray/#Permute-Dimensions-1","page":"Arrays With Axes","title":"Permute Dimensions","text":"","category":"section"},{"location":"axisindicesarray/#","page":"Arrays With Axes","title":"Arrays With Axes","text":"AxisIndices.permute_axes","category":"page"},{"location":"axisindicesarray/#AxisIndices.permute_axes","page":"Arrays With Axes","title":"AxisIndices.permute_axes","text":"permute_axes(x::AbstractArray, p::Tuple) = permute_axes(axes(x), p)\npermute_axes(x::NTuple{N}, p::NTuple{N}) -> NTuple{N}\n\nReturns axes of x in the order of p.\n\nExamples\n\njulia> using AxisIndices\n\njulia> permute_axes(rand(2, 4, 6), (1, 3, 2))\n(Base.OneTo(2), Base.OneTo(6), Base.OneTo(4))\n\njulia> permute_axes((Axis(1:2), Axis(1:4), Axis(1:6)), (1, 3, 2))\n(Axis(1:2 => Base.OneTo(2)), Axis(1:6 => Base.OneTo(6)), Axis(1:4 => Base.OneTo(4)))\n\n\n\n\n\npermute_axes(x::AbstractVector)\n\nReturns the permuted axes of x as axes of size 1 Ã— length(x)\n\nExamples\n\njulia> using AxisIndices\n\njulia> length.(permute_axes(rand(4))) == (1, 4)\ntrue\n\njulia> permute_axes((Axis(1:4),))\n(SimpleAxis(Base.OneTo(1)), Axis(1:4 => Base.OneTo(4)))\n\njulia> permute_axes((Axis(mrange(1, 4)),))\n(SimpleAxis(OneToMRange(1)), Axis(UnitMRange(1:4) => OneToMRange(4)))\n\njulia> permute_axes((Axis(srange(1, 4)),))\n(SimpleAxis(OneToSRange(1)), Axis(UnitSRange(1:4) => OneToSRange(4)))\n\n\n\n\n\npermute_axes(m::AbstractMatrix) -> NTuple{2}\n\nPermute the axes of the matrix m, by flipping the elements across the diagonal of the matrix. Differs from LinearAlgebra's transpose in that the operation is not recursive.\n\nExamples\n\njulia> using AxisIndices\n\njulia> permute_axes(rand(4, 2))\n(Base.OneTo(2), Base.OneTo(4))\n\njulia> permute_axes((Axis(1:4), Axis(1:2)))\n(Axis(1:2 => Base.OneTo(2)), Axis(1:4 => Base.OneTo(4)))\n\n\n\n\n\n","category":"function"},{"location":"axisindicesarray/#Covariance-and-Correlation-1","page":"Arrays With Axes","title":"Covariance and Correlation","text":"","category":"section"},{"location":"axisindicesarray/#","page":"Arrays With Axes","title":"Arrays With Axes","text":"AxisIndices.covcor_axes","category":"page"},{"location":"axisindicesarray/#AxisIndices.covcor_axes","page":"Arrays With Axes","title":"AxisIndices.covcor_axes","text":"covcor_axes(x, dim) -> NTuple{2}\n\nReturns appropriate axes for a cov or var method on array x.\n\nExamples\n\njulia> using AxisIndices\n\njulia> covcor_axes(rand(2,4), 1)\n(Base.OneTo(4), Base.OneTo(4))\n\njulia> covcor_axes((Axis(1:4), Axis(1:6)), 2)\n(Axis(1:4 => Base.OneTo(4)), Axis(1:4 => Base.OneTo(4)))\n\njulia> covcor_axes((Axis(1:4), Axis(1:4)), 1)\n(Axis(1:4 => Base.OneTo(4)), Axis(1:4 => Base.OneTo(4)))\n\nEach axis is resized to equal to the smallest sized dimension if given a dimensional argument greater than 2.\n\njulia> covcor_axes((Axis(2:4), Axis(3:4)), 3)\n(Axis(2:3 => Base.OneTo(2)), Axis(3:4 => Base.OneTo(2)))\n\n\n\n\n\n","category":"function"},{"location":"axisindicesarray/#Linear-Algebra-1","page":"Arrays With Axes","title":"Linear Algebra","text":"","category":"section"},{"location":"axisindicesarray/#Inverse-Array-1","page":"Arrays With Axes","title":"Inverse Array","text":"","category":"section"},{"location":"axisindicesarray/#","page":"Arrays With Axes","title":"Arrays With Axes","text":"AxisIndices.inverse_axes","category":"page"},{"location":"axisindicesarray/#AxisIndices.inverse_axes","page":"Arrays With Axes","title":"AxisIndices.inverse_axes","text":"inverse_axes(a::AbstractMatrix) = inverse_axes(axes(a))\ninverse_axes(a::Tuple{I1,I2}) -> Tuple{I2,I1}\n\nReturns the inverted axes of a, corresponding to the inv method from the  LinearAlgebra package in the standard library.\n\nExamples\n\njulia> using AxisIndices\n\njulia> inverse_axes(rand(2,4))\n(Base.OneTo(4), Base.OneTo(2))\n\njulia> inverse_axes((Axis(1:2), Axis(1:4)))\n(Axis(1:4 => Base.OneTo(4)), Axis(1:2 => Base.OneTo(2)))\n\n\n\n\n\n","category":"function"},{"location":"axisindicesarray/#Matrix-Multiplication-1","page":"Arrays With Axes","title":"Matrix Multiplication","text":"","category":"section"},{"location":"axisindicesarray/#","page":"Arrays With Axes","title":"Arrays With Axes","text":"AxisIndices.matmul_axes","category":"page"},{"location":"axisindicesarray/#AxisIndices.matmul_axes","page":"Arrays With Axes","title":"AxisIndices.matmul_axes","text":"matmul_axes(a, b) -> Tuple\n\nReturns the appropriate axes for the return of a * b where a and b are a vector or matrix.\n\nExamples\n\njulia> using AxisIndices\n\njulia> axs2, axs1 = (Axis(1:2), Axis(1:4)), (Axis(1:6),);\n\njulia> matmul_axes(axs2, axs2)\n(Axis(1:2 => Base.OneTo(2)), Axis(1:4 => Base.OneTo(4)))\n\njulia> matmul_axes(axs1, axs2)\n(Axis(1:6 => Base.OneTo(6)), Axis(1:4 => Base.OneTo(4)))\n\njulia> matmul_axes(axs2, axs1)\n(Axis(1:2 => Base.OneTo(2)),)\n\njulia> matmul_axes(axs1, axs1)\n()\n\njulia> matmul_axes(rand(2, 4), rand(4, 2))\n(Base.OneTo(2), Base.OneTo(2))\n\njulia> matmul_axes(CartesianAxes((2,4)), CartesianAxes((4, 2))) == matmul_axes(rand(2, 4), rand(4, 2))\ntrue\n\n\n\n\n\n","category":"function"},{"location":"axisindicesarray/#Diagonal-1","page":"Arrays With Axes","title":"Diagonal","text":"","category":"section"},{"location":"axisindicesarray/#","page":"Arrays With Axes","title":"Arrays With Axes","text":"AxisIndices.diagonal_axes","category":"page"},{"location":"axisindicesarray/#AxisIndices.diagonal_axes","page":"Arrays With Axes","title":"AxisIndices.diagonal_axes","text":"diagonal_axes(x::Tuple{<:AbstractAxis,<:AbstractAxis}) -> collection\n\nDetermines the appropriate axis for the resulting vector from a call to diag(::AxisIndicesMatrix). The default behavior is to place the smallest axis at the beginning of a call to combine_axis (e.g., combine_axis(small_axis, big_axis)).\n\nExamples\n\njulia> using AxisIndices\n\njulia> AxisIndices.diagonal_axes((Axis(string.(2:5)), SimpleAxis(1:2)))\nAxis([\"1\", \"2\"] => UnitMRange(1:2))\n\njulia> AxisIndices.diagonal_axes((SimpleAxis(1:3), Axis(string.(2:5))))\nAxis([\"1\", \"2\", \"3\"] => UnitMRange(1:3))\n\n\n\n\n\n","category":"function"},{"location":"axisindicesarray/#Factorizations-1","page":"Arrays With Axes","title":"Factorizations","text":"","category":"section"},{"location":"axisindicesarray/#","page":"Arrays With Axes","title":"Arrays With Axes","text":"AxisIndices.get_factorization","category":"page"},{"location":"axisindicesarray/#AxisIndices.get_factorization","page":"Arrays With Axes","title":"AxisIndices.get_factorization","text":"get_factorization(F::Factorization, axs::NTuple{2,Any}, d::Symbol)\n\nUsed internally to compose an AxisIndicesArray for each component of a factor decomposition.\n\nQR Factorization\n\njulia> using AxisIndices, LinearAlgebra\n\njulia> m = AxisIndicesArray([1.0 2; 3 4], (Axis(2:3 => Base.OneTo(2)), Axis(3:4 => Base.OneTo(2))));\n\njulia> F = qr(m, Val(true));\n\njulia> keys.(axes(F.Q))\n(2:3, Base.OneTo(2))\n\njulia> keys.(axes(F.R))\n(Base.OneTo(2), 3:4)\n\njulia> keys.(axes(F.Q * F.R))\n(2:3, 3:4)\n\njulia> keys.(axes(F.p))\n(2:3,)\n\njulia> keys.(axes(F.P))\n(2:3, 2:3)\n\njulia> keys.(axes(F.P * AxisIndicesArray([1.0 2; 3 4], (2:3, 3:4))))\n(2:3, 3:4)\n\nLU Factorization\n\njulia> F = lu(m);\n\njulia> keys.(axes(F.L))\n(2:3, Base.OneTo(2))\n\njulia> keys.(axes(F.U))\n(Base.OneTo(2), 3:4)\n\njulia> keys.(axes(F.p))\n(2:3,)\n\njulia> keys.(axes(F.P))\n(2:3, 2:3)\n\njulia> keys.(axes(F.P * m))\n(2:3, 3:4)\n\njulia> keys.(axes(F.L * F.U))\n(2:3, 3:4)\n\nLQ Factorization\n\njulia> F = lq(m);\n\njulia> keys.(axes(F.L))\n(2:3, Base.OneTo(2))\n\njulia> keys.(axes(F.Q))\n(Base.OneTo(2), 3:4)\n\njulia> keys.(axes(F.L * F.Q))\n(2:3, 3:4)\n\nSVD Factorization\n\njulia> F = svd(m);\n\njulia> axes(F.U)\n(Axis(2:3 => Base.OneTo(2)), SimpleAxis(Base.OneTo(2)))\n\njulia> axes(F.V)\n(Axis(3:4 => Base.OneTo(2)), SimpleAxis(Base.OneTo(2)))\n\njulia> axes(F.Vt)\n(SimpleAxis(Base.OneTo(2)), Axis(3:4 => Base.OneTo(2)))\n\njulia> axes(F.U * Diagonal(F.S) * F.Vt)\n(Axis(2:3 => Base.OneTo(2)), Axis(3:4 => Base.OneTo(2)))\n\n\n\n\n\n","category":"function"},{"location":"axis/#The-Axis-Interface-1","page":"The Axis","title":"The Axis Interface","text":"","category":"section"},{"location":"axis/#","page":"The Axis","title":"The Axis","text":"The following describes the components necessary to construct and manipulate existing and new subtypes of AbstractAxis.","category":"page"},{"location":"axis/#Introduction-1","page":"The Axis","title":"Introduction","text":"","category":"section"},{"location":"axis/#","page":"The Axis","title":"The Axis","text":"The supertype to all axis types herein is the AbstractAxis, which is a subtype of AbstractUnitRange{<:Integer}.","category":"page"},{"location":"axis/#","page":"The Axis","title":"The Axis","text":"The vocabulary can get a bit a tricky here and documentation tries to stick to these functional definitions:","category":"page"},{"location":"axis/#","page":"The Axis","title":"The Axis","text":"axis: maps a set of keys to a set of indices.\nindices: a set of integers (e.g., <:Integer) that locate the in memory locations of a elements.\nkeys: maps a set of any type to a set of indices","category":"page"},{"location":"axis/#","page":"The Axis","title":"The Axis","text":"If we have a set of keys a b c and a set of indices 1 2 3 then the key a maps to the index 1. Given these definitions, the AbstractAxis differs from the classic dictionary in the following two ways:","category":"page"},{"location":"axis/#","page":"The Axis","title":"The Axis","text":"The valtype of AbstractAxis is always an integer.\nThe values are always unique and continuous.","category":"page"},{"location":"axis/#","page":"The Axis","title":"The Axis","text":"The two main axis types defined here are Axis and SimpleAxis. The standard syntax for indexing doesn't change at all for these types.","category":"page"},{"location":"axis/#","page":"The Axis","title":"The Axis","text":"julia> using AxisIndices, Dates\n\njulia> sa = SimpleAxis(1:10)\nSimpleAxis(1:10)\n\njulia> sa[2]\n2\n\njulia> sa[>(2)]\nSimpleAxis(3:10)\n\njulia> a = Axis(1:10)\nAxis(1:10 => Base.OneTo(10))\n\njulia> a[2]\n2\n\njulia> a[2:3]\nAxis(2:3 => 2:3)","category":"page"},{"location":"axis/#","page":"The Axis","title":"The Axis","text":"But now we can also use functions to index by the keys of an AbstractAxis.","category":"page"},{"location":"axis/#","page":"The Axis","title":"The Axis","text":"julia> a = Axis(2.0:11.0, 1:10)\nAxis(2.0:1.0:11.0 => 1:10)\n\njulia> a[1]\n1\n\njulia> a[isequal(2.0)]\n1\n\njulia> a[>(2)]\nAxis(3.0:1.0:11.0 => 2:10)\n\njulia> a[>(2.0)]\nAxis(3.0:1.0:11.0 => 2:10)\n\njulia> a[and(>(2.0), <(8.0))]\nAxis(3.0:1.0:7.0 => 2:6)\n\njulia> sa[in(3:5)]\nSimpleAxis(3:5)","category":"page"},{"location":"axis/#","page":"The Axis","title":"The Axis","text":"This also allows certain syntax special treatment because they are obviously not referring to traditional integer based indexing.","category":"page"},{"location":"axis/#","page":"The Axis","title":"The Axis","text":"julia> x, y, z = Axis((:one, :two, :three)), Axis([\"one\", \"two\", \"three\"]), Axis(Second(1):Second(1):Second(3));\n\njulia> x[:one]\n1\n\njulia> x[:one] == y[\"one\"] == z[Second(1)]\ntrue\n\njulia> x[[:one, :two]]\n2-element Array{Int64,1}:\n 1\n 2","category":"page"},{"location":"axis/#","page":"The Axis","title":"The Axis","text":"Note in the last example that a vector was returned instead of an AbstractAxis. An AbstractAxis is a subtype of AbstractUnitRange and therefore cannot be reformed after any operation that does not guarantee the return of another unit range. This is similar to the behavior of UnitRange in base.","category":"page"},{"location":"axis/#How-Does-It-Work?-1","page":"The Axis","title":"How Does It Work?","text":"","category":"section"},{"location":"axis/#","page":"The Axis","title":"The Axis","text":"This package makes a small alteration in the indexing pipeline for arrays from base. Where an array typically passes indices along a similar path to:","category":"page"},{"location":"axis/#","page":"The Axis","title":"The Axis","text":"getindex(A::Array, i1, i2, i3) -> to_indices(A, axes(), (i1, i2, i3))\nto_indices(A, (ax1, ax2, ax3), (i1, i2, i3)) ->\n(to_index(A, i1), to_index(A, i2), to_index(A, i3)) -> I\n_getindex(A, I)","category":"page"},{"location":"axis/#","page":"The Axis","title":"The Axis","text":"This package does:","category":"page"},{"location":"axis/#","page":"The Axis","title":"The Axis","text":"getindex(A::Array, i1, i2, i3) -> to_indices(A, axes(), (i1, i2, i3))\nto_indices(A, (ax1, ax2, ax3), (i1, i2, i3)) ->\n(to_index(ax1, i1), to_index(ax2, i2), to_index(ax3, i3)) -> I\n_getindex(A, I)","category":"page"},{"location":"axis/#","page":"The Axis","title":"The Axis","text":"This allows customizing the initial arguments given to getindex per each axis instead of by the array type or the type of i1/2/3.","category":"page"},{"location":"axis/#Performance-1","page":"The Axis","title":"Performance","text":"","category":"section"},{"location":"axis/#","page":"The Axis","title":"The Axis","text":"Indexing CartesianAxes is comparable to that of CartesianIndices.","category":"page"},{"location":"axis/#","page":"The Axis","title":"The Axis","text":"julia> using AxisIndices, BenchmarkTools\n\njulia> cartaxes = CartesianAxes((Axis(2.0:5.0), Axis(1:4)));\n\njulia> cartinds = CartesianIndices((1:4, 1:4));\n\njulia> @btime getindex(cartaxes, 2, 2)\n  20.848 ns (1 allocation: 32 bytes)\nCartesianIndex(2, 2)\n\njulia> @btime getindex(cartinds, 2, 2)\n  22.317 ns (1 allocation: 32 bytes)\nCartesianIndex(2, 2)\n\njulia> @btime getindex(cartaxes, ==(3.0), 2)\n  444.374 ns (7 allocations: 416 bytes)\nCartesianIndex(2, 2)","category":"page"},{"location":"axis/#","page":"The Axis","title":"The Axis","text":"Indexing LinearAxes is comparable to that of LinearIndices","category":"page"},{"location":"axis/#","page":"The Axis","title":"The Axis","text":"julia> using AxisIndices, BenchmarkTools\n\njulia> linaxes = LinearAxes((Axis(1.0:4.0), Axis(1:4)));\n\njulia> lininds = LinearIndices((1:4, 1:4));\n\njulia> @btime getindex(linaxes, 2, 2)\n  18.275 ns (0 allocations: 0 bytes)\n6\n\njulia> @btime getindex(lininds, 2, 2)\n  18.849 ns (0 allocations: 0 bytes)\n6\n\njulia> @btime getindex(linaxes, ==(3.0), 2)\n  381.098 ns (6 allocations: 384 bytes)\n7","category":"page"},{"location":"axis/#","page":"The Axis","title":"The Axis","text":"You may notice there's significant overhead for using the filtering syntax. However, the filtering syntax takes advantage of a special type in base, Fix2. This means that we can take advantage of filtering methods that have been optimized for specific types of keys.  Here we do the same thing as above but we create a function that knows it's going to perform filtering.","category":"page"},{"location":"axis/#","page":"The Axis","title":"The Axis","text":"julia> getindex_filter(a, i1, i2) = a[==(i1), ==(i2)]\ngetindex_filter (generic function with 1 method)\n\njulia> @btime getindex_filter(linaxes, 3.0, 2)\n  57.216 ns (0 allocations: 0 bytes)\n7\n\njulia> linaxes2 = LinearAxes((Axis(Base.OneTo(4)), Axis(Base.OneTo(4))));\n\njulia> @btime getindex_filter(linaxes2, 3, 2)\n  22.070 ns (0 allocations: 0 bytes)\n7","category":"page"},{"location":"axis/#","page":"The Axis","title":"The Axis","text":"Indexing linaxes is much faster now that it can be optimized inside of a function call. However, it's still a little over twice as slow as normal indexing. That's largely because of the cost of searching 1.0:4.0 (which is a StepRangeLen type in this case). The second benchmark demonstrates how close we really are to standard indexing given similar range types.","category":"page"},{"location":"axis/#Combining-Axes-1","page":"The Axis","title":"Combining Axes","text":"","category":"section"},{"location":"axis/#","page":"The Axis","title":"The Axis","text":"These methods are responsible for assisting in broadcasting operations.","category":"page"},{"location":"axis/#","page":"The Axis","title":"The Axis","text":"AxisIndices.combine_axis\nAxisIndices.combine_values\nAxisIndices.combine_keys","category":"page"},{"location":"axis/#AxisIndices.combine_axis","page":"The Axis","title":"AxisIndices.combine_axis","text":"combine_axis(x, y) -> collection\n\nReturns the combination of axes x and y. This method relies on combine_values and combine_keys to form a new axis.\n\nExamples\n\njulia> using AxisIndices\n\njulia> a, b = 1:10, Base.OneTo(10);\n\njulia> combine_axis(a, SimpleAxis(b))\nSimpleAxis(1:10)\n\njulia> combine_axis(a, b)\n1:10\n\njulia> combine_axis(b, a)\n1:10\n\njulia> c = combine_axis(a, SimpleAxis(b))\nSimpleAxis(1:10)\n\njulia> d = combine_axis(SimpleAxis(b), a)\nSimpleAxis(1:10)\n\njulia> e = combine_axis(c, d)\nSimpleAxis(1:10)\n\njulia> f = combine_axis(Axis(a), a)\nAxis(1:10 => 1:10)\n\njulia> g = combine_axis(a, Axis(b))\nAxis(Base.OneTo(10) => 1:10)\n\njulia> combine_axis(f, g)\nAxis(1:10 => 1:10)\n\n\n\n\n\n\n","category":"function"},{"location":"axis/#AxisIndices.combine_values","page":"The Axis","title":"AxisIndices.combine_values","text":"combine_values(x, y)\n\nReturns the combination of the values of x and y, creating a new index. New subtypes of AbstractAxis may implement a unique combine_values method if  needed. Default behavior is to use the return of promote_rule(x, y) for the type of the combined values.\n\n\n\n\n\n","category":"function"},{"location":"axis/#AxisIndices.combine_keys","page":"The Axis","title":"AxisIndices.combine_keys","text":"combine_keys(x, y)\n\nReturns the combination of x and y, assuming they are keys to another structure. Default behavior is to use promote_rule for converting x. This method should be overloaded to accomodate combining keys where a traditional promotion isn't appropriate.\n\nExamples\n\nThe default behavior is to promote the first argument.\n\njulia> using AxisIndices\n\njulia> combine_keys(Base.OneTo(10), Base.OneTo(10))\nBase.OneTo(10)\n\njulia> combine_keys(1:10, Base.OneTo(10))\n1:10\n\nUsing combine_keys allows combining axes that aren't appropriate for conventional promotion.\n\njulia> combine_keys(1:2, string.(1:2))\n2-element Array{String,1}:\n \"1\"\n \"2\"\n\njulia> combine_keys(1:2, Symbol.(1:2))\n2-element Array{Symbol,1}:\n Symbol(\"1\")\n Symbol(\"2\")\n\n\n\n\n\n\n","category":"function"},{"location":"axis/#Reindexing-Axes-1","page":"The Axis","title":"Reindexing Axes","text":"","category":"section"},{"location":"axis/#","page":"The Axis","title":"The Axis","text":"AxisIndices.reindex\nAxisIndices.unsafe_reindex","category":"page"},{"location":"axis/#AxisIndices.reindex","page":"The Axis","title":"AxisIndices.reindex","text":"reindex(a::AbstractAxis, inds::AbstractVector{Integer}) -> AbstractAxis\n\nReturns an AbstractAxis of the same type as a where the keys of the axis are constructed by indexing into the keys of a with inds (keys(a)[inds]) and the values have the same first element as first(values(a)) but a length matching inds.\n\nExamples\n\njulia> using AxisIndices\n\njulia> x, y, z = Axis(1:10, 2:11), Axis(1:10), SimpleAxis(1:10);\n\njulia>  reindex(x, collect(1:2:10))\nAxis([1, 3, 5, 7, 9] => 2:6)\n\njulia> reindex(y, collect(1:2:10))\nAxis([1, 3, 5, 7, 9] => Base.OneTo(5))\n\njulia> reindex(z, collect(1:2:10))\nSimpleAxis(1:5)\n\n\n\n\n\n\n","category":"function"},{"location":"axis/#AxisIndices.unsafe_reindex","page":"The Axis","title":"AxisIndices.unsafe_reindex","text":"unsafe_reindex(a::AbstractAxis, inds::AbstractVector) -> AbstractAxis\n\nSimilar to reindex this function returns an index of the same type as a but doesn't check that inds is inbounds. New subtypes of AbstractAxis must implement a unique unsafe_reindex method.\n\nSee also: reindex\n\nExamples\n\njulia> using AxisIndices\n\njulia> AxisIndices.unsafe_reindex(SimpleAxis(OneToMRange(10)), 1:5)\nSimpleAxis(OneToMRange(5))\n\njulia> AxisIndices.unsafe_reindex(SimpleAxis(OneToSRange(10)), 1:5)\nSimpleAxis(OneToSRange(5))\n\n\n\n\n\n","category":"function"},{"location":"axis/#Reducing-Axes-1","page":"The Axis","title":"Reducing Axes","text":"","category":"section"},{"location":"axis/#","page":"The Axis","title":"The Axis","text":"AxisIndices.reduce_axes\nAxisIndices.reduce_axis","category":"page"},{"location":"axis/#AxisIndices.reduce_axes","page":"The Axis","title":"AxisIndices.reduce_axes","text":"reduce_axes(a, dims)\n\nReturns the appropriate axes for a measure that reduces dimensions along the dimensions dims.\n\nExample\n\njulia> using AxisIndices\n\njulia> reduce_axes(rand(2, 4), 2)\n(Base.OneTo(2), Base.OneTo(1))\n\njulia> reduce_axes(rand(2, 4), (1,2))\n(Base.OneTo(1), Base.OneTo(1))\n\njulia> reduce_axes(rand(2, 4), :)\n()\n\njulia> reduce_axes((Axis(1:4), Axis(1:4)), 2)\n(Axis(1:4 => Base.OneTo(4)), Axis(1:1 => Base.OneTo(1)))\n\n\n\n\n\n","category":"function"},{"location":"axis/#AxisIndices.reduce_axis","page":"The Axis","title":"AxisIndices.reduce_axis","text":"reduce_axis(a)\n\nReduces axis a to single value. Allows custom index types to have custom behavior throughout reduction methods (e.g., sum, prod, etc.)\n\nSee also: reduce_axes\n\nExample\n\njulia> using AxisIndices\n\njulia> reduce_axis(Axis(1:4))\nAxis(1:1 => Base.OneTo(1))\n\njulia> reduce_axis(1:4)\n1:1\n\n\n\n\n\n","category":"function"},{"location":"axis/#Resizing-Axes-1","page":"The Axis","title":"Resizing Axes","text":"","category":"section"},{"location":"axis/#","page":"The Axis","title":"The Axis","text":"These methods help with operations that need to resize axes, either dynamically or by creating a new instance of an axis. In addition to helping with operations related to array resizing, these may be useful for managing the axis of a vector throughout a push!, pushfirst!, pop, and popfirst! operation.","category":"page"},{"location":"axis/#","page":"The Axis","title":"The Axis","text":"AxisIndices.resize_first\nAxisIndices.resize_first!\nAxisIndices.resize_last\nAxisIndices.resize_last!\n\nAxisIndices.grow_first\nAxisIndices.grow_first!\nAxisIndices.grow_last\nAxisIndices.grow_last!\n\nAxisIndices.shrink_first\nAxisIndices.shrink_first!\nAxisIndices.shrink_last\nAxisIndices.shrink_last!\n\nAxisIndices.next_type\nAxisIndices.prev_type","category":"page"},{"location":"axis/#AxisIndices.resize_first","page":"The Axis","title":"AxisIndices.resize_first","text":"resize_first(x, n::Integer)\n\nReturns a collection similar to x that grows or shrinks from the first index to be of size n.\n\nExamples\n\njulia> using AxisIndices\n\njulia> x = collect(1:5);\n\njulia> resize_first(x, 2)\n2-element Array{Int64,1}:\n 4\n 5\n\njulia> resize_first(x, 7)\n7-element Array{Int64,1}:\n -1\n  0\n  1\n  2\n  3\n  4\n  5\n\njulia> resize_first(x, 5)\n5-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5\n\n\n\n\n\n","category":"function"},{"location":"axis/#AxisIndices.resize_first!","page":"The Axis","title":"AxisIndices.resize_first!","text":"resize_first!(x, n::Integer)\n\nReturns the collection x after growing or shrinking the first index to be of size n.\n\nExamples\n\njulia> using AxisIndices\n\njulia> x = collect(1:5);\n\njulia> resize_first!(x, 2);\n\njulia> x\n2-element Array{Int64,1}:\n 4\n 5\n\njulia> resize_first!(x, 6);\n\njulia> x\n6-element Array{Int64,1}:\n 0\n 1\n 2\n 3\n 4\n 5\n\n\n\n\n\n\n","category":"function"},{"location":"axis/#AxisIndices.resize_last","page":"The Axis","title":"AxisIndices.resize_last","text":"resize_last(x, n::Integer)\n\nReturns a collection similar to x that grows or shrinks from the last index to be of size n.\n\nExamples\n\njulia> using AxisIndices\n\njulia> x = collect(1:5);\n\njulia> resize_last(x, 2)\n2-element Array{Int64,1}:\n 1\n 2\n\njulia> resize_last(x, 7)\n7-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n\njulia>  resize_last(x, 5)\n5-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5\n\n\n\n\n\n\n","category":"function"},{"location":"axis/#AxisIndices.resize_last!","page":"The Axis","title":"AxisIndices.resize_last!","text":"resize_last!(x, n::Integer)\n\nReturns the collection x after growing or shrinking the last index to be of size n.\n\nExamples\n\njulia> using AxisIndices\n\njulia> x = collect(1:5);\n\njulia> resize_last!(x, 2);\n\njulia> x\n2-element Array{Int64,1}:\n 1\n 2\n\njulia> resize_last!(x, 5);\n\njulia> x\n5-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5\n\n\n\n\n\n\n","category":"function"},{"location":"axis/#AxisIndices.grow_first","page":"The Axis","title":"AxisIndices.grow_first","text":"grow_first(x, n)\n\nReturns a collection similar to x that grows by n elements from the first index.\n\nExamples\n\njulia> using AxisIndices\n\njulia> mr = UnitMRange(1, 10)\nUnitMRange(1:10)\n\njulia> grow_first(mr, 2)\nUnitMRange(-1:10)\n\n\n\n\n\n","category":"function"},{"location":"axis/#AxisIndices.grow_first!","page":"The Axis","title":"AxisIndices.grow_first!","text":"grow_first!(x, n)\n\nReturns the collection x after growing from the first index by n elements.\n\nExamples\n\njulia> using AxisIndices\n\njulia> mr = UnitMRange(1, 10)\nUnitMRange(1:10)\n\njulia> grow_first!(mr, 2);\n\njulia> mr\nUnitMRange(-1:10)\n\n\n\n\n\n","category":"function"},{"location":"axis/#AxisIndices.grow_last","page":"The Axis","title":"AxisIndices.grow_last","text":"grow_last(x, n)\n\nReturns a collection similar to x that grows by n elements from the last index.\n\nExamples\n\njulia> using AxisIndices\n\njulia> mr = UnitMRange(1, 10)\nUnitMRange(1:10)\n\njulia> grow_last(mr, 2)\nUnitMRange(1:12)\n\n\n\n\n\n","category":"function"},{"location":"axis/#AxisIndices.grow_last!","page":"The Axis","title":"AxisIndices.grow_last!","text":"grow_last!(x, n)\n\nReturns the collection x after growing from the last index by n elements.\n\nExamples\n\njulia> using AxisIndices\n\njulia> mr = UnitMRange(1, 10)\nUnitMRange(1:10)\n\njulia> grow_last!(mr, 2);\n\njulia> mr\nUnitMRange(1:12)\n\n\n\n\n\n","category":"function"},{"location":"axis/#AxisIndices.shrink_first","page":"The Axis","title":"AxisIndices.shrink_first","text":"shrink_first(x, n)\n\nReturns a collection similar to x that shrinks by n elements from the first index.\n\nExamples\n\njulia> using AxisIndices\n\njulia> mr = UnitMRange(1, 10)\nUnitMRange(1:10)\n\njulia> shrink_first(mr, 2)\nUnitMRange(3:10)\n\n\n\n\n\n","category":"function"},{"location":"axis/#AxisIndices.shrink_first!","page":"The Axis","title":"AxisIndices.shrink_first!","text":"shrink_first!(x, n)\n\nReturns the collection x after shrinking from the first index by n elements.\n\n\n\n\n\n","category":"function"},{"location":"axis/#AxisIndices.shrink_last","page":"The Axis","title":"AxisIndices.shrink_last","text":"shrink_last(x, n)\n\nReturns a collection similar to x that shrinks by n elements from the last index.\n\nExamples\n\njulia> using AxisIndices\n\njulia> mr = UnitMRange(1, 10)\nUnitMRange(1:10)\n\njulia> shrink_last(mr, 2)\nUnitMRange(1:8)\n\n\n\n\n\n","category":"function"},{"location":"axis/#AxisIndices.shrink_last!","page":"The Axis","title":"AxisIndices.shrink_last!","text":"shrink_last!(x, n)\n\nReturns the collection x after shrinking from the last index by n elements.\n\nExamples\n\njulia> using AxisIndices\n\njulia> mr = UnitMRange(1, 10)\nUnitMRange(1:10)\n\njulia> shrink_last!(mr, 2);\n\njulia> mr\nUnitMRange(1:8)\n\n\n\n\n\n","category":"function"},{"location":"axis/#AxisIndices.next_type","page":"The Axis","title":"AxisIndices.next_type","text":"next_type(x::T)\n\nReturns the immediately greater value of type T.\n\nExamples\n\njulia> using AxisIndices\n\njulia> AxisIndices.next_type(\"b\")\n\"c\"\n\njulia> AxisIndices.next_type(:b)\n:c\n\njulia> AxisIndices.next_type('a')\n'b': ASCII/Unicode U+0062 (category Ll: Letter, lowercase)\n\njulia> AxisIndices.next_type(1)\n2\n\njulia> AxisIndices.next_type(2.0)\n2.0000000000000004\n\njulia> AxisIndices.next_type(\"\")\n\"\"\n\n\n\n\n\n","category":"function"},{"location":"axis/#AxisIndices.prev_type","page":"The Axis","title":"AxisIndices.prev_type","text":"prev_type(x::T)\n\nReturns the immediately lesser value of type T.\n\nExamples\n\njulia> using AxisIndices\n\njulia> AxisIndices.prev_type(\"b\")\n\"a\"\n\njulia> AxisIndices.prev_type(:b)\n:a\n\njulia> AxisIndices.prev_type('b')\n'a': ASCII/Unicode U+0061 (category Ll: Letter, lowercase)\n\njulia> AxisIndices.prev_type(1)\n0\n\njulia> AxisIndices.prev_type(1.0)\n0.9999999999999999\n\njulia> AxisIndices.prev_type(\"\")\n\"\"\n\n\n\n\n\n","category":"function"},{"location":"axis/#Axis-Types-1","page":"The Axis","title":"Axis Types","text":"","category":"section"},{"location":"axis/#","page":"The Axis","title":"The Axis","text":"AxisIndices.AbstractAxis\nAxisIndices.values_type\nAxisIndices.keys_type\nAxisIndices.Axis\nAxisIndices.SimpleAxis\nAxisIndices.CartesianAxes\nAxisIndices.LinearAxes","category":"page"},{"location":"axis/#AxisIndices.AbstractAxis","page":"The Axis","title":"AxisIndices.AbstractAxis","text":"AbstractAxis\n\nAn AbstractVector subtype optimized for indexing.\n\n\n\n\n\n","category":"type"},{"location":"axis/#AxisIndices.values_type","page":"The Axis","title":"AxisIndices.values_type","text":"values_type(x)\n\nRetrieves the type of the values of x. This should be functionally equivalent to typeof(values(x)).\n\nExamples\n\njulia> using AxisIndices\n\njulia>  values_type(Axis(1:2))\nBase.OneTo{Int64}\n\njulia> values_type(typeof(Axis(1:2)))\nBase.OneTo{Int64}\n\njulia> values_type(typeof(1:2))\nUnitRange{Int64}\n\n\n\n\n\n","category":"function"},{"location":"axis/#AxisIndices.keys_type","page":"The Axis","title":"AxisIndices.keys_type","text":"keys_type(x)\n\nRetrieves the type of the keys of x.\n\nExamples\n\njulia> using AxisIndices\n\njulia>  keys_type(Axis(1:2))\nUnitRange{Int64}\n\njulia> keys_type(typeof(Axis(1:2)))\nUnitRange{Int64}\n\njulia> keys_type(UnitRange{Int})\nBase.OneTo{Int64}\n\n\n\n\n\n","category":"function"},{"location":"axis/#AxisIndices.Axis","page":"The Axis","title":"AxisIndices.Axis","text":"Axis(k[, v=OneTo(length(k))])\n\nSubtypes of AbstractAxis that maps keys to values. The first argument specifies the keys and the second specifies the values. If only one argument is specified then the values span from 1 to the length of k.\n\nExamples\n\nThe value for all of these is the same.\n\njulia> using AxisIndices\n\njulia> x = Axis(2.0:11.0, 1:10)\nAxis(2.0:1.0:11.0 => 1:10)\n\njulia> y = Axis(2.0:11.0)  # when only one argument is specified assume it's the keys\nAxis(2.0:1.0:11.0 => Base.OneTo(10))\n\njulia> z = Axis(1:10)\nAxis(1:10 => Base.OneTo(10))\n\nStandard indexing returns the same values\n\njulia> x[2]\n2\n\njulia> x[2] == y[2] == z[2]\ntrue\n\njulia> x[1:2]\nAxis(2.0:1.0:3.0 => 1:2)\n\njulia> y[1:2]\nAxis(2.0:1.0:3.0 => 1:2)\n\njulia> z[1:2]\nAxis(1:2 => 1:2)\n\njulia> x[1:2] == y[1:2] == z[1:2]\ntrue\n\nFunctions that return true or false may be used to search the keys for their corresponding index. The following is equivalent to the previous example.\n\njulia> x[==(3.0)]\n2\n\njulia> x[==(3.0)] ==       # 3.0 is the 2nd key of x\n       y[isequal(3.0)] ==  # 3.0 is the 2nd key of y\n       z[==(2)]            # 2 is the 2nd key of z\ntrue\n\njulia> x[<(4.0)]  # all keys less than 4.0 are 2.0:3.0 which correspond to values 1:2\nAxis(2.0:1.0:3.0 => 1:2)\n\njulia> y[<=(3.0)]  # all keys less than or equal to 3.0 are 2.0:3.0 which correspond to values 1:2\nAxis(2.0:1.0:3.0 => 1:2)\n\njulia> z[<(3)]  # all keys less than or equal to 3 are 1:2 which correspond to values 1:2\nAxis(1:2 => 1:2)\n\njulia> x[<(4.0)] == y[<=(3.0)] == z[<(3)]\ntrue\n\nNotice that == returns a single value instead of a collection of all elements where the key was found to be true. This is because all keys must be unique so there can only ever be one element returned.\n\n\n\n\n\n","category":"type"},{"location":"axis/#AxisIndices.SimpleAxis","page":"The Axis","title":"AxisIndices.SimpleAxis","text":"SimpleAxis(v)\n\nPovides an AbstractAxis interface for any AbstractUnitRange, v. v will be considered both the values and keys of the return instance. \n\nExamples\n\nA SimpleAxis is useful for giving a standard set of indices the ability to use the filtering syntax for indexing.\n\njulia> using AxisIndices\n\njulia> x = SimpleAxis(2:10)\nSimpleAxis(2:10)\n\njulia> x[2]\n3\n\njulia> x[==(2)]\n2\n\njulia> x[2] == x[==(3)]\ntrue\n\njulia> x[>(2)]\nSimpleAxis(3:10)\n\njulia> x[>(2)]\nSimpleAxis(3:10)\n\n\n\n\n\n","category":"type"},{"location":"axis/#AxisIndices.CartesianAxes","page":"The Axis","title":"AxisIndices.CartesianAxes","text":"CartesianAxes\n\nAlias for LinearIndices where indices are subtypes of AbstractAxis.\n\njulia> using AxisIndices\n\njulia> cartaxes = CartesianAxes((Axis(2.0:5.0), Axis(1:4)));\n\njulia> cartinds = CartesianIndices((1:4, 1:4));\n\njulia> cartaxes[2, 2]\nCartesianIndex(2, 2)\n\njulia> cartinds[2, 2]\nCartesianIndex(2, 2)\n\n\n\n\n\n","category":"type"},{"location":"axis/#AxisIndices.LinearAxes","page":"The Axis","title":"AxisIndices.LinearAxes","text":"LinearAxes\n\nAlias for LinearIndices where indices are subtypes of AbstractAxis.\n\njulia> using AxisIndices\n\njulia> linaxes = LinearAxes((Axis(2.0:5.0), Axis(1:4)));\n\njulia> lininds = LinearIndices((1:4, 1:4));\n\njulia> linaxes[2, 2]\n6\n\njulia> lininds[2, 2]\n6\n\n\n\n\n\n","category":"type"},{"location":"#AxisIndices-1","page":"Introduction","title":"AxisIndices","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"The goals of this package are:","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Facilitate multidimensional indexing (e.g., instance_of_an_array[indices]) that supports semantic user facing indices (e.g., indices = Second(1)).\nAccomplishing the first goal should not interfere in the ability to perform the vast majority of array related methods (e.g, vcat, append!, etc.).\nIt should be easy to implement new subtypes of AbstractAxis that accommodate novel behavior and needs.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"These goals are accomplished predominantly through the AbstractAxis type. It is a subtype of AbstractUnitRange{<:Integer} with an additional interface for creating keys and interacting with them. This additional interface is intended to be easily extended to new types that may be needed for a variety of different situations. An additional AxisIndicesArray type is provided that uses any subtype of AbstractAxis for each axis. However, many methods are provided and documented internally so that it's easy for users to alter the behavior of an AxisIndicesArray with a new AbstractAxis subtype or create an entirely unique multidimensional structure.","category":"page"}]
}
