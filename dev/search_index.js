var documenterSearchIndex = {"docs":
[{"location":"compatibility/#Compatibility","page":"Compatibility","title":"Compatibility","text":"","category":"section"},{"location":"compatibility/","page":"Compatibility","title":"Compatibility","text":"The following packages outside of the Base module have some form of support. In addition to creating awareness of existing functionality, the following provides users with a better idea of how exactly these packages are supported. This means features existing outside of those described here are not within the domain of intended coverage and users should seek support linked resources.","category":"page"},{"location":"compatibility/#MappedArrays","page":"Compatibility","title":"MappedArrays","text":"","category":"section"},{"location":"compatibility/","page":"Compatibility","title":"Compatibility","text":"MappedArrays.jl allows \"lazy\" in-place elementwise transformations of arrays. Support is provided by overloading the mappedarray method, which AxisIndices does not export (i.e. users must using mappedArrays to get access to it). In order to avoid method ambiguities multi-mapping of mixed AbstractArray and AbstractAxisIndices cannot be provided. In other words, the current version can only support multi-mapping multiple AbstractAxisIndices.","category":"page"},{"location":"compatibility/#NamedDims","page":"Compatibility","title":"NamedDims","text":"","category":"section"},{"location":"compatibility/","page":"Compatibility","title":"Compatibility","text":"Indexing via named dimensions is supported via the NamedDims.jl package. NamedAxisArray assists in constructing arrays that have both named dimensions and a subtype of AbstractAxis along each axis.","category":"page"},{"location":"compatibility/#Metadata","page":"Compatibility","title":"Metadata","text":"","category":"section"},{"location":"compatibility/","page":"Compatibility","title":"Compatibility","text":"Metadata is supported through the Metadata.jl package.","category":"page"},{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"Modules = [AxisIndices]\nOrder   = [:function, :type]","category":"page"},{"location":"references/#AxisIndices.center","page":"References","title":"AxisIndices.center","text":"center(x; origin=0)\ncenter(; origin=0) = x -> center(x; origin)\n\nShortcut for creating CenteredAxis.\n\nExamples\n\njulia> using AxisIndices\n\njulia> AxisArray(ones(3), center(origin=0))\n3-element AxisArray(::Array{Float64,1}\n  • axes:\n     1 = -1:1\n)\n      1\n  -1  1.0\n  0   1.0\n  1   1.0\n\n\n\n\n\n\n","category":"function"},{"location":"references/#AxisIndices.circular_pad","page":"References","title":"AxisIndices.circular_pad","text":"circular_pad(x; first_pad=0, last_pad=0, sym_pad=nothing)\n\nThe border elements wrap around. For instance, indexing beyond the left border returns values starting from the right border.\n\nboxed\nbeginarraylcr\n  c d e f    a  b  c  d  e  f  a  b  c  d\nendarray\n\n\n\n\n\n\n","category":"function"},{"location":"references/#AxisIndices.idaxis-Tuple{Any}","page":"References","title":"AxisIndices.idaxis","text":"idaxis(inds::AbstractUnitRange{<:Integer}) -> IdentityAxis\n\nShortcut for creating IdentityAxis.\n\nExamples\n\njulia> using AxisIndices\n\njulia> AxisArray(ones(3), idaxis)[2:3]\n2-element AxisArray(::Array{Float64,1}\n  • axes:\n     1 = 2:3\n)\n     1\n  2  1.0\n  3  1.0\n\n\n\n\n\n\n","category":"method"},{"location":"references/#AxisIndices.is_dense_wrapper-Tuple{Any}","page":"References","title":"AxisIndices.is_dense_wrapper","text":"is_dense_wrapper(::Type{T}) where {T} -> Bool\n\nDo all the indices of T map to a unique indice of the parent data that is wrapped? This is not true for padded axes.\n\n\n\n\n\n","category":"method"},{"location":"references/#AxisIndices.is_key-Tuple{Any}","page":"References","title":"AxisIndices.is_key","text":"is_key([collection,] arg) -> Bool\n\nWhether arg refers to a key of axis.\n\n\n\n\n\n","category":"method"},{"location":"references/#AxisIndices.offset","page":"References","title":"AxisIndices.offset","text":"offset(x)\n\nShortcut for creating OffsetAxis where x is the first argument to OffsetAxis.\n\nExamples\n\njulia> using AxisIndices\n\njulia> AxisArray(ones(3), offset(2))\n3-element AxisArray(::Array{Float64,1}\n  • axes:\n     1 = 3:5\n)\n     1\n  3  1.0\n  4  1.0\n  5  1.0\n\n\n\n\n\n\n","category":"function"},{"location":"references/#AxisIndices.one_pad","page":"References","title":"AxisIndices.one_pad","text":"one_pad(x; first_pad=0, last_pad=0, sym_pad=nothing)\n\nThe border elements return oneunit(eltype(A)), where A is the parent array being padded.\n\n\n\n\n\n","category":"function"},{"location":"references/#AxisIndices.permuteddimsview-Tuple{Any,Any}","page":"References","title":"AxisIndices.permuteddimsview","text":"permuteddimsview(A, perm)\n\nreturns a \"view\" of A with its dimensions permuted as specified by perm. This is like permutedims, except that it produces a view rather than a copy of A; consequently, any manipulations you make to the output will be mirrored in A. Compared to the copy, the view is much faster to create, but generally slower to use.\n\n\n\n\n\n","category":"method"},{"location":"references/#AxisIndices.reflect_pad","page":"References","title":"AxisIndices.reflect_pad","text":"reflect_pad(x; first_pad=0, last_pad=0, sym_pad=nothing)\n\nThe border elements reflect relative to the edge itself.\n\nboxed\nbeginarraylcr\n  d c b a    a  b  c  d  e  f  f  e  d  c\nendarray\n\n\n\n\n\n\n","category":"function"},{"location":"references/#AxisIndices.replicate_pad","page":"References","title":"AxisIndices.replicate_pad","text":"replicate_pad(x; first_pad=0, last_pad=0, sym_pad=nothing)\n\nThe border elements extend beyond the image boundaries.\n\nboxed\nbeginarraylcr\n  a a a a    a  b  c  d  e  f  f  f  f  f\nendarray\n\n\n\n\n\n\n","category":"function"},{"location":"references/#AxisIndices.struct_view-Tuple{Any}","page":"References","title":"AxisIndices.struct_view","text":"struct_view(A)\n\nCreates a MappedArray whose element type is derived from the first StructAxis found as an axis of A.\n\n\n\n\n\n","category":"method"},{"location":"references/#AxisIndices.symmetric_pad","page":"References","title":"AxisIndices.symmetric_pad","text":"symmetric_pad(x; first_pad=0, last_pad=0, sym_pad=nothing)\n\nThe border elements reflect relative to a position between elements. That is, the border pixel is omitted when mirroring.\n\nboxed\nbeginarraylcr\n  e d c b    a  b  c  d  e  f  e  d  c  b\nendarray\n\n\n\n\n\n\n","category":"function"},{"location":"references/#AxisIndices.zero_pad","page":"References","title":"AxisIndices.zero_pad","text":"zero_pad(x; first_pad=0, last_pad=0, sym_pad=nothing)\n\nThe border elements return zero(eltype(A)), where A is the parent array being padded.\n\n\n\n\n\n","category":"function"},{"location":"references/#Base.deleteat!-Union{Tuple{Ax}, Tuple{P}, Tuple{T}, Tuple{AxisArray{T,1,P,Tuple{Ax}},Any}} where Ax where P where T","page":"References","title":"Base.deleteat!","text":"deleteat!(a::AxisVector, arg)\n\nRemove the items corresponding to A[arg], and return the modified a. Subsequent items are shifted to fill the resulting gap. If the axis of a is an SimpleAxis then it is shortened to match the length of a.\n\nExamples\n\njulia> using AxisIndices\n\njulia> x = AxisArray([1, 2, 3, 4]);\n\njulia> deleteat!(x, 3)\n3-element AxisArray(::Array{Int64,1}\n  • axes:\n     1 = 1:3\n)\n     1\n  1  1\n  2  2\n  3  4  \n\njulia> x = AxisArray([1, 2, 3, 4], [\"a\", \"b\", \"c\", \"d\"]);\n\njulia> keys.(axes(deleteat!(x, \"c\")))\n([\"a\", \"b\", \"d\"],)\n\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.inv-Tuple{AxisArray}","page":"References","title":"Base.inv","text":"inv(M::AxisMatrix)\n\nComputes the inverse of an AxisMatrixMatrix\n\njulia> using AxisIndices, LinearAlgebra\n\njulia> M = AxisArray([2 5; 1 3], [\"a\", \"b\"], [:one, :two]);\n\njulia> keys.(axes(inv(M)))\n([:one, :two], [\"a\", \"b\"])\n\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.reshape-Union{Tuple{N}, Tuple{AxisArray,Tuple{Vararg{Int64,N}}}} where N","page":"References","title":"Base.reshape","text":"reshape(A::AxisArray, shape)\n\nReshape the array and axes of A.\n\nExamples\n\njulia> using AxisIndices\n\njulia> A = reshape(AxisArray(Vector(1:8), [:a, :b, :c, :d, :e, :f, :g, :h]), 4, 2);\n\njulia> axes(A)\n(Axis([:a, :b, :c, :d] => SimpleAxis(1:4)), SimpleAxis(1:2))\n\njulia> axes(reshape(A, 2, :))\n(Axis([:a, :b] => SimpleAxis(1:2)), SimpleAxis(1:4))\n\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.rot180-Tuple{AxisArray{T,2,P,Tuple{Ax1,Ax2}} where Ax2 where Ax1 where P<:AbstractArray{T,2} where T}","page":"References","title":"Base.rot180","text":"rot180(A::AxisMatrix)\n\nRotate A 180 degrees, along with its axes keys.\n\nExamples\n\njulia> using AxisIndices\n\njulia> a = AxisArray([1 2; 3 4], [\"a\", \"b\"], [\"one\", \"two\"]);\n\njulia> b = rot180(a);\n\njulia> keys.(axes(b))\n([\"b\", \"a\"], [\"two\", \"one\"])\n\njulia> c = rotr90(rotr90(a));\n\njulia> keys.(axes(c))\n([\"b\", \"a\"], [\"two\", \"one\"])\n\njulia> a[\"a\", \"one\"] == b[\"a\", \"one\"] == c[\"a\", \"one\"]\ntrue\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.rotl90-Tuple{AxisArray{T,2,P,Tuple{Ax1,Ax2}} where Ax2 where Ax1 where P<:AbstractArray{T,2} where T}","page":"References","title":"Base.rotl90","text":"rotl90(A::AxisMatrix)\n\nRotate A left 90 degrees, along with its axes keys.\n\nExamples\n\njulia> using AxisIndices\n\njulia> a = AxisArray([1 2; 3 4], [\"a\", \"b\"], [\"one\", \"two\"]);\n\njulia> b = rotl90(a);\n\njulia> keys.(axes(b))\n([\"two\", \"one\"], [\"a\", \"b\"])\n\njulia> a[\"a\", \"one\"] == b[\"one\", \"a\"]\ntrue\n\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.rotr90-Tuple{AxisArray{T,2,P,Tuple{Ax1,Ax2}} where Ax2 where Ax1 where P<:AbstractArray{T,2} where T}","page":"References","title":"Base.rotr90","text":"rotr90(A::AxisMatrix)\n\nRotate A right 90 degrees, along with its axes keys.\n\nExamples\n\njulia> using AxisIndices\n\njulia> a = AxisArray([1 2; 3 4], [\"a\", \"b\"], [\"one\", \"two\"]);\n\njulia> b = rotr90(a);\n\njulia> keys.(axes(b))\n([\"one\", \"two\"], [\"b\", \"a\"])\n\njulia> a[\"a\", \"one\"] == b[\"one\", \"a\"]\ntrue\n\n\n\n\n\n","category":"method"},{"location":"references/#LinearAlgebra.diag-Union{Tuple{AxisArray}, Tuple{D}, Tuple{AxisArray,Integer}} where D","page":"References","title":"LinearAlgebra.diag","text":"diag(M::AxisMatrix, k::Integer=0; dim::Val=Val(1))\n\nThe kth diagonal of an AxisMatrixMatrix, M. The keyword argument dim specifies which which dimension's axis to preserve, with the default being the first dimension. This can be change by specifying dim=Val(2) instead.\n\njulia> using AxisIndices, LinearAlgebra\n\njulia> A = AxisArray([1 2 3; 4 5 6; 7 8 9], [\"a\", \"b\", \"c\"], [:one, :two, :three]);\n\njulia> keys.(axes(diag(A)))\n([\"a\", \"b\", \"c\"],)\n\njulia> keys.(axes(diag(A, 1; dim=Val(2))))\n([:one, :two],)\n\n\n\n\n\n\n","category":"method"},{"location":"references/#LinearAlgebra.lq-Tuple{AxisArray,Vararg{Any,N} where N}","page":"References","title":"LinearAlgebra.lq","text":"lq(A::AxisArray, args...; kwargs...)\n\nCompute the LQ factorization of an AxisArray A.\n\nExamples\n\njulia> using AxisIndices, LinearAlgebra\n\njulia> m = AxisArray([1.0 2; 3 4], (2:3, 3:4));\n\njulia> F = lq(m);\n\njulia> axes(F.L)\n(OffsetAxis(offset=1, parent=SimpleAxis(1:2))), SimpleAxis(1:2))\n\njulia> axes(F.Q)\n(SimpleAxis(1:2), OffsetAxis(offset=2, parent=SimpleAxis(1:2))))\n\njulia> axes(F.L * F.Q)\n(OffsetAxis(offset=1, parent=SimpleAxis(1:2))), OffsetAxis(offset=2, parent=SimpleAxis(1:2))))\n\n\n\n\n\n\n","category":"method"},{"location":"references/#LinearAlgebra.lu","page":"References","title":"LinearAlgebra.lu","text":"lu(A::AxisArray, args...; kwargs...)\n\nCompute the LU factorization of an AxisArray A.\n\nExamples\n\njulia> using AxisIndices, LinearAlgebra\n\njulia> m = AxisArray([1.0 2; 3 4], (2:3, 3:4));\n\njulia> F = lu(m);\n\njulia> axes(F.L)\n(OffsetAxis(offset=1, parent=SimpleAxis(1:2))), SimpleAxis(1:2))\n\njulia> axes(F.U)\n(SimpleAxis(1:2), OffsetAxis(offset=2, parent=SimpleAxis(1:2))))\n\njulia> F.p\n2-element Array{Int64,1}:\n 3\n 2\n\njulia> axes(F.P)\n(OffsetAxis(offset=1, parent=SimpleAxis(1:2))), OffsetAxis(offset=1, parent=SimpleAxis(1:2))))\n\njulia> axes(F.P * m)\n(OffsetAxis(offset=1, parent=SimpleAxis(1:2))), OffsetAxis(offset=2, parent=SimpleAxis(1:2))))\n\njulia> axes(F.L * F.U)\n(OffsetAxis(offset=1, parent=SimpleAxis(1:2))), OffsetAxis(offset=2, parent=SimpleAxis(1:2))))\n\n\n\n\n\n\n","category":"function"},{"location":"references/#LinearAlgebra.qr-Union{Tuple{T}, Tuple{AxisArray{T,2,D,Axs} where Axs<:Tuple{Any,Any} where D,Vararg{Any,N} where N}} where T","page":"References","title":"LinearAlgebra.qr","text":"qr(F::AxisArray, args...; kwargs...)\n\nCompute the QR factorization of an AxisArray A.\n\nExamples\n\njulia> using AxisIndices, LinearAlgebra\n\njulia> m = AxisArray([1.0 2; 3 4], (2:3, 3:4));\n\njulia> F = qr(m, Val(true));\n\njulia> axes(F.Q)\n(OffsetAxis(offset=1, parent=SimpleAxis(1:2))), SimpleAxis(1:2))\n\njulia> axes(F.R)\n(SimpleAxis(1:2), OffsetAxis(offset=2, parent=SimpleAxis(1:2))))\n\njulia> axes(F.Q * F.R)\n(OffsetAxis(offset=1, parent=SimpleAxis(1:2))), OffsetAxis(offset=2, parent=SimpleAxis(1:2))))\n\njulia> axes(F.p)\n(Base.OneTo(2),)\n\njulia> axes(F.P)\n(OffsetAxis(offset=1, parent=SimpleAxis(1:2))), OffsetAxis(offset=1, parent=SimpleAxis(1:2))))\n\njulia> axes(F.P * AxisArray([1.0 2; 3 4], (2:3, 3:4)))\n(OffsetAxis(offset=1, parent=SimpleAxis(1:2))), OffsetAxis(offset=2, parent=SimpleAxis(1:2))))\n\n\n\n\n\n\n","category":"method"},{"location":"references/#LinearAlgebra.svd-Tuple{AxisArray,Vararg{Any,N} where N}","page":"References","title":"LinearAlgebra.svd","text":"svd(F::AxisArray, args...; kwargs...)\n\nCompute the singular value decomposition (SVD) of an AxisArray A.\n\nExamples\n\njulia> using AxisIndices, LinearAlgebra\n\njulia> m = AxisArray([1.0 2; 3 4], (2:3, 3:4));\n\njulia> F = svd(m);\n\njulia> axes(F.U)\n(OffsetAxis(offset=1, parent=SimpleAxis(1:2))), SimpleAxis(1:2))\n\njulia> axes(F.V)\n(OffsetAxis(offset=2, parent=SimpleAxis(1:2))), SimpleAxis(1:2))\n\njulia> axes(F.Vt)\n(SimpleAxis(1:2), OffsetAxis(offset=2, parent=SimpleAxis(1:2))))\n\njulia> axes(F.U * Diagonal(F.S) * F.Vt)\n(OffsetAxis(offset=1, parent=SimpleAxis(1:2))), OffsetAxis(offset=2, parent=SimpleAxis(1:2))))\n\n\n\n\n\n\n","category":"method"},{"location":"references/#Statistics.cor-Union{Tuple{AxisArray{T,2,D,Axs} where Axs<:Tuple{Any,Any} where D}, Tuple{T}} where T","page":"References","title":"Statistics.cor","text":"cor(x::AxisMatrix; dims=1, kwargs...)\n\nPerforms cor on the parent matrix of x and reconstructs a similar type with the appropriate axes.\n\nExamples\n\njulia> using AxisIndices, Statistics\n\njulia> A = AxisArray([1 2 3; 4 5 6; 7 8 9], [\"a\", \"b\", \"c\"], [:one, :two, :three]);\n\njulia> keys.(axes(cor(A, dims = 2)))\n([\"a\", \"b\", \"c\"], [\"a\", \"b\", \"c\"])\n\njulia> keys.(axes(cor(A, dims = 1)))\n([:one, :two, :three], [:one, :two, :three])\n\n\n\n\n\n\n","category":"method"},{"location":"references/#Statistics.cov-Union{Tuple{AxisArray{T,2,D,Axs} where Axs<:Tuple{Any,Any} where D}, Tuple{T}} where T","page":"References","title":"Statistics.cov","text":"cov(x::AxisMatrix; dims=1, kwargs...)\n\nPerforms cov on the parent matrix of x and reconstructs a similar type with the appropriate axes.\n\nExamples\n\njulia> using AxisIndices, Statistics\n\njulia> A = AxisArray([1 2 3; 4 5 6; 7 8 9], [\"a\", \"b\", \"c\"], [:one, :two, :three]);\n\njulia> keys.(axes(cov(A, dims = 2)))\n([\"a\", \"b\", \"c\"], [\"a\", \"b\", \"c\"])\n\njulia> keys.(axes(cov(A, dims = 1)))\n([:one, :two, :three], [:one, :two, :three])\n\n\n\n\n\n\n","category":"method"},{"location":"references/#AxisIndices.AbstractAxis","page":"References","title":"AxisIndices.AbstractAxis","text":"AbstractAxis\n\nAn AbstractVector subtype optimized for indexing.\n\n\n\n\n\n","category":"type"},{"location":"references/#AxisIndices.AbstractOffsetAxis","page":"References","title":"AxisIndices.AbstractOffsetAxis","text":"AbstractOffsetAxis{I,Inds}\n\nSupertype for axes that begin indexing offset from one. All subtypes of AbstractOffsetAxis use the keys for indexing and only convert to the underlying indices when to_index(::OffsetAxis, ::Integer) is called (i.e. when indexing the an array with an AbstractOffsetAxis. See OffsetAxis, CenteredAxis, and IdentityAxis for more details and examples.\n\n\n\n\n\n","category":"type"},{"location":"references/#AxisIndices.Axis","page":"References","title":"AxisIndices.Axis","text":"Axis(k[, v=OneTo(length(k))])\n\nSubtypes of AbstractAxis that maps keys to values. The first argument specifies the keys and the second specifies the values. If only one argument is specified then the values span from 1 to the length of k.\n\nExamples\n\nThe value for all of these is the same.\n\njulia> using AxisIndices\n\njulia> x = Axis(2.0:11.0)  # when only one argument is specified assume it's the keys\nAxis(2.0:1.0:11.0 => SimpleAxis(1:10))\n\njulia> y = Axis(1:10)\nAxis(1:10 => SimpleAxis(1:10))\n\nStandard indexing returns the same values\n\njulia> x[2]\n2\n\njulia> x[2] == y[2]\ntrue\n\njulia> x[1:2]\nAxis(2.0:1.0:3.0 => SimpleAxis(1:2))\n\njulia> y[1:2]\nAxis(1:2 => SimpleAxis(1:2))\n\njulia> x[1:2] == y[1:2]\ntrue\n\nFunctions that return true or false may be used to search the keys for their corresponding index. The following is equivalent to the previous example.\n\njulia> x[==(3.0)]\n2\n\njulia> x[3.0] ==  # 3.0 is the 2nd key of x\n       y[==(2)]   # 2 is the 2nd key of z\ntrue\n\njulia> x[<(4.0)]  # all keys less than 4.0 are 2.0:3.0 which correspond to values 1:2\nAxis(2.0:1.0:3.0 => SimpleAxis(1:2))\n\njulia> y[<=(3.0)]  # all keys less than or equal to 3.0 are 2.0:3.0 which correspond to values 1:2\nAxis(2.0:1.0:3.0 => SimpleAxis(1:2))\n\njulia> z[<(3)]  # all keys less than or equal to 3 are 1:2 which correspond to values 1:2\nAxis(1:2 => SimpleAxis(1:2))\n\njulia> x[<(4.0)] == y[<=(3.0)] == z[<(3)]\ntrue\n\nNotice that == returns a single value instead of a collection of all elements where the key was found to be true. This is because all keys must be unique so there can only ever be one element returned.\n\n\n\n\n\n","category":"type"},{"location":"references/#AxisIndices.AxisArray","page":"References","title":"AxisIndices.AxisArray","text":"AxisArray{T,N,P,AI}\n\nAn array struct that wraps any parent array and assigns it an AbstractAxis for each dimension. The first argument is the parent array and the second argument is a tuple of subtypes to AbstractAxis or keys that will be converted to subtypes of AbstractAxis with the provided keys.\n\n\n\n\n\n","category":"type"},{"location":"references/#AxisIndices.AxisInitializer","page":"References","title":"AxisIndices.AxisInitializer","text":"AxisInitializer <: Function\n\nSupertype for functions that assist in initialization of AbstractAxis subtypes.\n\n\n\n\n\n","category":"type"},{"location":"references/#AxisIndices.AxisVector","page":"References","title":"AxisIndices.AxisVector","text":"AxisVector\n\nA vector whose indices have keys.\n\nExamples\n\njulia> using AxisIndices\n\njulia> AxisVector([1, 2], [:a, :b])\n2-element AxisArray(::Array{Int64,1}\n  • axes:\n     1 = [:a, :b]\n)\n      1\n  :a  1\n  :b  2  \n\n\n\n\n\n\n","category":"type"},{"location":"references/#AxisIndices.CartesianAxes","page":"References","title":"AxisIndices.CartesianAxes","text":"CartesianAxes\n\nAlias for LinearIndices where indices are subtypes of AbstractAxis.\n\nExamples\n\njulia> using AxisIndices\n\njulia> cartaxes = CartesianAxes((Axis(2.0:5.0), Axis(1:4)));\n\njulia> cartinds = CartesianIndices((1:4, 1:4));\n\njulia> cartaxes[2, 2]\nCartesianIndex(2, 2)\n\njulia> cartinds[2, 2]\nCartesianIndex(2, 2)\n\n\n\n\n\n","category":"type"},{"location":"references/#AxisIndices.CenteredArray","page":"References","title":"AxisIndices.CenteredArray","text":"CenteredArray(A::AbstractArray)\n\nProvides centered axes for indexing A.\n\nExamples\n\njulia> using AxisIndices\n\njulia> AxisIndices.CenteredArray(ones(3,3))\n3×3 AxisArray(::Array{Float64,2}\n  • axes:\n     1 = -1:1\n     2 = -1:1\n)\n      -1    0    1\n  -1   1.0  1.0  1.0\n  0    1.0  1.0  1.0\n  1    1.0  1.0  1.0\n\n\n\n\n\n\n","category":"type"},{"location":"references/#AxisIndices.CenteredAxis","page":"References","title":"AxisIndices.CenteredAxis","text":"CenteredAxis(origin=0, indices)\n\nA CenteredAxis takes indices and provides a user facing set of keys centered around zero. The CenteredAxis is a subtype of AbstractOffsetAxis and its keys are treated as the predominant indexing style. Note that the element type of a CenteredAxis cannot be unsigned because any instance with a length greater than 1 will begin at a negative value.\n\nExamples\n\nA CenteredAxis sends all indexing arguments to the keys and only maps to the indices when to_index is called.\n\njulia> using AxisIndices\n\njulia> axis = CenteredAxis(1:10)\nCenteredAxis(origin=0, parent=SimpleAxis(1:10))\n\njulia> axis[10]  # the indexing goes straight to keys and is centered around zero\nERROR: BoundsError: attempt to access CenteredAxis(origin=0, parent=SimpleAxis(1:10)) at index [10]\n[...]\n\njulia> axis[-4]\n-4\n\n\n\n\n\n\n","category":"type"},{"location":"references/#AxisIndices.CenteredVector","page":"References","title":"AxisIndices.CenteredVector","text":"CenteredVector(v::AbstractVector)\n\nProvides a centered axis for indexing v.\n\nExamples\n\njulia> using AxisIndices\n\njulia> AxisIndices.CenteredVector(ones(3))\n3-element AxisArray(::Array{Float64,1}\n  • axes:\n     1 = -1:1\n)\n      1\n  -1  1.0\n  0   1.0\n  1   1.0\n\n\n\n\n\n\n","category":"type"},{"location":"references/#AxisIndices.CenteredVector-Union{Tuple{T}, Tuple{Union{Missing, Nothing, UndefInitializer},Any}} where T","page":"References","title":"AxisIndices.CenteredVector","text":"CenteredVector{T}(init::ArrayInitializer, sz::Integer)\n\nCreates a vector with elements of type T of size sz and a centered axis.\n\nExamples\n\njulia> using AxisIndices\n\njulia> AxisIndices.CenteredVector{Union{Missing, Int}}(missing, 3)\n3-element AxisArray(::Array{Union{Missing, Int64},1}\n  • axes:\n     1 = -1:1\n)\n      1\n  -1   missing\n  0    missing\n  1    missing\n\n\n\n\n\n\n","category":"method"},{"location":"references/#AxisIndices.IdentityArray","page":"References","title":"AxisIndices.IdentityArray","text":"IdentityArray(A::AbstractArray)\n\nProvides IdentityAxiss for indexing A.\n\nExamples\n\njulia> using AxisIndices\n\njulia> AxisIndices.IdentityArray(ones(3,3))[2:3, 2:3]\n2×2 AxisArray(::Array{Float64,2}\n  • axes:\n     1 = 2:3\n     2 = 2:3\n)\n     2    3\n  2  1.0  1.0\n  3  1.0  1.0\n\n\n\n\n\n\n","category":"type"},{"location":"references/#AxisIndices.IdentityAxis","page":"References","title":"AxisIndices.IdentityAxis","text":"IdentityAxis(start, stop) -> axis\nIdentityAxis(keys::AbstractUnitRange) -> axis\nIdentityAxis(keys::AbstractUnitRange, indices::AbstractUnitRange) -> axis\n\nAbstractAxis subtype that preserves indices after indexing.\n\nExamples\n\njulia> using AxisIndices\n\njulia> axis = IdentityAxis(3:5)\nIdentityAxis(identity=3:5, parent=SimpleAxis(1:3))\n\njulia> axis[4:5]\nIdentityAxis(identity=4:5, parent=SimpleAxis(2:3))\n\n\n\n\n\n\n","category":"type"},{"location":"references/#AxisIndices.IdentityVector","page":"References","title":"AxisIndices.IdentityVector","text":"IdentityVector(v::AbstractVector)\n\nProvides an IdentityAxis for indexing v.\n\nExamples\n\njulia> using AxisIndices\n\njulia> AxisIndices.IdentityVector(ones(4))[3:4]\n2-element AxisArray(::Array{Float64,1}\n  • axes:\n     1 = 3:4\n)\n     1\n  3  1.0\n  4  1.0\n\n\n\n\n\n\n","category":"type"},{"location":"references/#AxisIndices.IdentityVector-Union{Tuple{T}, Tuple{Union{Missing, Nothing, UndefInitializer},Any}} where T","page":"References","title":"AxisIndices.IdentityVector","text":"IdentityVector{T}(init::ArrayInitializer, sz::Integer)\n\nCreates a vector with elements of type T of size sz an IdentityAxis.\n\nExamples\n\njulia> using AxisIndices\n\njulia> AxisIndices.IdentityVector{Union{Missing, Int}}(missing, 3)[2:3]\n2-element AxisArray(::Array{Union{Missing, Int64},1}\n  • axes:\n     1 = 2:3\n)\n     1\n  2   missing\n  3   missing\n\n\n\n\n\n\n\n","category":"method"},{"location":"references/#AxisIndices.IndexAxis","page":"References","title":"AxisIndices.IndexAxis","text":"IndexAxis\n\nIndex style for mapping keys to an array's parent indices.\n\n\n\n\n\n","category":"type"},{"location":"references/#AxisIndices.LinearAxes","page":"References","title":"AxisIndices.LinearAxes","text":"LinearAxes\n\nAlias for LinearIndices where indices are subtypes of AbstractAxis.\n\nExamples\n\njulia> using AxisIndices\n\njulia> linaxes = LinearAxes((Axis(2.0:5.0), Axis(1:4)));\n\njulia> lininds = LinearIndices((1:4, 1:4));\n\njulia> linaxes[2, 2]\n6\n\njulia> lininds[2, 2]\n6\n\n\n\n\n\n","category":"type"},{"location":"references/#AxisIndices.NamedAxisArray","page":"References","title":"AxisIndices.NamedAxisArray","text":"NamedAxisArray(parent::AbstractArray; kwargs...) = NamedAxisArray(parent, kwargs)\nNamedAxisArray(parent::AbstractArray, axes::NamedTuple{L,AbstractAxes})\n\nType alias for NamedDimsArray whose parent array is an AxisArray. If key word arguments are provided then each key word becomes the name of a dimension and its assigned value is sent to the corresponding axis when constructing the underlying AxisArray.\n\nExamples\n\njulia> using AxisIndices\n\njulia> A = NamedAxisArray{(:x, :y, :z)}(reshape(1:24, 2, 3, 4), [\"a\", \"b\"], [\"one\", \"two\", \"three\"], 2:5)\n2×3×4 NamedDimsArray(AxisArray(reshape(::UnitRange{Int64}, 2, 3, 4)\n  • axes:\n     x = [\"a\", \"b\"]\n     y = [\"one\", \"two\", \"three\"]\n     z = 2:5\n))\n[:, :, 2] =\n       \"one\"   \"two\"   \"three\"\n  \"a\"  1       3       5\n  \"b\"  2       4       6\n\n[:, :, 3] =\n       \"one\"   \"two\"    \"three\"\n  \"a\"  7        9       11\n  \"b\"  8       10       12\n\n[:, :, 4] =\n       \"one\"    \"two\"    \"three\"\n  \"a\"  13       15       17\n  \"b\"  14       16       18\n\n[:, :, 5] =\n       \"one\"    \"two\"    \"three\"\n  \"a\"  19       21       23\n  \"b\"  20       22       24\n\njulia> B = A[\"a\", :, :]\n3×4 NamedDimsArray(AxisArray(::Array{Int64,2}\n  • axes:\n     y = [\"one\", \"two\", \"three\"]\n     z = 2:5\n))\n           2  3   4   5\n  \"one\"    1   7  13  19\n  \"two\"    3   9  15  21\n  \"three\"  5  11  17  23\n\njulia> C = B[\"one\",:]\n4-element NamedDimsArray(AxisArray(::Array{Int64,1}\n  • axes:\n     z = 2:5\n))\n     1\n  2   1\n  3   7\n  4  13\n  5  19\n\n\n\n\n\n\n","category":"type"},{"location":"references/#AxisIndices.OffsetArray","page":"References","title":"AxisIndices.OffsetArray","text":"OffsetArray\n\nAn array whose axes are all OffsetAxis\n\n\n\n\n\n","category":"type"},{"location":"references/#AxisIndices.OffsetAxis","page":"References","title":"AxisIndices.OffsetAxis","text":"OffsetAxis(keys::AbstractUnitRange{<:Integer}, parent::AbstractUnitRange{<:Integer}[, check_length::Bool=true])\nOffsetAxis(offset::Integer, parent::AbstractUnitRange{<:Integer})\n\nAn axis that has the indexing behavior of an AbstractOffsetAxis and retains an offset from its underlying indices in its keys. Note that offset is only the offset from the parent indices. If OffsetAxis is part of an AxisArray, the number returned by ArrayInterface.offsets refers to the offset from zero, not the offset found in this axis.\n\nExamples\n\nUsers may construct an OffsetAxis by providing an from a set of indices.\n\njulia> using AxisIndices\n\njulia> axis = OffsetAxis(-2, 1:3)\nOffsetAxis(offset=-2, parent=SimpleAxis(1:3)))\n\n\nIn this instance the first index of the wrapped indices is 1 (firstindex(indices(axis))) but adding the offset (-2) moves it to -1.\n\njulia> firstindex(axis)\n-1\n\njulia> axis[-1]\n-1\n\nSimilarly, the last index is move by -2.\n\njulia> lastindex(axis)\n1\n\njulia> axis[1]\n1\n\n\nThis means that traditional one based indexing no longer applies and may result in errors.\n\njulia> axis[3]\nERROR: BoundsError: attempt to access OffsetAxis(offset=-2, parent=SimpleAxis(1:3))) at index [3]\n[...]\n\nWhen an OffsetAxis is reconstructed the offset from indices are presserved.\n\njulia> axis[0:1]  # offset of -2 still applies\nOffsetAxis(offset=-2, parent=SimpleAxis(2:3)))\n\n\n\n\n\n\n","category":"type"},{"location":"references/#AxisIndices.OffsetVector","page":"References","title":"AxisIndices.OffsetVector","text":"OffsetVector\n\nA vector whose axis is OffsetAxis\n\n\n\n\n\n","category":"type"},{"location":"references/#AxisIndices.PaddedInitializer","page":"References","title":"AxisIndices.PaddedInitializer","text":"PaddedInitializer\n\nAbstract type for padding styles.\n\n\n\n\n\n","category":"type"},{"location":"references/#AxisIndices.SimpleAxis","page":"References","title":"AxisIndices.SimpleAxis","text":"SimpleAxis(v)\n\nPovides an AbstractAxis interface for any AbstractUnitRange, v. v will be considered both the values and keys of the return instance. \n\nExamples\n\nA SimpleAxis is useful for giving a standard set of indices the ability to use the filtering syntax for indexing.\n\njulia> using AxisIndices, StaticRanges\n\njulia> x = SimpleAxis(2:10)\nSimpleAxis(2:10)\n\njulia> x[2]\n2\n\njulia> x[==(2)]\n2\n\njulia> x[2] == x[==(2)]  # keys and values are same\ntrue\n\njulia> x[>(2)]\nSimpleAxis(3:10)\n\njulia> x[>(2)]\nSimpleAxis(3:10)\n\njulia> x[1]\nERROR: BoundsError: attempt to access SimpleAxis(2:10) at index [1]\n[...]\n\n\n\n\n\n","category":"type"},{"location":"references/#AxisIndices.StructAxis","page":"References","title":"AxisIndices.StructAxis","text":"StructAxis{T}\n\nAn axis that uses a structure T to form its keys. the field names of\n\n\n\n\n\n","category":"type"},{"location":"acknowledgments/#Acknowledgments","page":"Acknowledgments","title":"Acknowledgments","text":"","category":"section"},{"location":"acknowledgments/","page":"Acknowledgments","title":"Acknowledgments","text":"This package is the result of many people providing input to make it successful. Hopefully, it will continue to be a product of such collaborations. The following is an incomplete list of individuals who have helped me in some way get this package started. It's mainly a list of people who have tolerated my incessant queries into many minor details that led to this package.","category":"page"},{"location":"acknowledgments/","page":"Acknowledgments","title":"Acknowledgments","text":"Eric Davies\nLyndon White\nMichael Abbott\nRafael Schouten\nTim Holy","category":"page"},{"location":"acknowledgments/","page":"Acknowledgments","title":"Acknowledgments","text":"Also, anyone that has contributed to StaticArrays.jl and NamedDims.jl has probably helped.","category":"page"},{"location":"comparison/#Comparison-to-Other-Packages","page":"Comparison to Other Packages","title":"Comparison to Other Packages","text":"","category":"section"},{"location":"comparison/","page":"Comparison to Other Packages","title":"Comparison to Other Packages","text":"This is very brief overview of how AxisIndices compares to other packages. Rather than a comprehensive comparison of available alternatives and integrations, this is intended to provide a general idea of how AxisIndices fits in the Julia ecosystem.","category":"page"},{"location":"comparison/","page":"Comparison to Other Packages","title":"Comparison to Other Packages","text":"AxisArrays.jl similarly supports mapping some sort of keys to each set of indices. AxisIndices is intended to be a more comprehensive, well documented, and flexible implementation of this concept. AxisArays natively offers the ability to name each dimension. In contrast AxisIndices was developed with the intention of using packages like NamedDims.jl to more fully implement such features in a complementary way.","category":"page"},{"location":"comparison/","page":"Comparison to Other Packages","title":"Comparison to Other Packages","text":"DimensionalData.jl is a notable package that covers many similar funcitonalities as AxisArrays did. There are numerous differences in design decisions between this package and DimensionalData. It's likely that the majority of these differences represent personal preferences rather than strictly objective advantages over one another. In terms of approach, DimensionalData offers a more comprehensive alternative to the functionality of AxisArrays, where AxisIndices is intended only to be a highly customizable component of some of the features AxisArrays offers. Therefore, this package expects users seeking a complete replacement for AxisArrays to ultimately use another package that composes a modular solution to replacing AxisArrays.","category":"page"},{"location":"comparison/","page":"Comparison to Other Packages","title":"Comparison to Other Packages","text":"There are many packages that offer overlapping features. For example, Dictionaries.jl implements a focused improvement on dictionaries where mapping keys to indices highly overlaps. However, as Dictionaries.jl continues to evolve many of the types provided therein may prove extremely useful in constructing the keys of an Axis type thereby giving these dictionaries multidimensional functionality. Similarly, many packages provide overlapping features that could actually be extended with the addition of AxisIndices.","category":"page"},{"location":"#AxisIndices","page":"AxisIndices","title":"AxisIndices","text":"","category":"section"},{"location":"#Introduction","page":"AxisIndices","title":"Introduction","text":"","category":"section"},{"location":"","page":"AxisIndices","title":"AxisIndices","text":"The goals of this package are:","category":"page"},{"location":"","page":"AxisIndices","title":"AxisIndices","text":"Facilitate multidimensional indexing (e.g., instance_of_an_array[indices]) that supports semantic user facing indices (e.g., indices = Second(1)).\nAccomplishing the first goal should not interfere in the ability to perform the vast majority of array related methods (e.g, vcat, append!, etc.).\nIt should be easy to implement new subtypes of AbstractAxis that accommodate novel behavior and needs.","category":"page"},{"location":"","page":"AxisIndices","title":"AxisIndices","text":"These goals are accomplished predominantly through the AbstractAxis type. It is a subtype of AbstractUnitRange{<:Integer} with an additional interface for creating keys and interacting with them. This additional interface is intended to be easily extended to new types that may be needed for a variety of different situations. An additional AxisArray type is provided that uses any subtype of AbstractAxis for each axis. However, many methods are provided and documented internally so that it's easy for users to alter the behavior of an AxisArray with a new AbstractAxis subtype or create an entirely unique multidimensional structure.","category":"page"},{"location":"#Quick-Start","page":"AxisIndices","title":"Quick Start","text":"","category":"section"},{"location":"","page":"AxisIndices","title":"AxisIndices","text":"Custom indexing only requires specifying a tuple of keys[1] for the indices of each dimension.","category":"page"},{"location":"","page":"AxisIndices","title":"AxisIndices","text":"julia> using AxisIndices\n\njulia> A = AxisArray(reshape(1:9, 3,3),\n               (2:4,        # first dimension has keys 2:4\n                3.0:5.0));  # second dimension has keys 3.0:5.0","category":"page"},{"location":"","page":"AxisIndices","title":"AxisIndices","text":"Most code should work just the same for an AxisArray...","category":"page"},{"location":"","page":"AxisIndices","title":"AxisIndices","text":"julia> A[2, 1]\n1\n\njulia> A[2:4, 1:2] == parent(A)[1:3, 1:2]\ntrue\n\njulia> sum(A) == sum(parent(A))\ntrue","category":"page"},{"location":"","page":"AxisIndices","title":"AxisIndices","text":"But now the indices of each dimension have keys that we can filter through.","category":"page"},{"location":"","page":"AxisIndices","title":"AxisIndices","text":"julia> A[==(2), ==(3.0)] == parent(A)[findfirst(==(2), 2:4), findfirst(==(3.0), 3.0:5.0)] == 1\ntrue\n\njulia> A[<(4), <(5.0)] == parent(A)[findall(<(4), 2:4), findall(<(5.0), 3.0:5.0)] == [1 4; 2 5]\ntrue","category":"page"},{"location":"","page":"AxisIndices","title":"AxisIndices","text":"Any value that is not a CartesianIndex or subtype of Real is considered a dedicated key type. In other words, it could never be used for default indexing and will be treated the same as the == filtering syntax above.","category":"page"},{"location":"","page":"AxisIndices","title":"AxisIndices","text":"julia> AxisArray([1, 2, 3], ([\"one\", \"two\", \"three\"],))[\"one\"]\n1","category":"page"},{"location":"","page":"AxisIndices","title":"AxisIndices","text":"Note that the first call only returns a single element, where the last call returns an array. This is because all keys must be unique so there can only be one value that returns true if filtering by ==, which is the same as indexing by 1 (e.g., only one index can equal 1). The last call uses operators that can produce any number of true values and the resulting output is an array. This is the same as indexing an array by any vector (i.e., returns another array).","category":"page"},{"location":"#The-Axis-Interface","page":"AxisIndices","title":"The Axis Interface","text":"","category":"section"},{"location":"","page":"AxisIndices","title":"AxisIndices","text":"The supertype to all axis types herein is the AbstractAxis, which is a subtype of AbstractUnitRange{<:Integer}.","category":"page"},{"location":"","page":"AxisIndices","title":"AxisIndices","text":"If we have a set of keys a b c and a set of indices 1 2 3 then the key a maps to the index 1. Given these definitions, the AbstractAxis differs from the classic dictionary in the following two ways:","category":"page"},{"location":"","page":"AxisIndices","title":"AxisIndices","text":"The valtype of AbstractAxis is always an integer.\nThe values are always unique and continuous.","category":"page"},{"location":"","page":"AxisIndices","title":"AxisIndices","text":"The two main axis types defined here are Axis and SimpleAxis. The standard syntax for indexing doesn't change at all for these types.","category":"page"},{"location":"","page":"AxisIndices","title":"AxisIndices","text":"julia> using AxisIndices\n\njulia> using Dates\n\njulia> using ChainedFixes  # provides `and`, `or`, `⩓`, `⩔` methods\n\njulia> sa = SimpleAxis(1:10)\nSimpleAxis(1:10)\n\njulia> sa[2]\n2\n\njulia> sa[>(2)]\nSimpleAxis(3:10)\n\njulia> a = Axis(1:10)\nAxis(1:10 => SimpleAxis(1:10))\n\njulia> a[2]\n2\n\njulia> a[2:3]\nAxis(2:3 => SimpleAxis(2:3))","category":"page"},{"location":"","page":"AxisIndices","title":"AxisIndices","text":"But now we can also use functions to index by the keys of an AbstractAxis.","category":"page"},{"location":"","page":"AxisIndices","title":"AxisIndices","text":"julia> a = Axis(2.0:11.0)\nAxis(2.0:1.0:11.0 => SimpleAxis(1:10))\n\njulia> a[1]\n1\n\njulia> a[isequal(2.0)]\n1\n\njulia> a[>(2)]\nAxis(3.0:1.0:11.0 => SimpleAxis(2:10))\n\njulia> a[>(2.0)]\nAxis(3.0:1.0:11.0 => SimpleAxis(2:10))\n\njulia> a[and(>(2.0), <(8.0))]\nAxis(3.0:1.0:7.0 => SimpleAxis(2:6))\n\njulia> sa[in(3:5)]\nSimpleAxis(3:5)","category":"page"},{"location":"","page":"AxisIndices","title":"AxisIndices","text":"This also allows certain syntax special treatment because they are obviously not referring to traditional integer based indexing.","category":"page"},{"location":"","page":"AxisIndices","title":"AxisIndices","text":"julia> x, y, z = Axis([:one, :two, :three]), Axis([\"one\", \"two\", \"three\"]), Axis(Second(1):Second(1):Second(3));\n\njulia> x[:one]\n1\n\njulia> x[:one] == y[\"one\"] == z[Second(1)]\ntrue\n\njulia> x[[:one, :two]]\n2-element AxisArray(::Array{Int64,1}\n  • axes:\n     1 = [:one, :two]\n)\n        1\n  :one  1\n  :two  2","category":"page"},{"location":"","page":"AxisIndices","title":"AxisIndices","text":"Note in the last example that a vector was returned instead of an AbstractAxis. An AbstractAxis is a subtype of AbstractUnitRange and therefore cannot be reformed after any operation that does not guarantee the return of another unit range. This is similar to the behavior of UnitRange in base.","category":"page"},{"location":"#Indexing-an-Axis","page":"AxisIndices","title":"Indexing an Axis","text":"","category":"section"},{"location":"","page":"AxisIndices","title":"AxisIndices","text":"Setup for running axis examples.","category":"page"},{"location":"","page":"AxisIndices","title":"AxisIndices","text":"julia> using AxisIndices, Unitful, ChainedFixes\n\njulia> using Unitful: s\n\njulia> time1 = Axis((1.5:.5:10)s)\nAxis((1.5:0.5:10.0) s => SimpleAxis(1:18))\n\njulia> time2 = Axis((1.5:.5:10)s, SimpleAxis(2:19))\nAxis((1.5:0.5:10.0) s => SimpleAxis(2:19))","category":"page"},{"location":"#Indexing-With-Integers","page":"AxisIndices","title":"Indexing With Integers","text":"","category":"section"},{"location":"","page":"AxisIndices","title":"AxisIndices","text":"Integers will map directly to the indices of an axis.","category":"page"},{"location":"","page":"AxisIndices","title":"AxisIndices","text":"julia> time1[1]\n1\n\njulia> time1[2]\n2\n\njulia> time2[2]\n2\n\njulia> time2[1]\nERROR: BoundsError: attempt to access Axis((1.5:0.5:10.0) s => SimpleAxis(2:19)) at index [1]\n[...]","category":"page"},{"location":"","page":"AxisIndices","title":"AxisIndices","text":"Notice that time2[1] throws an error. This is because the indices of the time2 axis don't contain a 1 and begins at 2. This allows an axis to map to any single dimensional memory mapping, even if it doesn't start at 1.","category":"page"},{"location":"","page":"AxisIndices","title":"AxisIndices","text":"Indexing an axis with a collection of integers works similarly to indexing any other AbstractUnitRange. That is, using other subtypes of AbstractUnitRange preserves the structure...","category":"page"},{"location":"","page":"AxisIndices","title":"AxisIndices","text":"julia> time1[1:2]\nAxis((1.5:0.5:2.0) s => SimpleAxis(1:2))\n\njulia> time2[2:3]\nAxis((1.5:0.5:2.0) s => SimpleAxis(2:3))","category":"page"},{"location":"","page":"AxisIndices","title":"AxisIndices","text":"However, we can't ensure that the resulting range will have a step of one in other cases so only the indices are returned.","category":"page"},{"location":"","page":"AxisIndices","title":"AxisIndices","text":"julia> time1[1:2:3]\n2-element AxisArray(::StepRange{Int64,Int64}\n  • axes:\n     1 = (1.5:1.0:2.5) s\n)\n         1\n  1.5 s  1\n  2.5 s  3\n\njulia> time1[[1, 2, 3]]\n3-element AxisArray(::Array{Int64,1}\n  • axes:\n     1 = Unitful.Quantity{Float64,𝐓,Unitful.FreeUnits{(s,),𝐓,nothing}}[1.5 s, 2.0 s, 2.5 s]\n)\n         1\n  1.5 s  1\n  2.0 s  2\n  2.5 s  3\n\njulia> time1[firstindex(time1):end]\nAxis((1.5:0.5:10.0) s => SimpleAxis(1:18))\n","category":"page"},{"location":"#Indexing-With-Keys","page":"AxisIndices","title":"Indexing With Keys","text":"","category":"section"},{"location":"","page":"AxisIndices","title":"AxisIndices","text":"julia> time1[1.5s]\n1\n\njulia> time2[1.5s]\n2","category":"page"},{"location":"","page":"AxisIndices","title":"AxisIndices","text":"julia> time1[1.5s..3s]\nAxis((1.5:0.5:3.0) s => SimpleAxis(1:4))\n\njulia> time1[3s..4.5s]\nAxis((3.0:0.5:4.5) s => SimpleAxis(4:7))","category":"page"},{"location":"#Approximate-Indexing","page":"AxisIndices","title":"Approximate Indexing","text":"","category":"section"},{"location":"","page":"AxisIndices","title":"AxisIndices","text":"julia> axis = Axis([pi + 0, pi + 1]);\n\njulia> axis[3.141592653589793]\n1\n\njulia> axis[3.14159265358979]\nERROR: BoundsError: attempt to access Axis([3.141592653589793, 4.141592653589793] => SimpleAxis(1:2)) at index [3.14159265358979]\n[...]\n\njulia> axis[isapprox(3.14159265358979)]\n1\n\njulia> axis[isapprox(3.14, atol=1e-2)]\n1","category":"page"},{"location":"#Indexing-With-Functions","page":"AxisIndices","title":"Indexing With Functions","text":"","category":"section"},{"location":"","page":"AxisIndices","title":"AxisIndices","text":"Operators that typically return true or false can often ","category":"page"},{"location":"","page":"AxisIndices","title":"AxisIndices","text":"julia> time1[<(3.0s)]\nAxis((1.5:0.5:2.5) s => SimpleAxis(1:3))\n\njulia> time1[>(3.0s)]\nAxis((3.5:0.5:10.0) s => SimpleAxis(5:18))\n\njulia> time1[==(6.0s)]\n10\n\njulia> time1[!=(6.0s)] == vcat(1:9, 11:18)\ntrue","category":"page"},{"location":"","page":"AxisIndices","title":"AxisIndices","text":"These operators can also be combined to get more specific regions of an axis.","category":"page"},{"location":"","page":"AxisIndices","title":"AxisIndices","text":"julia> time1[and(>(2.5s), <(10.0s))]\nAxis((3.0:0.5:9.5) s => SimpleAxis(4:17))\n\njulia> time1[>(2.5s) ⩓ <(10.0s)]  # equivalent to `and` you can use \\And<TAB>\nAxis((3.0:0.5:9.5) s => SimpleAxis(4:17))\n\njulia> time1[or(<(2.5s),  >(9.0s))] == vcat(1:2, 17:18)\ntrue\n\njulia> time1[<(2.5s) ⩔ >(9.0s)] == vcat(1:2, 17:18) # equivalent to `or` you can use \\Or<TAB>\ntrue\n","category":"page"},{"location":"#The-Array-Interface","page":"AxisIndices","title":"The Array Interface","text":"","category":"section"},{"location":"#Construction","page":"AxisIndices","title":"Construction","text":"","category":"section"},{"location":"","page":"AxisIndices","title":"AxisIndices","text":"Take a standard array and attach custom keys along the indices of each dimension.","category":"page"},{"location":"","page":"AxisIndices","title":"AxisIndices","text":"julia> using AxisIndices\n\njulia> A_base = [1 2; 3 4];\n\njulia> A_axis = AxisArray(A_base, [\"a\", \"b\"], [:one, :two])\n2×2 AxisArray(::Array{Int64,2}\n  • axes:\n     1 = [\"a\", \"b\"]\n     2 = [:one, :two]\n)\n       :one   :two\n  \"a\"  1      2\n  \"b\"  3      4\n","category":"page"},{"location":"","page":"AxisIndices","title":"AxisIndices","text":"Note that the keys provided are converted to a subtype of AbstractAxis.","category":"page"},{"location":"","page":"AxisIndices","title":"AxisIndices","text":"julia> axes(A_axis, 1)\nAxis([\"a\", \"b\"] => SimpleAxis(1:2))\n","category":"page"},{"location":"","page":"AxisIndices","title":"AxisIndices","text":"An AxisArray may also be initialized using similar syntax as Array{T}(undef, dims).","category":"page"},{"location":"","page":"AxisIndices","title":"AxisIndices","text":"julia> A_axis = AxisArray{Int}(undef, [\"a\", \"b\"], [:one, :two]);\n\njulia> A_axis[:,:] = A_base;\n\njulia> A_axis\n2×2 AxisArray(::Array{Int64,2}\n  • axes:\n     1 = [\"a\", \"b\"]\n     2 = [:one, :two]\n)\n       :one   :two\n  \"a\"  1      2\n  \"b\"  3      4\n","category":"page"},{"location":"","page":"AxisIndices","title":"AxisIndices","text":"We can also attach metadata to an array.","category":"page"},{"location":"","page":"AxisIndices","title":"AxisIndices","text":"julia> using Metadata\n\njulia> attach_metadata(AxisArray(A_base, ([\"a\", \"b\"], [:one, :two])), (m1 = 1, m2 = 2))\n2×2 attach_metadata(AxisArray(::Array{Int64,2}\n  • axes:\n     1 = [\"a\", \"b\"]\n     2 = [:one, :two]\n), ::NamedTuple{(:m1, :m2),Tuple{Int64,Int64}}\n  • metadata:\n     m1 = 1\n     m2 = 2\n)\n       :one   :two\n  \"a\"  1      2\n  \"b\"  3      4\n\njulia> attach_metadata(NamedAxisArray{(:xdim, :ydim)}(A_base, [\"a\", \"b\"], [:one, :two]), (m1 = 1, m2 = 2))\n2×2 NamedDimsArray(attach_metadata(AxisArray(::Array{Int64,2}\n  • axes:\n     xdim = [\"a\", \"b\"]\n     ydim = [:one, :two]\n), ::NamedTuple{(:m1, :m2),Tuple{Int64,Int64}}\n  • metadata:\n     m1 = 1\n     m2 = 2\n))\n       :one   :two\n  \"a\"  1      2\n  \"b\"  3      4\n","category":"page"},{"location":"#Combining-Different-Axes","page":"AxisIndices","title":"Combining Different Axes","text":"","category":"section"},{"location":"","page":"AxisIndices","title":"AxisIndices","text":"One of benefits of AxisIndices using a unified backend for multiple axis types is that they can be arbitrarily mixed together. For example, here's an example the first indices are offset by 4 and the last indices are centered.","category":"page"},{"location":"","page":"AxisIndices","title":"AxisIndices","text":"julia> AxisArray(ones(3,3), offset(4), center)\n3×3 AxisArray(::Array{Float64,2}\n  • axes:\n     1 = 5:7\n     2 = -1:1\n)\n     -1    0    1\n  5   1.0  1.0  1.0\n  6   1.0  1.0  1.0\n  7   1.0  1.0  1.0\n","category":"page"},{"location":"","page":"AxisIndices","title":"AxisIndices","text":"Although this example isn't particularly useful, being able to arbitrarily mix axes with static characteristics, metadata, offset indices, semantic keys, etc. lends itself to easy custom designs and algorithms.","category":"page"},{"location":"#Performance","page":"AxisIndices","title":"Performance","text":"","category":"section"},{"location":"","page":"AxisIndices","title":"AxisIndices","text":"Indexing CartesianAxes is comparable to that of CartesianIndices.","category":"page"},{"location":"","page":"AxisIndices","title":"AxisIndices","text":"julia> using AxisIndices, BenchmarkTools\n\njulia> cartaxes = CartesianAxes((Axis(2.0:5.0), Axis(1:4)));\n\njulia> cartinds = CartesianIndices((1:4, 1:4));\n\njulia> @btime getindex(cartaxes, 2, 2)\n20.848 ns (1 allocation: 32 bytes)\nCartesianIndex(2, 2)\n\njulia> @btime getindex(cartinds, 2, 2)\n22.317 ns (1 allocation: 32 bytes)\nCartesianIndex(2, 2)\n\njulia> @btime getindex(cartaxes, ==(3.0), 2)\n444.374 ns (7 allocations: 416 bytes)\nCartesianIndex(2, 2)","category":"page"},{"location":"","page":"AxisIndices","title":"AxisIndices","text":"Indexing LinearAxes is comparable to that of LinearIndices","category":"page"},{"location":"","page":"AxisIndices","title":"AxisIndices","text":"julia> using AxisIndices, BenchmarkTools\n\njulia> linaxes = LinearAxes((Axis(1.0:4.0), Axis(1:4)));\n\njulia> lininds = LinearIndices((1:4, 1:4));\n\njulia> @btime getindex(linaxes, 2, 2)\n18.275 ns (0 allocations: 0 bytes)\n6\n\njulia> @btime getindex(lininds, 2, 2)\n18.849 ns (0 allocations: 0 bytes)\n6\n\njulia> @btime getindex(linaxes, ==(3.0), 2)\n381.098 ns (6 allocations: 384 bytes)\n7","category":"page"},{"location":"","page":"AxisIndices","title":"AxisIndices","text":"You may notice there's significant overhead for using the filtering syntax. However, the filtering syntax takes advantage of a special type in base, Fix2. This means that we can take advantage of filtering methods that have been optimized for specific types of keys.  Here we do the same thing as above but we create a function that knows it's going to perform filtering.","category":"page"},{"location":"","page":"AxisIndices","title":"AxisIndices","text":"julia> getindex_filter(a, i1, i2) = a[==(i1), ==(i2)]\ngetindex_filter (generic function with 1 method)\n\njulia> @btime getindex_filter(linaxes, 3.0, 2)\n57.216 ns (0 allocations: 0 bytes)\n7\n\njulia> linaxes2 = LinearAxes((Axis(Base.OneTo(4)), Axis(Base.OneTo(4))));\n\njulia> @btime getindex_filter(linaxes2, 3, 2)\n22.070 ns (0 allocations: 0 bytes)\n7","category":"page"},{"location":"","page":"AxisIndices","title":"AxisIndices","text":"Indexing linaxes is much faster now that it can be optimized inside of a function call. However, it's still a little over twice as slow as normal indexing. That's largely because of the cost of searching 1.0:4.0 (which is a StepRangeLen type in this case). The second benchmark demonstrates how close we really are to standard indexing given similar range types.","category":"page"},{"location":"#Notes","page":"AxisIndices","title":"Notes","text":"","category":"section"},{"location":"","page":"AxisIndices","title":"AxisIndices","text":"[1]: Terminology here is important here. Keys, indices, and axes each have a specific meaning. Throughout the documentation the following functional definitions apply:","category":"page"},{"location":"","page":"AxisIndices","title":"AxisIndices","text":"axis: maps a set of keys to a set of indices.\nindices: a set of integers (e.g., <:Integer) that locate the in memory locations of elements.\nkeys: maps a set of any type to a set of indices\nindexing: anytime one calls getindex or uses square brackets to navigate the elements of a collection","category":"page"},{"location":"","page":"AxisIndices","title":"AxisIndices","text":"Also note the use of argument (abbreviated arg in code) and arguments (abbreviated args in code). These terms specifically refer to what users pass to an indexing method. Therefore, an argument may be a key (:a), index (1), or something else that maps to one of the two (==(1)).","category":"page"}]
}
