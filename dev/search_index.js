var documenterSearchIndex = {"docs":
[{"location":"axis_types/#Axis-Types-1","page":"Types","title":"Axis Types","text":"","category":"section"},{"location":"axis_types/#","page":"Types","title":"Types","text":"AxisIndices.AbstractAxis\nAxisIndices.Axis\nAxisIndices.SimpleAxis\nAxisIndices.CartesianAxes\nAxisIndices.LinearAxes","category":"page"},{"location":"axis_types/#AxisIndices.AbstractAxis","page":"Types","title":"AxisIndices.AbstractAxis","text":"AbstractAxis\n\nAn AbstractVector subtype optimized for indexing.\n\n\n\n\n\n","category":"type"},{"location":"axis_types/#AxisIndices.Axis","page":"Types","title":"AxisIndices.Axis","text":"Axis(k[, v=OneTo(length(k))])\n\nSubtypes of AbstractAxis that maps keys to values. The first argument specifies the keys and the second specifies the values. If only one argument is specified then the values span from 1 to the length of k.\n\nExamples\n\nThe value for all of these is the same.\n\njulia> using AxisIndices\n\njulia> x = Axis(2.0:11.0, 1:10)\nAxis(2.0:1.0:11.0 => 1:10)\n\njulia> y = Axis(2.0:11.0)  # when only one argument is specified assume it's the keys\nAxis(2.0:1.0:11.0 => Base.OneTo(10))\n\njulia> z = Axis(1:10)\nAxis(1:10 => Base.OneTo(10))\n\nStandard indexing returns the same values\n\njulia> x[2]\n2\n\njulia> x[2] == y[2] == z[2]\ntrue\n\njulia> x[1:2]\nAxis(2.0:1.0:3.0 => 1:2)\n\njulia> y[1:2]\nAxis(2.0:1.0:3.0 => 1:2)\n\njulia> z[1:2]\nAxis(1:2 => 1:2)\n\njulia> x[1:2] == y[1:2] == z[1:2]\ntrue\n\nFunctions that return true or false may be used to search the keys for their corresponding index. The following is equivalent to the previous example.\n\njulia> x[==(3.0)]\n2\n\njulia> x[==(3.0)] ==       # 3.0 is the 2nd key of x\n       y[isequal(3.0)] ==  # 3.0 is the 2nd key of y\n       z[==(2)]            # 2 is the 2nd key of z\ntrue\n\njulia> x[<(4.0)]  # all keys less than 4.0 are 2.0:3.0 which correspond to values 1:2\nAxis(2.0:1.0:3.0 => 1:2)\n\njulia> y[<=(3.0)]  # all keys less than or equal to 3.0 are 2.0:3.0 which correspond to values 1:2\nAxis(2.0:1.0:3.0 => 1:2)\n\njulia> z[<(3)]  # all keys less than or equal to 3 are 1:2 which correspond to values 1:2\nAxis(1:2 => 1:2)\n\njulia> x[<(4.0)] == y[<=(3.0)] == z[<(3)]\ntrue\n\nNotice that == returns a single value instead of a collection of all elements where the key was found to be true. This is because all keys must be unique so there can only ever be one element returned.\n\n\n\n\n\n","category":"type"},{"location":"axis_types/#AxisIndices.SimpleAxis","page":"Types","title":"AxisIndices.SimpleAxis","text":"SimpleAxis(v)\n\nPovides an AbstractAxis interface for any AbstractUnitRange, v. v will be considered both the values and keys of the return instance. \n\nExamples\n\nA SimpleAxis is useful for giving a standard set of indices the ability to use the filtering syntax for indexing.\n\njulia> using AxisIndices\n\njulia> x = SimpleAxis(2:10)\nSimpleAxis(2:10)\n\njulia> x[2]\n3\n\njulia> x[==(2)]\n2\n\njulia> x[2] == x[==(3)]\ntrue\n\njulia> x[>(2)]\nSimpleAxis(3:10)\n\njulia> x[>(2)]\nSimpleAxis(3:10)\n\n\n\n\n\n","category":"type"},{"location":"axis_types/#AxisIndices.CartesianAxes","page":"Types","title":"AxisIndices.CartesianAxes","text":"CartesianAxes\n\nAlias for LinearIndices where indices are subtypes of AbstractAxis.\n\njulia> using AxisIndices\n\njulia> cartaxes = CartesianAxes((Axis(2.0:5.0), Axis(1:4)));\n\njulia> cartinds = CartesianIndices((1:4, 1:4));\n\njulia> cartaxes[2, 2]\nCartesianIndex(2, 2)\n\njulia> cartinds[2, 2]\nCartesianIndex(2, 2)\n\n\n\n\n\n","category":"type"},{"location":"axis_types/#AxisIndices.LinearAxes","page":"Types","title":"AxisIndices.LinearAxes","text":"LinearAxes\n\nAlias for LinearIndices where indices are subtypes of AbstractAxis.\n\njulia> using AxisIndices\n\njulia> linaxes = LinearAxes((Axis(2.0:5.0), Axis(1:4)));\n\njulia> lininds = LinearIndices((1:4, 1:4));\n\njulia> linaxes[2, 2]\n6\n\njulia> lininds[2, 2]\n6\n\n\n\n\n\n","category":"type"},{"location":"axis_types/#","page":"Types","title":"Types","text":"The majority of the AbstractAxis interface is already present in Julia, but we provide several methods to gather type information.","category":"page"},{"location":"axis_types/#","page":"Types","title":"Types","text":"AxisIndices.values_type\nAxisIndices.keys_type","category":"page"},{"location":"axis_types/#AxisIndices.values_type","page":"Types","title":"AxisIndices.values_type","text":"values_type(x)\n\nRetrieves the type of the values of x. This should be functionally equivalent to typeof(values(x)).\n\nExamples\n\njulia> using AxisIndices\n\njulia>  values_type(Axis(1:2))\nBase.OneTo{Int64}\n\njulia> values_type(typeof(Axis(1:2)))\nBase.OneTo{Int64}\n\njulia> values_type(typeof(1:2))\nUnitRange{Int64}\n\n\n\n\n\n","category":"function"},{"location":"axis_types/#AxisIndices.keys_type","page":"Types","title":"AxisIndices.keys_type","text":"keys_type(x)\n\nRetrieves the type of the keys of x.\n\nExamples\n\njulia> using AxisIndices\n\njulia>  keys_type(Axis(1:2))\nUnitRange{Int64}\n\njulia> keys_type(typeof(Axis(1:2)))\nUnitRange{Int64}\n\njulia> keys_type(UnitRange{Int})\nBase.OneTo{Int64}\n\n\n\n\n\n","category":"function"},{"location":"axes_to_arrays/#Axes-to-Arrays-1","page":"Axes to Arrays","title":"Axes to Arrays","text":"","category":"section"},{"location":"axes_to_arrays/#","page":"Axes to Arrays","title":"Axes to Arrays","text":"Most of the methods up to this point are potentially useful for manipulating an axis independent of a parent structure that it may belong to. However, we want it to be easy to use an AbstractAxis in a variety of settings. The following methods are likely to only be useful when extending the use of a multidimensional arrays to use the AbstractAxis interface.","category":"page"},{"location":"axes_to_arrays/#Swapping-Axes-1","page":"Axes to Arrays","title":"Swapping Axes","text":"","category":"section"},{"location":"axes_to_arrays/#","page":"Axes to Arrays","title":"Axes to Arrays","text":"AxisIndices.drop_axes\nAxisIndices.permute_axes\nAxisIndices.reduce_axes\nAxisIndices.reduce_axis","category":"page"},{"location":"axes_to_arrays/#AxisIndices.drop_axes","page":"Axes to Arrays","title":"AxisIndices.drop_axes","text":"drop_axes(x, dims)\n\nReturns all axes of x except for those identified by dims. Elements of dims must be unique integers or symbols corresponding to the dimensions or names of dimensions of x.\n\nExamples\n\njulia> using AxisIndices\n\njulia> axs = (Axis(1:5), Axis(1:10));\n\njulia> drop_axes(axs, 1)\n(Axis(1:10 => Base.OneTo(10)),)\n\njulia> drop_axes(axs, 2)\n(Axis(1:5 => Base.OneTo(5)),)\n\njulia> drop_axes(rand(2, 4), 2)\n(Base.OneTo(2),)\n\n\n\n\n\n","category":"function"},{"location":"axes_to_arrays/#AxisIndices.permute_axes","page":"Axes to Arrays","title":"AxisIndices.permute_axes","text":"permute_axes(x::AbstractArray, p::Tuple) = permute_axes(axes(x), p)\npermute_axes(x::NTuple{N}, p::NTuple{N}) -> NTuple{N}\n\nReturns axes of x in the order of p.\n\nExamples\n\njulia> using AxisIndices\n\njulia> permute_axes(rand(2, 4, 6), (1, 3, 2))\n(Base.OneTo(2), Base.OneTo(6), Base.OneTo(4))\n\njulia> permute_axes((Axis(1:2), Axis(1:4), Axis(1:6)), (1, 3, 2))\n(Axis(1:2 => Base.OneTo(2)), Axis(1:6 => Base.OneTo(6)), Axis(1:4 => Base.OneTo(4)))\n\n\n\n\n\npermute_axes(x::AbstractVector)\n\nReturns the permuted axes of x as axes of size 1 Ã— length(x)\n\nExamples\n\njulia> using AxisIndices\n\njulia> length.(permute_axes(rand(4))) == (1, 4)\ntrue\n\njulia> permute_axes((Axis(1:4),))\n(SimpleAxis(Base.OneTo(1)), Axis(1:4 => Base.OneTo(4)))\n\njulia> permute_axes((Axis(mrange(1, 4)),))\n(SimpleAxis(OneToMRange(1)), Axis(UnitMRange(1:4) => OneToMRange(4)))\n\njulia> permute_axes((Axis(srange(1, 4)),))\n(SimpleAxis(OneToSRange(1)), Axis(UnitSRange(1:4) => OneToSRange(4)))\n\n\n\n\n\npermute_axes(m::AbstractMatrix) -> NTuple{2}\n\nPermute the axes of the matrix m, by flipping the elements across the diagonal of the matrix. Differs from LinearAlgebra's transpose in that the operation is not recursive.\n\nExamples\n\njulia> using AxisIndices\n\njulia> permute_axes(rand(4, 2))\n(Base.OneTo(2), Base.OneTo(4))\n\njulia> permute_axes((Axis(1:4), Axis(1:2)))\n(Axis(1:2 => Base.OneTo(2)), Axis(1:4 => Base.OneTo(4)))\n\n\n\n\n\n","category":"function"},{"location":"axes_to_arrays/#AxisIndices.reduce_axes","page":"Axes to Arrays","title":"AxisIndices.reduce_axes","text":"reduce_axes(a, dims)\n\nReturns the appropriate axes for a measure that reduces dimensions along the dimensions dims.\n\nExample\n\njulia> using AxisIndices\n\njulia> reduce_axes(rand(2, 4), 2)\n(Base.OneTo(2), Base.OneTo(1))\n\njulia> reduce_axes(rand(2, 4), (1,2))\n(Base.OneTo(1), Base.OneTo(1))\n\njulia> reduce_axes(rand(2, 4), :)\n()\n\njulia> reduce_axes((Axis(1:4), Axis(1:4)), 2)\n(Axis(1:4 => Base.OneTo(4)), Axis(1:1 => Base.OneTo(1)))\n\n\n\n\n\n","category":"function"},{"location":"axes_to_arrays/#AxisIndices.reduce_axis","page":"Axes to Arrays","title":"AxisIndices.reduce_axis","text":"reduce_axis(a)\n\nReduces axis a to single value. Allows custom index types to have custom behavior throughout reduction methods (e.g., sum, prod, etc.)\n\nSee also: reduce_axes\n\nExample\n\njulia> using AxisIndices\n\njulia> reduce_axis(Axis(1:4))\nAxis(1:1 => Base.OneTo(1))\n\njulia> reduce_axis(1:4)\n1:1\n\n\n\n\n\n","category":"function"},{"location":"axes_to_arrays/#Matrix-Multiplication-and-Statistics-1","page":"Axes to Arrays","title":"Matrix Multiplication and Statistics","text":"","category":"section"},{"location":"axes_to_arrays/#","page":"Axes to Arrays","title":"Axes to Arrays","text":"AxisIndices.matmul_axes\nAxisIndices.inverse_axes\nAxisIndices.covcor_axes","category":"page"},{"location":"axes_to_arrays/#AxisIndices.matmul_axes","page":"Axes to Arrays","title":"AxisIndices.matmul_axes","text":"matmul_axes(a, b) -> Tuple\n\nReturns the appropriate axes for the return of a * b where a and b are a vector or matrix.\n\nExamples\n\njulia> using AxisIndices\n\njulia> axs2, axs1 = (Axis(1:2), Axis(1:4)), (Axis(1:6),);\n\njulia> matmul_axes(axs2, axs2)\n(Axis(1:2 => Base.OneTo(2)), Axis(1:4 => Base.OneTo(4)))\n\njulia> matmul_axes(axs1, axs2)\n(Axis(1:6 => Base.OneTo(6)), Axis(1:4 => Base.OneTo(4)))\n\njulia> matmul_axes(axs2, axs1)\n(Axis(1:2 => Base.OneTo(2)),)\n\njulia> matmul_axes(axs1, axs1)\n()\n\njulia> matmul_axes(rand(2, 4), rand(4, 2))\n(Base.OneTo(2), Base.OneTo(2))\n\njulia> matmul_axes(CartesianAxes((2,4)), CartesianAxes((4, 2))) == matmul_axes(rand(2, 4), rand(4, 2))\ntrue\n\n\n\n\n\n","category":"function"},{"location":"axes_to_arrays/#AxisIndices.inverse_axes","page":"Axes to Arrays","title":"AxisIndices.inverse_axes","text":"inverse_axes(a::AbstractMatrix) = inverse_axes(axes(a))\ninverse_axes(a::Tuple{I1,I2}) -> Tuple{I2,I1}\n\nReturns the inverted axes of a, corresponding to the inv method from the  LinearAlgebra package in the standard library.\n\nExamples\n\njulia> using AxisIndices\n\njulia> inverse_axes(rand(2,4))\n(Base.OneTo(4), Base.OneTo(2))\n\njulia> inverse_axes((Axis(1:2), Axis(1:4)))\n(Axis(1:4 => Base.OneTo(4)), Axis(1:2 => Base.OneTo(2)))\n\n\n\n\n\n","category":"function"},{"location":"axes_to_arrays/#AxisIndices.covcor_axes","page":"Axes to Arrays","title":"AxisIndices.covcor_axes","text":"covcor_axes(x, dim) -> NTuple{2}\n\nReturns appropriate axes for a cov or var method on array x.\n\nExamples\n\njulia> using AxisIndices\n\njulia> covcor_axes(rand(2,4), 1)\n(Base.OneTo(4), Base.OneTo(4))\n\njulia> covcor_axes((Axis(1:4), Axis(1:6)), 2)\n(Axis(1:4 => Base.OneTo(4)), Axis(1:4 => Base.OneTo(4)))\n\njulia> covcor_axes((Axis(1:4), Axis(1:4)), 1)\n(Axis(1:4 => Base.OneTo(4)), Axis(1:4 => Base.OneTo(4)))\n\nEach axis is resize to equal to the smallest sized dimension if given a dimensional argument greater than 2.\n\njulia> covcor_axes((Axis(2:4), Axis(3:4)), 3)\n(Axis(2:3 => Base.OneTo(2)), Axis(3:4 => Base.OneTo(2)))\n\n\n\n\n\n","category":"function"},{"location":"axisindicesarray/#AxisIndicesArray-1","page":"AxisIndicesArray","title":"AxisIndicesArray","text":"","category":"section"},{"location":"axisindicesarray/#","page":"AxisIndicesArray","title":"AxisIndicesArray","text":"AxisIndicesArray is provided as a convenient subtype of AbstractArray for using instances of AbstractAxis. The implementation is meant to be basic and have sane defaults that can be overridden as necessary. In other words, default methods for manipulating arrays that return an AxisIndicesArray should not cause unexpected downstream behavior for users. However, it should also be possible to change the behavior of an AxisIndicesArray through unique subtypes of AbstractAxis.","category":"page"},{"location":"resize_axes/#Resizing-Axes-1","page":"Resizing Axes","title":"Resizing Axes","text":"","category":"section"},{"location":"resize_axes/#","page":"Resizing Axes","title":"Resizing Axes","text":"These methods help with operations that need to resize axes, either dynamically or by creating a new instance of an axis. In addition to helping with operations related to array resizing, these may be useful for managing the axis of a vector throughout a push!, pushfirst!, pop, and popfirst! operation.","category":"page"},{"location":"resize_axes/#","page":"Resizing Axes","title":"Resizing Axes","text":"AxisIndices.resize_first\nAxisIndices.resize_first!\nAxisIndices.resize_last\nAxisIndices.resize_last!\n\nAxisIndices.grow_first\nAxisIndices.grow_first!\nAxisIndices.grow_last\nAxisIndices.grow_last!\n\nAxisIndices.shrink_first\nAxisIndices.shrink_first!\nAxisIndices.shrink_last\nAxisIndices.shrink_last!\n\nAxisIndices.next_type\nAxisIndices.prev_type","category":"page"},{"location":"resize_axes/#AxisIndices.resize_first","page":"Resizing Axes","title":"AxisIndices.resize_first","text":"resize_first(x, n::Integer)\n\nReturns a collection similar to x that grows or shrinks from the first index to be of size n.\n\nExamples\n\njulia> using AxisIndices\n\njulia> x = collect(1:5);\n\njulia> resize_first(x, 2)\n2-element Array{Int64,1}:\n 4\n 5\n\njulia> resize_first(x, 7)\n7-element Array{Int64,1}:\n -1\n  0\n  1\n  2\n  3\n  4\n  5\n\njulia> resize_first(x, 5)\n5-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5\n\n\n\n\n\n","category":"function"},{"location":"resize_axes/#AxisIndices.resize_first!","page":"Resizing Axes","title":"AxisIndices.resize_first!","text":"resize_first!(x, n::Integer)\n\nReturns the collection x after growing or shrinking the first index to be of size n.\n\nExamples\n\njulia> using AxisIndices\n\njulia> x = collect(1:5);\n\njulia> resize_first!(x, 2);\n\njulia> x\n2-element Array{Int64,1}:\n 4\n 5\n\njulia> resize_first!(x, 6);\n\njulia> x\n6-element Array{Int64,1}:\n 0\n 1\n 2\n 3\n 4\n 5\n\n\n\n\n\n\n","category":"function"},{"location":"resize_axes/#AxisIndices.resize_last","page":"Resizing Axes","title":"AxisIndices.resize_last","text":"resize_last(x, n::Integer)\n\nReturns a collection similar to x that grows or shrinks from the last index to be of size n.\n\nExamples\n\njulia> using AxisIndices\n\njulia> x = collect(1:5);\n\njulia> resize_last(x, 2)\n2-element Array{Int64,1}:\n 1\n 2\n\njulia> resize_last(x, 7)\n7-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n\njulia>  resize_last(x, 5)\n5-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5\n\n\n\n\n\n\n","category":"function"},{"location":"resize_axes/#AxisIndices.resize_last!","page":"Resizing Axes","title":"AxisIndices.resize_last!","text":"resize_last!(x, n::Integer)\n\nReturns the collection x after growing or shrinking the last index to be of size n.\n\nExamples\n\njulia> using AxisIndices\n\njulia> x = collect(1:5);\n\njulia> resize_last!(x, 2);\n\njulia> x\n2-element Array{Int64,1}:\n 1\n 2\n\njulia> resize_last!(x, 5);\n\njulia> x\n5-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5\n\n\n\n\n\n\n","category":"function"},{"location":"resize_axes/#AxisIndices.grow_first","page":"Resizing Axes","title":"AxisIndices.grow_first","text":"grow_first(x, n)\n\nReturns a collection similar to x that grows by n elements from the first index.\n\nExamples\n\njulia> using AxisIndices\n\njulia> mr = UnitMRange(1, 10)\nUnitMRange(1:10)\n\njulia> grow_first(mr, 2)\nUnitMRange(-1:10)\n\n\n\n\n\n","category":"function"},{"location":"resize_axes/#AxisIndices.grow_first!","page":"Resizing Axes","title":"AxisIndices.grow_first!","text":"grow_first!(x, n)\n\nReturns the collection x after growing from the first index by n elements.\n\nExamples\n\njulia> using AxisIndices\n\njulia> mr = UnitMRange(1, 10)\nUnitMRange(1:10)\n\njulia> grow_first!(mr, 2);\n\njulia> mr\nUnitMRange(-1:10)\n\n\n\n\n\n","category":"function"},{"location":"resize_axes/#AxisIndices.grow_last","page":"Resizing Axes","title":"AxisIndices.grow_last","text":"grow_last(x, n)\n\nReturns a collection similar to x that grows by n elements from the last index.\n\nExamples\n\njulia> using AxisIndices\n\njulia> mr = UnitMRange(1, 10)\nUnitMRange(1:10)\n\njulia> grow_last(mr, 2)\nUnitMRange(1:12)\n\n\n\n\n\n","category":"function"},{"location":"resize_axes/#AxisIndices.grow_last!","page":"Resizing Axes","title":"AxisIndices.grow_last!","text":"grow_last!(x, n)\n\nReturns the collection x after growing from the last index by n elements.\n\nExamples\n\njulia> using AxisIndices\n\njulia> mr = UnitMRange(1, 10)\nUnitMRange(1:10)\n\njulia> grow_last!(mr, 2);\n\njulia> mr\nUnitMRange(1:12)\n\n\n\n\n\n","category":"function"},{"location":"resize_axes/#AxisIndices.shrink_first","page":"Resizing Axes","title":"AxisIndices.shrink_first","text":"shrink_first(x, n)\n\nReturns a collection similar to x that shrinks by n elements from the first index.\n\nExamples\n\njulia> using AxisIndices\n\njulia> mr = UnitMRange(1, 10)\nUnitMRange(1:10)\n\njulia> shrink_first(mr, 2)\nUnitMRange(3:10)\n\n\n\n\n\n","category":"function"},{"location":"resize_axes/#AxisIndices.shrink_first!","page":"Resizing Axes","title":"AxisIndices.shrink_first!","text":"shrink_first!(x, n)\n\nReturns the collection x after shrinking from the first index by n elements.\n\n\n\n\n\n","category":"function"},{"location":"resize_axes/#AxisIndices.shrink_last","page":"Resizing Axes","title":"AxisIndices.shrink_last","text":"shrink_last(x, n)\n\nReturns a collection similar to x that shrinks by n elements from the last index.\n\nExamples\n\njulia> using AxisIndices\n\njulia> mr = UnitMRange(1, 10)\nUnitMRange(1:10)\n\njulia> shrink_last(mr, 2)\nUnitMRange(1:8)\n\n\n\n\n\n","category":"function"},{"location":"resize_axes/#AxisIndices.shrink_last!","page":"Resizing Axes","title":"AxisIndices.shrink_last!","text":"shrink_last!(x, n)\n\nReturns the collection x after shrinking from the last index by n elements.\n\nExamples\n\njulia> using AxisIndices\n\njulia> mr = UnitMRange(1, 10)\nUnitMRange(1:10)\n\njulia> shrink_last!(mr, 2);\n\njulia> mr\nUnitMRange(1:8)\n\n\n\n\n\n","category":"function"},{"location":"resize_axes/#AxisIndices.next_type","page":"Resizing Axes","title":"AxisIndices.next_type","text":"next_type(x::T)\n\nReturns the immediately greater value of type T.\n\nExamples\n\njulia> using AxisIndices\n\njulia> AxisIndices.next_type(\"b\")\n\"c\"\n\njulia> AxisIndices.next_type(:b)\n:c\n\njulia> AxisIndices.next_type('a')\n'b': ASCII/Unicode U+0062 (category Ll: Letter, lowercase)\n\njulia> AxisIndices.next_type(1)\n2\n\njulia> AxisIndices.next_type(2.0)\n2.0000000000000004\n\njulia> AxisIndices.next_type(\"\")\n\"\"\n\n\n\n\n\n","category":"function"},{"location":"resize_axes/#AxisIndices.prev_type","page":"Resizing Axes","title":"AxisIndices.prev_type","text":"prev_type(x::T)\n\nReturns the immediately lesser value of type T.\n\nExamples\n\njulia> using AxisIndices\n\njulia> AxisIndices.prev_type(\"b\")\n\"a\"\n\njulia> AxisIndices.prev_type(:b)\n:a\n\njulia> AxisIndices.prev_type('b')\n'a': ASCII/Unicode U+0061 (category Ll: Letter, lowercase)\n\njulia> AxisIndices.prev_type(1)\n0\n\njulia> AxisIndices.prev_type(1.0)\n0.9999999999999999\n\njulia> AxisIndices.prev_type(\"\")\n\"\"\n\n\n\n\n\n","category":"function"},{"location":"reindex_axes/#Reindexing-Axes-1","page":"Reindexing Axes","title":"Reindexing Axes","text":"","category":"section"},{"location":"reindex_axes/#","page":"Reindexing Axes","title":"Reindexing Axes","text":"AxisIndices.reindex\nAxisIndices.unsafe_reindex","category":"page"},{"location":"reindex_axes/#AxisIndices.reindex","page":"Reindexing Axes","title":"AxisIndices.reindex","text":"reindex(a::AbstractAxis, inds::AbstractVector{Integer}) -> AbstractAxis\n\nReturns an AbstractAxis of the same type as a where the keys of the axis are constructed by indexing into the keys of a with inds (keys(a)[inds]) and the values have the same first element as first(values(a)) but a length matching inds.\n\nExamples\n\njulia> using AxisIndices\n\njulia> x, y, z = Axis(1:10, 2:11), Axis(1:10), SimpleAxis(1:10);\n\njulia>  reindex(x, collect(1:2:10))\nAxis([1, 3, 5, 7, 9] => 2:6)\n\njulia> reindex(y, collect(1:2:10))\nAxis([1, 3, 5, 7, 9] => Base.OneTo(5))\n\njulia> reindex(z, collect(1:2:10))\nSimpleAxis(1:5)\n\n\n\n\n\n\n","category":"function"},{"location":"reindex_axes/#AxisIndices.unsafe_reindex","page":"Reindexing Axes","title":"AxisIndices.unsafe_reindex","text":"unsafe_reindex(a::AbstractAxis, inds::AbstractVector) -> AbstractAxis\n\nSimilar to reindex this function returns an index of the same type as a but doesn't check that inds is inbounds. New subtypes of AbstractAxis must implement a unique unsafe_reindex method.\n\nSee also: reindex\n\nExamples\n\njulia> using AxisIndices\n\njulia> AxisIndices.unsafe_reindex(SimpleAxis(OneToMRange(10)), 1:5)\nSimpleAxis(OneToMRange(5))\n\njulia> AxisIndices.unsafe_reindex(SimpleAxis(OneToSRange(10)), 1:5)\nSimpleAxis(OneToSRange(5))\n\n\n\n\n\n","category":"function"},{"location":"append_axes/#Appending-Axes-1","page":"Appending Axes","title":"Appending Axes","text":"","category":"section"},{"location":"append_axes/#","page":"Appending Axes","title":"Appending Axes","text":"AxisIndices.append_axis\nAxisIndices.append_axis!\nAxisIndices.append_keys\nAxisIndices.append_values","category":"page"},{"location":"append_axes/#AxisIndices.append_axis","page":"Appending Axes","title":"AxisIndices.append_axis","text":"append_axis(x, y)\n\nReturns the appended axes x and y. New subtypes of AbstractAxis must implement a unique append_axis method.\n\nExamples\n\njulia> using AxisIndices\n\njulia> append_axis(Axis(UnitMRange(1, 10)), SimpleAxis(UnitMRange(1, 10)))\nAxis(UnitMRange(1:20) => UnitMRange(1:20))\n\njulia> append_axis(SimpleAxis(UnitMRange(1, 10)), SimpleAxis(UnitMRange(1, 10)))\nSimpleAxis(UnitMRange(1:20))\n\n\n\n\n\n","category":"function"},{"location":"append_axes/#AxisIndices.append_axis!","page":"Appending Axes","title":"AxisIndices.append_axis!","text":"append_axis!(x, y)\n\nReturns the appended axes x and y. New subtypes of AbstractAxis must implement a unique append_axis! method.\n\nExamples\n\njulia> using AxisIndices\n\njulia> x, y = Axis(UnitMRange(1, 10)), SimpleAxis(UnitMRange(1, 10));\n\njulia> append_axis!(x, y);\n\njulia> length(x)\n20\n\njulia> append_axis!(y, x);\n\njulia> length(y)\n30\n\n\n\n\n\n","category":"function"},{"location":"append_axes/#AxisIndices.append_keys","page":"Appending Axes","title":"AxisIndices.append_keys","text":"append_keys(x, y)\n\nReturns the appropriate keys of and index within the operation append_axis(x, y)\n\nSee also: append_axis\n\n\n\n\n\n","category":"function"},{"location":"append_axes/#AxisIndices.append_values","page":"Appending Axes","title":"AxisIndices.append_values","text":"append_values(x, y)\n\nReturns the appropriate values of and index within the operation append_axis(x, y)\n\nSee also: append_axis\n\n\n\n\n\n","category":"function"},{"location":"combine_axes/#Combining-Axes-1","page":"Combining Axes","title":"Combining Axes","text":"","category":"section"},{"location":"combine_axes/#","page":"Combining Axes","title":"Combining Axes","text":"These methods are responsible for assisting in broadcasting operations.","category":"page"},{"location":"combine_axes/#","page":"Combining Axes","title":"Combining Axes","text":"AxisIndices.combine_axis\nAxisIndices.combine_values\nAxisIndices.combine_keys","category":"page"},{"location":"combine_axes/#AxisIndices.combine_axis","page":"Combining Axes","title":"AxisIndices.combine_axis","text":"combine_axis(x, y) -> collection\n\nReturns the combination of axes x and y. This method relies on combine_values and combine_keys to form a new axis.\n\nExamples\n\njulia> using AxisIndices\n\njulia> a, b = 1:10, Base.OneTo(10);\n\njulia> combine_axis(a, SimpleAxis(b))\nSimpleAxis(1:10)\n\njulia> combine_axis(a, b)\n1:10\n\njulia> combine_axis(b, a)\n1:10\n\njulia> c = combine_axis(a, SimpleAxis(b))\nSimpleAxis(1:10)\n\njulia> d = combine_axis(SimpleAxis(b), a)\nSimpleAxis(1:10)\n\njulia> e = combine_axis(c, d)\nSimpleAxis(1:10)\n\njulia> f = combine_axis(Axis(a), a)\nAxis(1:10 => 1:10)\n\njulia> g = combine_axis(a, Axis(b))\nAxis(Base.OneTo(10) => 1:10)\n\njulia> combine_axis(f, g)\nAxis(1:10 => 1:10)\n\n\n\n\n\n\n","category":"function"},{"location":"combine_axes/#AxisIndices.combine_values","page":"Combining Axes","title":"AxisIndices.combine_values","text":"combine_values(x, y)\n\nReturns the combination of the values of x and y, creating a new index. New subtypes of AbstractAxis may implement a unique combine_values method if  needed. Default behavior is to use the return of promote_rule(x, y) for the type of the combined values.\n\n\n\n\n\n","category":"function"},{"location":"combine_axes/#AxisIndices.combine_keys","page":"Combining Axes","title":"AxisIndices.combine_keys","text":"combine_keys(x, y)\n\nReturns the combination of x and y, assuming they are keys to another structure. Default behavior is to use promote_rule for converting x. This method should be overloaded to accomodate combining keys where a traditional promotion isn't appropriate.\n\nExamples\n\nThe default behavior is to promote the first argument.\n\njulia> using AxisIndices\n\njulia> combine_keys(Base.OneTo(10), Base.OneTo(10))\nBase.OneTo(10)\n\njulia> combine_keys(1:10, Base.OneTo(10))\n1:10\n\nUsing combine_keys allows combining axes that aren't appropriate for conventional promotion.\n\njulia> combine_keys(1:2, string.(1:2))\n2-element Array{String,1}:\n \"1\"\n \"2\"\n\njulia> combine_keys(1:2, Symbol.(1:2))\n2-element Array{Symbol,1}:\n Symbol(\"1\")\n Symbol(\"2\")\n\n\n\n\n\n\n","category":"function"},{"location":"axis_intro/#Introduction-to-the-AbstractAxis-1","page":"Introduction","title":"Introduction to the AbstractAxis","text":"","category":"section"},{"location":"axis_intro/#","page":"Introduction","title":"Introduction","text":"The supertype to all axis types herein is the AbstractAxis, which is a subtype of AbstractUnitRange{<:Integer}.","category":"page"},{"location":"axis_intro/#","page":"Introduction","title":"Introduction","text":"The vocabulary can get a bit a tricky here and documentation tries to stick to these functional definitions:","category":"page"},{"location":"axis_intro/#","page":"Introduction","title":"Introduction","text":"axis: maps a set of keys to a set of indices.\nindices: a set of integers (e.g., <:Integer) that locate the in memory locations of a elements.\nkeys: maps a set of any type to a set of indices","category":"page"},{"location":"axis_intro/#","page":"Introduction","title":"Introduction","text":"If we have a set of keys a b c and a set of indices 1 2 3 then the key a maps to the index 1. Given these definitions, the AbstractAxis differs from the classic dictionary in the following two ways:","category":"page"},{"location":"axis_intro/#","page":"Introduction","title":"Introduction","text":"The valtype of AbstractAxis is always an integer.\nThe values are always unique and continuous.","category":"page"},{"location":"axis_intro/#","page":"Introduction","title":"Introduction","text":"The two main axis types defined here are Axis and SimpleAxis. The standard syntax for indexing doesn't change at all for these types.","category":"page"},{"location":"axis_intro/#","page":"Introduction","title":"Introduction","text":"julia> using AxisIndices, Dates\n\njulia> sa = SimpleAxis(1:10)\nSimpleAxis(1:10)\n\njulia> sa[2]\n2\n\njulia> sa[>(2)]\nSimpleAxis(3:10)\n\njulia> a = Axis(1:10)\nAxis(1:10 => Base.OneTo(10))\n\njulia> a[2]\n2\n\njulia> a[2:3]\nAxis(2:3 => 2:3)","category":"page"},{"location":"axis_intro/#","page":"Introduction","title":"Introduction","text":"But now we can also use functions to index by the keys of an AbstractAxis.","category":"page"},{"location":"axis_intro/#","page":"Introduction","title":"Introduction","text":"julia> a = Axis(2.0:11.0, 1:10)\nAxis(2.0:1.0:11.0 => 1:10)\n\njulia> a[1]\n1\n\njulia> a[isequal(2.0)]\n1\n\njulia> a[>(2)]\nAxis(3.0:1.0:11.0 => 2:10)\n\njulia> a[>(2.0)]\nAxis(3.0:1.0:11.0 => 2:10)\n\njulia> a[and(>(2.0), <(8.0))]\nAxis(3.0:1.0:7.0 => 2:6)\n\njulia> sa[in(3:5)]\nSimpleAxis(3:5)","category":"page"},{"location":"axis_intro/#","page":"Introduction","title":"Introduction","text":"This also allows certain syntax special treatment because they are obviously not referring to traditional integer based indexing.","category":"page"},{"location":"axis_intro/#","page":"Introduction","title":"Introduction","text":"julia> x, y, z = Axis((:one, :two, :three)), Axis([\"one\", \"two\", \"three\"]), Axis(Second(1):Second(1):Second(3));\n\njulia> x[:one]\n1\n\njulia> x[:one] == y[\"one\"] == z[Second(1)]\ntrue\n\njulia> x[[:one, :two]]\n2-element Array{Int64,1}:\n 1\n 2","category":"page"},{"location":"axis_intro/#","page":"Introduction","title":"Introduction","text":"Note in the last example that a vector was returned instead of an AbstractAxis. An AbstractAxis is a subtype of AbstractUnitRange and therefore cannot be reformed after any operation that does not guarantee the return of another unit range. This is similar to the behavior of UnitRange in base.","category":"page"},{"location":"axis_intro/#How-Does-It-Work?-1","page":"Introduction","title":"How Does It Work?","text":"","category":"section"},{"location":"axis_intro/#","page":"Introduction","title":"Introduction","text":"This package makes a small alteration in the indexing pipeline for arrays from base. Where an array typically passes indices along a similar path to:","category":"page"},{"location":"axis_intro/#","page":"Introduction","title":"Introduction","text":"getindex(A::Array, i1, i2, i3) -> to_indices(A, axes(), (i1, i2, i3))\nto_indices(A, (ax1, ax2, ax3), (i1, i2, i3)) ->\n(to_index(A, i1), to_index(A, i2), to_index(A, i3)) -> I\n_getindex(A, I)","category":"page"},{"location":"axis_intro/#","page":"Introduction","title":"Introduction","text":"This package does:","category":"page"},{"location":"axis_intro/#","page":"Introduction","title":"Introduction","text":"getindex(A::Array, i1, i2, i3) -> to_indices(A, axes(), (i1, i2, i3))\nto_indices(A, (ax1, ax2, ax3), (i1, i2, i3)) ->\n(to_index(ax1, i1), to_index(ax2, i2), to_index(ax3, i3)) -> I\n_getindex(A, I)","category":"page"},{"location":"axis_intro/#","page":"Introduction","title":"Introduction","text":"This allows customizing the initial arguments given to getindex per each axis instead of by the array type or the type of i1/2/3.","category":"page"},{"location":"axis_intro/#Performance-1","page":"Introduction","title":"Performance","text":"","category":"section"},{"location":"axis_intro/#","page":"Introduction","title":"Introduction","text":"Indexing CartesianAxes is comparable to that of CartesianIndices.","category":"page"},{"location":"axis_intro/#","page":"Introduction","title":"Introduction","text":"julia> using AxisIndices, BenchmarkTools\n\njulia> cartaxes = CartesianAxes((Axis(2.0:5.0), Axis(1:4)));\n\njulia> cartinds = CartesianIndices((1:4, 1:4));\n\njulia> @btime getindex(cartaxes, 2, 2)\n  20.848 ns (1 allocation: 32 bytes)\nCartesianIndex(2, 2)\n\njulia> @btime getindex(cartinds, 2, 2)\n  22.317 ns (1 allocation: 32 bytes)\nCartesianIndex(2, 2)\n\njulia> @btime getindex(cartaxes, ==(3.0), 2)\n  444.374 ns (7 allocations: 416 bytes)\nCartesianIndex(2, 2)","category":"page"},{"location":"axis_intro/#","page":"Introduction","title":"Introduction","text":"Indexing LinearAxes is comparable to that of LinearIndices","category":"page"},{"location":"axis_intro/#","page":"Introduction","title":"Introduction","text":"julia> using AxisIndices, BenchmarkTools\n\njulia> linaxes = LinearAxes((Axis(1.0:4.0), Axis(1:4)));\n\njulia> lininds = LinearIndices((1:4, 1:4));\n\njulia> @btime getindex(linaxes, 2, 2)\n  18.275 ns (0 allocations: 0 bytes)\n6\n\njulia> @btime getindex(lininds, 2, 2)\n  18.849 ns (0 allocations: 0 bytes)\n6\n\njulia> @btime getindex(linaxes, ==(3.0), 2)\n  381.098 ns (6 allocations: 384 bytes)\n7","category":"page"},{"location":"axis_intro/#","page":"Introduction","title":"Introduction","text":"You may notice there's significant overhead for using the filtering syntax. However, the filtering syntax takes advantage of a special type in base, Fix2. This means that we can take advantage of filtering methods that have been optimized for specific types of keys.  Here we do the same thing as above but we create a function that knows it's going to perform filtering.","category":"page"},{"location":"axis_intro/#","page":"Introduction","title":"Introduction","text":"julia> getindex_filter(a, i1, i2) = a[==(i1), ==(i2)]\ngetindex_filter (generic function with 1 method)\n\njulia> @btime getindex_filter(linaxes, 3.0, 2)\n  57.216 ns (0 allocations: 0 bytes)\n7\n\njulia> linaxes2 = LinearAxes((Axis(Base.OneTo(4)), Axis(Base.OneTo(4))));\n\njulia> @btime getindex_filter(linaxes2, 3, 2)\n  22.070 ns (0 allocations: 0 bytes)\n7","category":"page"},{"location":"axis_intro/#","page":"Introduction","title":"Introduction","text":"Indexing linaxes is much faster now that it can be optimized inside of a function call. However, it's still a little over twice as slow as normal indexing. That's largely because of the cost of searching 1.0:4.0 (which is a StepRangeLen type in this case). The second benchmark demonstrates how close we really are to standard indexing given similar range types.","category":"page"},{"location":"concat_axes/#Concatenating-Axes-1","page":"Concatenating Axes","title":"Concatenating Axes","text":"","category":"section"},{"location":"concat_axes/#","page":"Concatenating Axes","title":"Concatenating Axes","text":"AxisIndices.cat_axes\nAxisIndices.hcat_axes\nAxisIndices.vcat_axes\nAxisIndices.cat_axis\nAxisIndices.cat_values\nAxisIndices.cat_keys","category":"page"},{"location":"concat_axes/#AxisIndices.cat_axes","page":"Concatenating Axes","title":"AxisIndices.cat_axes","text":"cat_axes(x, y, dims) -> Tuple\n\nReturns the appropriate axes for cat(x, y; dims). If any of dims are names then they should refer to the dimensions of x.\n\nExamples\n\njulia> using AxisIndices\n\njulia> cat_axes(LinearAxes((2,3)), LinearAxes((2,3)), dims=(1,2))\n(SimpleAxis(Base.OneTo(4)), SimpleAxis(Base.OneTo(6)))\n\n\n\n\n\n","category":"function"},{"location":"concat_axes/#AxisIndices.hcat_axes","page":"Concatenating Axes","title":"AxisIndices.hcat_axes","text":"hcat_axes(x, y) -> Tuple\n\nReturns the appropriate axes for hcat(x, y).\n\nExamples\n\njulia> using AxisIndices\n\njulia> hcat_axes((Axis(1:4), Axis(1:2)), (Axis(1:4), Axis(1:2)))\n(Axis(1:4 => Base.OneTo(4)), Axis(1:4 => Base.OneTo(4)))\n\njulia> a, b = [1; 2; 3; 4; 5], [6 7; 8 9; 10 11; 12 13; 14 15];\n\njulia> hcat_axes(a, b) == axes(hcat(a, b))\ntrue\n\njulia> c, d = CartesianAxes((Axis(1:5),)), CartesianAxes((Axis(1:5), Axis(1:2)));\n\njulia> length.(hcat_axes(c, d)) == length.(hcat_axes(a, b))\ntrue\n\n\n\n\n\n","category":"function"},{"location":"concat_axes/#AxisIndices.vcat_axes","page":"Concatenating Axes","title":"AxisIndices.vcat_axes","text":"vcat_axes(x, y) -> Tuple\n\nReturns the appropriate axes for vcat(x, y).\n\nExamples\n\njulia> using AxisIndices\n\njulia> vcat_axes((Axis(1:2), Axis(1:4)), (Axis(1:2), Axis(1:4)))\n(Axis(1:4 => Base.OneTo(4)), Axis(1:4 => Base.OneTo(4)))\n\njulia> a, b = [1 2 3 4 5], [6 7 8 9 10; 11 12 13 14 15];\n\njulia> vcat_axes(a, b) == axes(vcat(a, b))\ntrue\n\njulia> c, d = LinearAxes((1:1, 1:5,)), LinearAxes((1:2, 1:5));\n\njulia> length.(vcat_axes(c, d)) == length.(vcat_axes(a, b))\ntrue\n\n\n\n\n\n","category":"function"},{"location":"concat_axes/#AxisIndices.cat_axis","page":"Concatenating Axes","title":"AxisIndices.cat_axis","text":"cat_axis(x, y)\n\nReturns the concatenation of the axes x and y. New subtypes of AbstractAxis must implement a unique cat_axis method.\n\n\n\n\n\n","category":"function"},{"location":"concat_axes/#AxisIndices.cat_values","page":"Concatenating Axes","title":"AxisIndices.cat_values","text":"cat_values(x, y)\n\nReturns the appropriate values of the x and y index within the operation cat_axis(x, y)\n\nSee also: cat_axis\n\n\n\n\n\n","category":"function"},{"location":"concat_axes/#AxisIndices.cat_keys","page":"Concatenating Axes","title":"AxisIndices.cat_keys","text":"cat_keys(x, y)\n\nReturns the appropriate keys of the x and y index within the operation cat_axis(x, y)\n\nSee also: cat_axis\n\n\n\n\n\n","category":"function"},{"location":"#AxisIndices-1","page":"Introduction","title":"AxisIndices","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"The core contribution provided by AxisIndices is the AbstractAxis type. It is a subtype of AbstractUnitRange{<:Integer} with an additional interface for creating keys and interacting with them. This additional interface is intended to be easily extended to new types that may be needed for a variety of different situations. An additional AxisIndicesArray type is provided that uses any subtype of AbstractAxis for each axis. However, many methods are provided and documented internally so that it's easy for users to alter the behavior of an AxisIndicesArray with a new AbstractAxis subtype or create an entirely unique multidimensional structure.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"The goals of this package are:","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Facilitate multidimensional indexing (e.g., instance_of_an_array[indices]) that supports semantic user facing indices (e.g., indices = Second(1)).\nAccomplishing the first goal should not interfere in the ability to perform the vast majority of array related methods (e.g, vcat, append!, etc.).\nIt should be easy to implement new subtypes of AbstractAxis that accommodate novel behavior and needs.","category":"page"}]
}
